# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_river.ipynb.

# %% auto #0
__all__ = ['RiverDemo', 'River', 'find_local_minima', 'SoilType', 'SoilSystem', 'soilInformation', 'ErosionModel']

# %% ../nbs/06_river.ipynb #91bb6416
#standard
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple, deque
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

# unique
from treelib import Tree
import heapq


# %% ../nbs/06_river.ipynb #a00c60ae
from .styles import StyleCSS, SVGBuilder,SVGLayer, SVGPatternLoader, preview, app, StyleDemo
from .primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexWrapper, HexPosition, hexBackground,windy_edge, HexRegion
from .terrain import  TerraDemo, Terrain
from .terrainpatterns import TerrainPatterns


# %% ../nbs/06_river.ipynb #dd61c75a
from .voronoi import PlateKind

# %% ../nbs/06_river.ipynb #e71cfd34
class RiverDemo:
    def __init__(self):
        self.help = ""

# %% ../nbs/06_river.ipynb #77f6b2d1
class River:
    def __init__(self, terrain):
        self.terrain = terrain
        self.tree = Tree()
        self.hexes = set()  # All hex indices for quick intersection checks
        self.ocean_outlet = None

    @property
    def is_empty(self):
        return self.tree.size() == 0
    
    @classmethod
    def from_peak(cls, terrain, peak_index):
        """Create a river by tracing downhill from a peak."""
      
        
        # Trace downhill to find the outlet first
        path = [peak_index]
        current = peak_index
        
        while True:
            lowest = terrain.lowest_neighbor(current)
            # Stop if local minimum or hit water
            if lowest is None or terrain.elevations[lowest] < 1:
                break
            path.append(lowest)
            current = lowest
        # Don't create river if path is too short (just the peak itself)
        if len(path) < 2:
            return None
        
        # Build tree from outlet (root) upward
        # Reverse path so outlet is first
        path.reverse()
        
        river = River(terrain)
        # Create root node with the path as a single segment
        river.tree.create_node(tag="segment", identifier=0, data=path)
        river.hexes.update(path)
        
        return river
    
    @staticmethod
    def combine_rivers(rivers):
        """Merge intersecting rivers, return list with no intersections."""
        result = list(rivers)
        
        changed = True
        while changed:
            changed = False
            for i in range(len(result)):
                for j in range(i + 1, len(result)):
                    # Check for intersection
                    intersection = result[i].hexes & result[j].hexes
                    if intersection:
                        # Merge j into i
                        merged = result[i]._merge_with(result[j], intersection)
                        result[i] = merged
                        result.pop(j)
                        changed = True
                        break
                if changed:
                    break
        
        result = [r for r in result if not r.is_empty]
        return result
    
    def _merge_with(self, other, intersection):
        """Merge another river into this one at intersection point."""
        # TODO: implement tree merging logic
        # For now, just combine the hex sets
        merged = River(self.terrain)
        merged.hexes = self.hexes | other.hexes
        # Tree merging is more complex - need to attach other's
        # upstream portion at the intersection point
        return merged


# %% ../nbs/06_river.ipynb #24162299
# In River class

@patch  
def show(self:River):
    """Display river tree structure with hex indices."""
    if self.tree.size() == 0:
        print("Empty river")
        return
    
    # Recursively print the tree with custom formatting
    def print_node(node, indent=0):
        # Print the hex indices for this segment
        indices_str = ", ".join(map(str, node.data))
        print("    " * indent + indices_str)
        
        # Print children
        children = self.tree.children(node.identifier)
        for child in children:
            print_node(child, indent + 1)
    
    # Start from root
    root = self.tree.get_node(self.tree.root)
    print_node(root)



# %% ../nbs/06_river.ipynb #98c5b4f8
@patch
def midTerrain(self:RiverDemo):

    mySize = MapSize(480,480)
    myBounds = MapRect(MapCord(0,0), mySize)
    sampleMap =  Terrain(myBounds,radius=15,path = "volcano.svg")
    for center in [23,46,57,81,123,145,167,189,211,233,255]:
        sampleMap.volcano(center=center*3,adjusted=200,num_rings=8,variability=0.5,initial_threshold=0.4)
    sampleMap.colorMap()
    sampleMap.hexGrid.update()

    return sampleMap

@patch
def demoRiver(self:RiverDemo):
    sampleMap = self.midTerrain()
    peaks = sampleMap.find_peaks(40,1)
    rivers = [River.from_peak(sampleMap, peak) for peak in peaks]
    rivers = [r for r in rivers if r is not None]  # Filter out None rivers
    rivers = River.combine_rivers(rivers)

    for river in rivers:
        print("====")
        river.show()
    



# %% ../nbs/06_river.ipynb #785479e1
@patch 
def _merge_with(self:River, other, intersection):
    """Merge another river into this one at intersection point."""
    merged = River(self.terrain)
    
    # Start with a copy of self's tree
    merged.tree = Tree(self.tree, deep=True)
    merged.hexes = self.hexes.copy()
    
    # Find the furthest upstream intersection point (highest elevation)
    intersection_hex = max(intersection, key=lambda h: self.terrain.elevations[h])
    
    for node in merged.tree.all_nodes():
        if intersection_hex in node.data:
            # Found the node containing intersection
            idx = node.data.index(intersection_hex)
            
            if idx == len(node.data) - 1:
                # Case 1: intersection at end of list
                attach_point = node.identifier
            else:
                # Case 2: intersection in middle - need to split
                # Keep [0:idx+1] in current node
                downstream = node.data[:idx+1]
                upstream = node.data[idx+1:]
                
                node.data = downstream
                
                # Create new child with upstream portion
                new_id = merged.tree.size()
                merged.tree.create_node(
                    tag="segment",
                    identifier=new_id,
                    parent=node.identifier,
                    data=upstream
                )
                
                # Move existing children to new node
                for child in merged.tree.children(node.identifier):
                    if child.identifier != new_id:
                        merged.tree.move_node(child.identifier, new_id)
                
                attach_point = node.identifier
            
            # Now trim and attach other tree
            trimmed_other = merged._trim_tree(other, intersection_hex)
            if trimmed_other:
                merged._attach_tree(trimmed_other, attach_point)
            
            break
    
    merged.hexes.update(other.hexes)
    return merged


@patch 
def _trim_tree(self:River, other, intersection_hex):
    """Return a copy of other's tree with everything at/below intersection removed."""
    # Find node containing intersection in other's tree
    for node in other.tree.all_nodes():
        if intersection_hex in node.data:
            idx = node.data.index(intersection_hex)
            
            # Keep only portion after intersection
            if idx == len(node.data) - 1:
                # Intersection at end, keep children
                # Return subtree starting from children
                trimmed = Tree()
                for child in other.tree.children(node.identifier):
                    trimmed = other.tree.subtree(child.identifier)
                    break  # For now just take first child, may need to handle multiple
                return trimmed
            else:
                # Split node, keep upstream portion
                trimmed = Tree(other.tree, deep=True)
                trim_node = trimmed.get_node(node.identifier)
                trim_node.data = trim_node.data[idx+1:]
                return trimmed
    
    return None
@patch 
def _attach_tree(self:River, other_tree, parent_id):
    """Attach other_tree's root(s) as children of parent_id."""
    if other_tree.size() == 0:
        return
    
    # Get next available ID
    next_id = self.tree.size()
    
    # Recursively copy nodes from other_tree
    def copy_subtree(other_node, new_parent_id):
        nonlocal next_id
        new_node_id = next_id
        next_id += 1
        
        self.tree.create_node(
            tag=other_node.tag,
            identifier=new_node_id,
            parent=new_parent_id,
            data=other_node.data.copy()
        )
        
        for child in other_tree.children(other_node.identifier):
            copy_subtree(child, new_node_id)
    
    # Copy from other's root
    other_root = other_tree.get_node(other_tree.root)
    copy_subtree(other_root, parent_id)


# %% ../nbs/06_river.ipynb #93ee1d1c
@patch
def showIndices(self:Terrain):
    ret = ""
    i = 0
    for row in range(self.hexGrid.nRows):
        line = ""
        for col in range(self.hexGrid.nCols):
            line += f"{i:3} "
            i += 1
        ret += line + "\n"
    return ret


# %% ../nbs/06_river.ipynb #f5063efa
@patch
def demoRiverMerge(self:RiverDemo):
    sampleMap = TerraDemo().tiny()
    print(sampleMap.showIndices())
    print()
    
    # Create three rivers manually
    river1 = River(sampleMap)
    river1.tree.create_node(tag="segment", identifier=0, data=[4, 5, 6])
    river1.hexes = {4, 5, 6}
    
    river2 = River(sampleMap)
    river2.tree.create_node(tag="segment", identifier=0, data=[5, 9, 14])
    river2.hexes = {5, 9, 14}
    
    river3 = River(sampleMap)
    river3.tree.create_node(tag="segment", identifier=0, data=[14, 11])
    river3.hexes = {14, 11}
    
    print("Before merge:")
    print("River 1:")
    river1.show()
    print("\nRiver 2:")
    river2.show()
    print("\nRiver 3:")
    river3.show()
    
    # Merge them
    rivers = [river1, river2, river3]
    merged = River.combine_rivers(rivers)
    
    print("\n\nAfter merge:")
    for i, river in enumerate(merged):
        print(f"\nMerged River {i+1}:")
        river.show()
    
    




# %% ../nbs/06_river.ipynb #b890c33b
@patch
def svg(self: River, styles=[StyleCSS("river", fill="none", stroke="blue", stroke_width=4)]) -> str:
    """Render river as SVG path.
    
    Args:
        styles: List of styles for different depth levels (thicker for main channels)
    
    Returns:
        SVG path string
    """
    ret = ""
    terrain = self.terrain
   
    for i, node in enumerate(self.tree.all_nodes()):
        points = []
        
        # If this node has a parent, add connection point
        parent_id = node.predecessor(self.tree.identifier)
        if parent_id is not None:
            parent_node = self.tree.get_node(parent_id)
            # Connect last point of child to first point of parent
            parent_first_hex = parent_node.data[-1]
            points.append(terrain.hexGrid.hexes[parent_first_hex].center)

        # Add all hex centers in this segment
        points.extend([terrain.hexGrid.hexes[idx].center for idx in node.data])
        
        # If this segment has ocean_outlet, extend to the border
        if self.ocean_outlet is not None:
            # Check if this is the outlet segment (last in path)
            if len(node.data) > 0:
                last_hex_idx = node.data[-1]
                last_hex = terrain.hexGrid.hexes[last_hex_idx]
                ocean_hex = terrain.hexGrid.hexes[self.ocean_outlet]
                
                # Add edge point (midpoint between last land hex and ocean hex)
                edge_point = MapCord(
                    (last_hex.center.x + ocean_hex.center.x) / 2,
                    (last_hex.center.y + ocean_hex.center.y) / 2
                )
                points.append(edge_point)

        # Select style based on tree depth (deeper = thicker)
        depth = self.tree.depth(node.identifier)
        style_index = min(depth, len(styles) - 1)
        
        # Create path and make it windy
        aPath = MapPath([], style=styles[style_index])
        aPath.points = points
        windy_river = aPath.make_windy(iterations=max(5 - i, 2), offset_factor=0.2)
        ret += windy_river.drawSpline()

    return ret


# %% ../nbs/06_river.ipynb #908c0574
@patch
def getLargestRiver(self:Terrain, num_peaks=40, min_height=1):
    """Find peaks, create rivers, merge them, and return the largest one."""
    peaks = self.find_peaks(num_peaks, min_height)
    rivers = [River.from_peak(self, peak) for peak in peaks]
    rivers = [r for r in rivers if r is not None]
    merged = River.combine_rivers(rivers)
    
    if not merged:
        return None
    
    # Return river with most hexes
    return max(merged, key=lambda r: len(r.hexes))


# %% ../nbs/06_river.ipynb #73288bb5
@patch
def _calculate_flow(self:River):
    """Calculate accumulated flow for each hex in the river.
    Returns dict mapping hex_index -> flow_count"""
    flow = {}
    
    def traverse(node):
        # Start with hexes in this segment
        segment_flow = {}
        
        # Get flow from all children first (depth-first)
        child_flows = []
        for child in self.tree.children(node.identifier):
            child_flows.append(traverse(child))
        
        # Process this segment from end to beginning (upstream to downstream)
        for i in range(len(node.data) - 1, -1, -1):
            hex_idx = node.data[i]
            
            if i == len(node.data) - 1:
                # Last hex in segment - accumulate from children
                accumulated = 1  # This hex itself
                for child_flow in child_flows:
                    # Get flow from first hex of each child
                    accumulated += child_flow.get(node.data[i], 0)
            else:
                # Middle of segment - accumulate from next hex
                accumulated = 1 + segment_flow[node.data[i + 1]]
            
            segment_flow[hex_idx] = accumulated
            flow[hex_idx] = accumulated
        
        return segment_flow
    
    root = self.tree.get_node(self.tree.root)
    traverse(root)
    return flow


# %% ../nbs/06_river.ipynb #cbbcd791
@patch
def _calculate_gradient(self:River):
    """Calculate elevation gradient for each hex in the river.
    Returns dict mapping hex_index -> elevation_drop"""
    gradient = {}
    
    def traverse(node):
        # Process each hex in this segment
        for i in range(len(node.data)):
            hex_idx = node.data[i]
            current_elev = self.terrain.elevations[hex_idx]
            
            # Find next downstream hex
            if i > 0:
                # Next hex is earlier in the list (toward outlet)
                next_hex = node.data[i - 1]
            else:
                # At start of segment - check parent
                parent_id = node.predecessor(self.tree.identifier)
                if parent_id is not None:
                    parent_node = self.tree.get_node(parent_id)
                    next_hex = parent_node.data[-1]  # Last hex of parent
                else:
                    # At outlet - no gradient
                    gradient[hex_idx] = 0
                    continue
            
            next_elev = self.terrain.elevations[next_hex]
            drop = max(0, current_elev - next_elev)  # Only positive drops
            gradient[hex_idx] = drop
        
        # Recurse to children
        for child in self.tree.children(node.identifier):
            traverse(child)
    
    root = self.tree.get_node(self.tree.root)
    traverse(root)
    return gradient


# %% ../nbs/06_river.ipynb #f2c9b3fb
@patch
def demoGradient(self:RiverDemo):

    fills=["#d4ff00eb","#ffb300ff","#ff0073ff","#9900ff97","#1e0e45eb"]
    riverStyle = StyleCSS("river",fill="none",stroke="blue",stroke_width=4)
    sampleMap = TerraDemo().sanFran()
    
    sampleMap.hexGrid.adjustRadius(15)
    aRender = sampleMap.hexGrid.builder
   
    peaks = sampleMap.find_peaks(35,7)

    rivers = [River.from_peak(sampleMap, peak) for peak in peaks]
    rivers = [r for r in rivers if r is not None]  # Filter out None rivers
    colors = []
    legends = []
    for i, c  in enumerate(fills):
        aStyle = StyleCSS(f"river{i}",fill="none",stroke=c ,stroke_width=4)
        colors.append(aStyle)
        aRender.add_style(aStyle)

        aStyle = StyleCSS(f"Level_{i+1}",fill=c,stroke="#000000" ,stroke_width=2)
        legends.append(aStyle)
        aRender.add_style(aStyle)
    
    #print(StyleCSS.generate(colors))
    # Merge them
    merged = River.combine_rivers(rivers)
    rivSVG = ""
    

    flowData = np.zeros(len(sampleMap.hexGrid.hexes)) - 1

    for i, stream in enumerate(merged):
        rivSVG += stream.svg(styles = colors)
        flows = stream._calculate_gradient()
        streamFlow = np.zeros(len(sampleMap.hexGrid.hexes)) - 1
        for k,v in flows.items():
            streamFlow[k] = v
        flowData = np.maximum(flowData,streamFlow)

    sampleMap.colorMap()
    sampleMap.hexGrid.update()
    
    flowData = [int(x) for x in flowData]
    # Create patterns and overlay
    patternGen = TerrainPatterns(sampleMap)
    patterns = patternGen.ballDensity(max(flowData),fills=fills)  # 5 levels
    sampleMap.makeOverlay(flowData, patterns)
    
        
    sampleMap.colorMap()
    sampleMap.hexGrid.update()

    aRender.adjust("rivers", rivSVG)
    aRender.adjust("root","")
    sampleMap.addCoast()
    aRender.adjust("legend",drawLegend(legends))
    
    #return max(flowData)
    return aRender.show()



# %% ../nbs/06_river.ipynb #9b090465
@patch
def carve(self:River, base_erosion=0.5, valley_width=3, lower = 40, shape='river'):
    """Carve a valley along this river/glacier path."""
    
    adjustments = {}
    adjusted_hexes = set()
    
    # 1. Sort by elevation (highest first = upstream to downstream)
    sorted_hexes = sorted(self.hexes, key=lambda i: self.terrain.elevations[i], reverse=True)
    
    cumulative_flow = 0

    for hex_idx in sorted_hexes:
        self.terrain.elevations[hex_idx] = max(self.terrain.elevations[hex_idx]-lower,0)
    
    for i, hex_idx in enumerate(sorted_hexes):
        # 2. Calculate on the fly
        cumulative_flow += 1  # Each hex adds unit flow
        
        if i < len(sorted_hexes) - 1:
            next_hex = sorted_hexes[i + 1]
            gradient = self.terrain.elevations[hex_idx] - self.terrain.elevations[next_hex] + lower
        else:
            gradient = 0.1  # Small default at mouth
        
        power = cumulative_flow * max(gradient, 0.01)
        erosion_amount = base_erosion * power
        
        # Erode river hex itself
        if hex_idx not in adjusted_hexes:
            adjustments[hex_idx] = -erosion_amount
            adjusted_hexes.add(hex_idx)
        
        # 3. Spread to neighbors (only unadjusted hexes)
        for dist in range(1, valley_width + 1):
            ring = self.terrain.ring(hex_idx, dist)
            
            for n in ring:
                if n in adjusted_hexes:
                    continue
                
                if shape == 'river':
                    decay = erosion_amount * (0.5 ** dist)
                else:  # glacier
                    decay = erosion_amount * (1 - dist / (valley_width + 1))
                
                adjustments[n] = -decay
                adjusted_hexes.add(n)
    
    return adjustments


# %% ../nbs/06_river.ipynb #d108f30a
@patch
def flow_directions(self: Terrain) -> np.ndarray:
    """Return array where each hex points to its downhill neighbor, or -1 if minimum."""
    n = len(self.elevations)
    directions = np.full(n, -1, dtype=int)
    
    for i in range(n):
        lowest = self.lowest_neighbor(i)
        if lowest is not None and self.elevations[lowest] < self.elevations[i]:
            directions[i] = lowest
    
    return directions

# %% ../nbs/06_river.ipynb #ab248538
@patch
def flow_diagram(self: Terrain) -> str:
    """Return array where each hex points to its downhill neighbor, or -1 if minimum."""
    n = len(self.elevations)
    overlay = ""
    style = StyleCSS("arrow", stroke="black",stroke_width=1)
    self.builder.add_style(style)

    directions = self.flow_directions()
    for i, x in enumerate(directions):
        if 0 <= x < n and self.elevations[i] > 0:


    
            path = MapPath([ self.hexGrid.hexes[i].center, self.hexGrid.hexes[x].center], style)
    
        
            overlay += path.with_arrowhead() + "\n"
    
    return overlay

# %% ../nbs/06_river.ipynb #20130d47
def find_local_minima(self: Terrain) -> list[int]:
    """Return indices of land hexes that are local minima (potential lakes)."""
    directions = self.flow_directions()
    return [i for i in range(len(self.elevations)) 
            if directions[i] == -1 and self.elevations[i] > 0]


@patch
def find_drainage_path(self: Terrain, start: int) -> list[int]:
    """Find lowest-cost path from start to ocean using Dijkstra.
    
    Cost = elevation we'd need to carve (downhill = 0, uphill = diff).
    """
    
    
    ocean = {i for i in range(len(self.elevations)) if self.elevations[i] <= 0}
    if start in ocean:
        return [start]
    
    # (cost, current_hex, path)
    pq = [(0, start, [start])]
    visited = set()
    
    while pq:
        cost, current, path = heapq.heappop(pq)
        
        if current in visited:
            continue
        visited.add(current)
        
        if current in ocean:
            return path
        
        for neighbor in self.hexGrid.neighborsOf(current):
            if neighbor < 0 or neighbor in visited:
                continue
            
            # Cost = how much we'd need to lower neighbor to flow from current
            elev_curr = self.elevations[current]
            elev_neighbor = self.elevations[neighbor]
            
            # To flow, neighbor must be < current
            carve_cost = max(0, elev_neighbor - elev_curr + 1)
            
            new_cost = cost + carve_cost
            heapq.heappush(pq, (new_cost, neighbor, path + [neighbor]))
    
    return []  # No path found




# %% ../nbs/06_river.ipynb #6eeb3b81
@patch
def carve_to_ocean(self: Terrain, num_lakes: int = 5, max_iters: int = 10) ->  list[River]:
    """Carve drainage using lowest-cost paths to ocean."""
    paths = []
    
    for iteration in range(max_iters):
        minima = find_local_minima(self)
        if len(minima) <= num_lakes:
            print(f"Done at iter {iteration}: {len(minima)} lakes")
            break
        
        # Keep highest elevation minima as lakes
        minima.sort(key=lambda i: self.elevations[i], reverse=True)
        drain_these = minima[num_lakes:]
        
        for lake_idx in drain_these:
            path = self.find_drainage_path(lake_idx)
            river = River(terrain=self)
                   
            # Create root node with the path as a single segment
            river.tree.create_node(tag="segment", identifier=0, data=path)
            reversed(path)
            river.hexes.update(path)
            paths.append(river)
           
            
            if len(path) < 2:
                continue
            
            # Carve monotonically decreasing along path
            for i in range(len(path) - 1):
                curr, next_hex = path[i], path[i + 1]
                
                if self.elevations[next_hex] >= self.elevations[curr]:
                    self.elevations[next_hex] = self.elevations[curr] - 1
        
        new_count = len(find_local_minima(self))
        
    
    return  paths

# %% ../nbs/06_river.ipynb #e2f072fa
@patch
def compute_distance_to_coast(self: Terrain):
    """Calculate distance from coast for each hex using BFS."""
   
    
    n_hexes = len(self.elevations)
    distances = np.full(n_hexes, np.inf)
    
    # Find all coastal hexes (at or below sea level)
    coastal = [i for i in range(n_hexes) if self.elevations[i] <= 0]
    
    # BFS to calculate distances
    queue = deque()
    for coast_idx in coastal:
        distances[coast_idx] = 0
        queue.append((coast_idx, 0))
    
    visited = set(coastal)
    
    while queue:
        current_idx, dist = queue.popleft()
        
        # Check all neighbors
        neighbors = self.ring(current_idx, 1)
        for neighbor in neighbors:
            if neighbor >= 0 and neighbor not in visited:
                distances[neighbor] = dist + 1
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    self.fields['distance_to_coast'] = distances.astype(float)
    return self.fields['distance_to_coast']

# %% ../nbs/06_river.ipynb #5c1be915
@dataclass
class SoilType:
    """Represents a soil/bedrock type with erosion properties."""
    name: str
    bedrock: str  # Description of rock type
    erosion_resistance: float  # 0-1, higher = harder to erode
    permeability: float  # 0-1, higher = water flows through faster
    color: str  # Hex color for visualization
    
    @classmethod
    def standard_types(cls) -> List['SoilType']:
        """Five standard soil types from hard rock to sediment."""
        return [
            cls(
                name="Granite",
                bedrock="Plutonic igneous (continental crust)",
                erosion_resistance=0.9,
                permeability=0.2,
                color="#8B7355"  # Gray-brown
            ),
            cls(
                name="Basalt",
                bedrock="Volcanic igneous (oceanic crust)",
                erosion_resistance=0.85,
                permeability=0.3,
                color="#4A4A4A"  # Dark gray
            ),
            cls(
                name="Limestone",
                bedrock="Sedimentary carbonate (dissolves)",
                erosion_resistance=0.5,
                permeability=0.6,
                color="#D4C5B9"  # Light tan
            ),
            cls(
                name="Sandstone",
                bedrock="Sedimentary clastic (crumbles)",
                erosion_resistance=0.4,
                permeability=0.7,
                color="#C2B280"  # Sandy tan
            ),
            cls(
                name="Alluvial",
                bedrock="Deposited sediment (clay/silt)",
                erosion_resistance=0.1,
                permeability=0.4,
                color="#8B6914"  # Dark gold/brown
            ),
        ]

# %% ../nbs/06_river.ipynb #d3b0da5b
@patch
def to_style(self: SoilType, stroke_width: float = 1.0, opacity: float = 1.0) -> StyleCSS:
    """Create a StyleCSS for this soil type.
    
    Args:
        stroke_width: Width of stroke for hex borders
        opacity: Opacity of the fill color (0-1)
    
    Returns:
        StyleCSS with soil color as fill
    """
    return StyleCSS(
        name=f"soil_{self.name.lower()}",
        fill=self.color,
        stroke="#000000",
        stroke_width=stroke_width,
        opacity=opacity
    )


# %% ../nbs/06_river.ipynb #a7ae2e7f
@dataclass
class SoilSystem:
    """Manages soil types and their distribution across terrain."""
    terrain: 'Terrain'
    types: List[SoilType]
    regions: List[HexRegion]  # One per type (index matches types)
    
    def __post_init__(self):
        """Ensure terrain has soil_type field."""
        if 'soil_type' not in self.terrain.fields:
            self.terrain.fields['soil_type'] = np.zeros(len(self.terrain.elevations), dtype=int)

    @classmethod
    def from_plates(cls, terrain: 'Terrain', plates: List['Plate'], 
                    elev_threshold: float = 50.0,
                    precip_threshold: float = 750.0,
                    debug: bool = False) -> 'SoilSystem':
        """Create soil system from plate tectonics and terrain properties.
        
        Args:
            terrain: Terrain with elevations and climate data
            plates: List of tectonic plates
            elev_threshold: Elevation below which alluvial can form (meters)
            precip_threshold: Precipitation above which limestone forms (mm/year)
            debug: Print diagnostic info
        
        Returns:
            SoilSystem with initial soil distribution
        """

        
        types = SoilType.standard_types()
        n_hexes = len(terrain.elevations)
        
        # Initialize soil_type array
        soil_type = np.zeros(n_hexes, dtype=int)
        
        # Map plates to hexes
        plate_map = {}  # hex_idx -> plate
        for plate in plates:
            for hex_idx in plate.hexes:
                plate_map[hex_idx] = plate
        
        # Ensure we have distance_to_coast
        if 'distance_to_coast' not in terrain.fields:
            terrain.compute_distance_to_coast()
        
        # Track counts for debug
        counts = {i: 0 for i in range(len(types))}
        
        for i in range(n_hexes):
            elev = terrain.elevations[i]
            
            # Ocean hexes get basalt (oceanic crust)
            if elev <= 0:
                soil_type[i] = 1  # Basalt
                counts[1] += 1
                continue
            
            # Get plate type
            plate = plate_map.get(i)
            is_oceanic = plate and plate.kind == PlateKind.oceanic
            
            # Coastal lowlands → Alluvial
            if elev < elev_threshold and terrain.fields['distance_to_coast'][i] <= 1:
                soil_type[i] = 4  # Alluvial
                counts[4] += 1
            
            # High elevation → Bedrock (Granite or Basalt from plate)
            elif elev > 1000:
                if is_oceanic:
                    soil_type[i] = 1  # Basalt
                    counts[1] += 1
                else:
                    soil_type[i] = 0  # Granite
                    counts[0] += 1
            
            # Mid elevation → Sedimentary (Limestone or Sandstone)
            else:
                # Use precipitation if available
                if 'precipitation' in terrain.fields:
                    precip = terrain.fields['precipitation'][i]
                    if precip > precip_threshold:
                        soil_type[i] = 2  # Limestone (wet)
                        counts[2] += 1
                    else:
                        soil_type[i] = 3  # Sandstone (dry)
                        counts[3] += 1
                else:
                    # Fallback: use plate type
                    if is_oceanic:
                        soil_type[i] = 2  # Limestone
                        counts[2] += 1
                    else:
                        soil_type[i] = 3  # Sandstone
                        counts[3] += 1
        
        # Store in terrain
        terrain.fields['soil_type'] = soil_type
        
        # Create regions for each type
        regions = []
        for type_idx in range(len(types)):
            hexes = set(np.where(soil_type == type_idx)[0])
            regions.append(HexRegion(hexes=hexes, hexGrid=terrain.hexGrid))
        
        if debug:
            print("\n=== SOIL SYSTEM CREATED ===")
            print(f"Total hexes: {n_hexes}")
            for i, soil_type_obj in enumerate(types):
                pct = 100 * counts[i] / n_hexes
                print(f"{soil_type_obj.name:12s}: {counts[i]:5d} hexes ({pct:5.1f}%)")
        
        return cls(terrain=terrain, types=types, regions=regions)

# %% ../nbs/06_river.ipynb #cd5d2f80
@patch
def soilOverlay(self:SoilSystem,f=None,smooth=False)->str:
    """ build an overlay simalar to HexGrid.styleLayer but uses plates."""
    retLayer = ""
    orders = {}  # Shared cache across all regions
    allPaths = []
    borders = {}  # Shared cache across all regions
    soilStyles = [x.to_style() for x in SoilType.standard_types()]
    

    for i, region in enumerate(self.regions):
        style = soilStyles[i]
        self.terrain.hexGrid.builder.add_style(style)
        allPaths.extend( region.trace_perimeter_cached(borders, f, style))

    allPaths = reversed(sorted(allPaths))
    for path in allPaths:
        if smooth:
            #path = path.smooth()
            retLayer += path.svg()
        else:
            retLayer += path.drawClosed()

    return retLayer

# %% ../nbs/06_river.ipynb #9a3637cf
def soilInformation(showText=True,terrain=None):
    global sampleTerrain, samplePlates
    if terrain == None:
        terrain = sampleTerrain
    terrain.colorMap()
    sGrid = terrain.hexGrid
    sGrid.builder.layers = []
    sampleSoil = SoilSystem.from_plates(terrain, samplePlates, debug=True)

    if showText:
        terrain.field_summary("soil_type")
        return
        

    sGrid.builder.adjust("regions", sampleSoil.soilOverlay(f=unique_windy_edge(iterations=2)))
  

    return sGrid.builder.show()

# %% ../nbs/06_river.ipynb #b99e4b60
@dataclass
class ErosionModel:
    """Simple erosion model with age parameter."""
    terrain: 'Terrain'
    soil_system: 'SoilSystem'
    age: float = 1.0  # 0.1 = young/new world, 1.0 = old world
    
    def erode(self, iterations: int = 1, base_rate: float = 5.0, deposition_threshold: float = 50.0):
        """Run erosion simulation.
        
        Args:
            iterations: Number of erosion passes (age scales this)
            base_rate: Base erosion amount per unit stream power
            deposition_threshold: Elevation below which deposition occurs
        """
        effective_iters = max(1, int(iterations * self.age))
        
        for _ in range(effective_iters):
            self._erode_pass(base_rate, deposition_threshold)
    
    
    def _update_soils(self, eroded: np.ndarray, deposited: np.ndarray):
        """Update soil types based on erosion/deposition."""
        soil_types = self.terrain.fields['soil_type']
        elevations = self.terrain.elevations
        
        for i in range(len(elevations)):
            if deposited[i] > 5:
                # Significant deposition → Alluvial
                soil_types[i] = 4
            elif eroded[i] < -20:
                # Heavy erosion → expose bedrock
                if elevations[i] > 500:
                    soil_types[i] = 0  # Granite
                else:
                    soil_types[i] = 1  # Basalt
            elif eroded[i] < -5:
                # Moderate erosion → sandstone/limestone
                soil_types[i] = 3 if soil_types[i] > 2 else 2
        
        # Rebuild regions
        for type_idx in range(len(self.soil_system.types)):
            hexes = set(np.where(soil_types == type_idx)[0])
            self.soil_system.regions[type_idx] = HexRegion(hexes=hexes, hexGrid=self.terrain.hexGrid)


# %% ../nbs/06_river.ipynb #82eba692
@patch
def _find_knickpoints(self: ErosionModel, river: River, gradient_threshold: float = 15.0) -> list[int]:
    """Find knickpoints (sudden gradient changes) in a river.
    
    Returns hex indices where gradient spikes (potential waterfalls).
    """
    gradient = river._calculate_gradient()
    knickpoints = []
    
    # Walk upstream looking for gradient jumps
    for node in river.tree.all_nodes():
        for i, hex_idx in enumerate(node.data):
            if gradient.get(hex_idx, 0) > gradient_threshold:
                knickpoints.append(hex_idx)
    
    return knickpoints

@patch
def _migrate_knickpoint(self: ErosionModel, hex_idx: int, river: River, migration_rate: float = 0.5):
    """Migrate a knickpoint upstream by eroding the lip.
    
    Args:
        hex_idx: Current knickpoint location
        river: The river containing this knickpoint
        migration_rate: How much to erode (scaled by age and soil)
    """
    terrain = self.terrain
    soil_types = terrain.fields.get('soil_type', np.zeros(len(terrain.elevations), dtype=int))
    types = self.soil_system.types
    
    # Get soil resistance at knickpoint
    resistance = types[soil_types[hex_idx]].erosion_resistance
    
    # Find upstream hex(es) - these form the "lip" of the waterfall
    upstream_hexes = []
    for node in river.tree.all_nodes():
        if hex_idx in node.data:
            idx = node.data.index(hex_idx)
            # Upstream is later in the list (remember: outlet is first)
            if idx < len(node.data) - 1:
                upstream_hexes.append(node.data[idx + 1])
            # Also check child nodes (tributaries joining here)
            for child in river.tree.children(node.identifier):
                upstream_hexes.append(child.data[0])
            break
    
    if not upstream_hexes:
        return
    
    # Calculate erosion at the lip
    current_elev = terrain.elevations[hex_idx]
    
    for upstream_idx in upstream_hexes:
        upstream_elev = terrain.elevations[upstream_idx]
        drop = upstream_elev - current_elev
        
        if drop > 5:  # Only erode if there's a real drop
            # Erosion inversely proportional to resistance
            erosion = migration_rate * self.age * drop / (resistance + 0.1)
            erosion = min(erosion, drop * 0.5)  # Don't over-erode
            
            # Erode the upstream lip
            terrain.elevations[upstream_idx] -= erosion
            
            # If we've eroded through soft rock to hard rock, slow down
            if erosion > 10 and soil_types[upstream_idx] in [3, 4]:  # Sandstone/Alluvial
                # Expose harder rock underneath
                soil_types[upstream_idx] = 2  # Limestone (harder)

@patch  
def _erode_pass(self: ErosionModel, base_rate: float, deposition_threshold: float):
    """Single erosion pass with knickpoint migration."""
    terrain = self.terrain
    soil_types = terrain.fields.get('soil_type', np.zeros(len(terrain.elevations), dtype=int))
    types = self.soil_system.types
    
    # Get rivers and compute power
    peaks = terrain.find_peaks(40, 1)
    rivers = [River.from_peak(terrain, p) for p in peaks]
    rivers = [r for r in rivers if r]
    rivers = River.combine_rivers(rivers)
    
    adjustments = np.zeros(len(terrain.elevations))
    deposited = np.zeros(len(terrain.elevations))
    
    for river in rivers:
        flow = river._calculate_flow()
        gradient = river._calculate_gradient()
        
        # === KNICKPOINT MIGRATION ===
        knickpoints = self._find_knickpoints(river, gradient_threshold=12.0)
        for kp in knickpoints:
            self._migrate_knickpoint(kp, river, migration_rate=0.8)
        
        # === FLUVIAL EROSION ===
        for hex_idx in river.hexes:
            power = flow[hex_idx] * gradient[hex_idx]
            
            soil_idx = soil_types[hex_idx]
            resistance = types[soil_idx].erosion_resistance
            
            erosion = base_rate * power * self.age / (resistance + 0.1)
            
            elev = terrain.elevations[hex_idx]
            
            if elev < deposition_threshold and gradient[hex_idx] < 5:
                deposited[hex_idx] += erosion * 0.3
            else:
                adjustments[hex_idx] -= erosion
                
                for neighbor in terrain.hexGrid.neighborsOf(hex_idx):
                    if neighbor >= 0 and terrain.elevations[neighbor] < elev:
                        adjustments[neighbor] -= erosion * 0.3 / (resistance + 0.1)
    
    # Apply changes
    terrain.elevations = np.clip(terrain.elevations + adjustments + deposited, 0, None)
    
    self._update_soils(adjustments, deposited)

