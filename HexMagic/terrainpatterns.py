# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_terrainpatterns.ipynb.

# %% auto #0
__all__ = ['TerrainPatterns', 'PathPattern', 'SVGMask']

# %% ../nbs/05_terrainpatterns.ipynb #91bb6416
#standard
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

# unique
from treelib import Tree
import heapq
from .voronoi import generate_plate_terrain



# %% ../nbs/05_terrainpatterns.ipynb #a00c60ae
from .styles import StyleCSS, SVGBuilder,SVGLayer, SVGPatternLoader, preview, app, StyleDemo, Generatable,SVGDef, NamedColor
from .primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexRegion, HexWrapper, HexPosition, PrimitiveDemo, hexBackground, windy_edge, unique_windy_edge

# %% ../nbs/05_terrainpatterns.ipynb #9d40ef74
from .terrain import Terrain, TerraDemo
Terrain.fromSeeds = generate_plate_terrain

# %% ../nbs/05_terrainpatterns.ipynb #b8ce1510
class TerrainPatterns:

    def __init__(self,terrain):
        self.terrain = terrain

    @classmethod
    def circlePattern(cls, id, radius=5, spacing=10, color="black"):
        """Generate a circle pattern definition"""
        content = f'<circle cx="{spacing/2}" cy="{spacing/2}" r="{radius}" fill="{color}"/>'
        return SVGDef("pattern", id, content, 
                    width=spacing, height=spacing, 
                    patternUnits="userSpaceOnUse")

    @classmethod
    def trianglePattern(cls, id, size=10, spacing=12, color="black"):
        """Generate an equilateral triangle pattern"""
        height = size * 0.866  # sqrt(3)/2
        points = f"0,{height} {size/2},0 {size},{height}"
        content = f'<polygon points="{points}" fill="{color}"/>'
        return SVGDef("pattern", id, content,
                    width=spacing, height=spacing,
                    patternUnits="userSpaceOnUse")

    @classmethod
    def wavePattern(cls, id, amplitude=5, wavelength=20, color="black", stroke_width=2, fill="none",scale=0.25):
        """Generate a wave pattern with optional background fill"""
        path = f"M 0,{amplitude} Q {wavelength/4},0 {wavelength/2},{amplitude} T {wavelength},{amplitude}"
        
        content = ""
        if fill != "none":
            content += f'<rect width="{wavelength}" height="{amplitude*2}" fill="{fill}"/>'
        content += f'<path d="{path}" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>'

        pattern = SVGDef("pattern", id, content,
                    width=wavelength, height=amplitude*2,
                    patternUnits="userSpaceOnUse")

        pattern.attributes['patternTransform'] = f'scale({scale})'
        
        return pattern

    @classmethod
    def crosshatchPattern(cls, id, spacing=10, color="black", stroke_width=1):
        """Generate a crosshatch pattern"""
        content = f'<line x1="0" y1="0" x2="{spacing}" y2="{spacing}" stroke="{color}" stroke-width="{stroke_width}"/>'
        content += f'<line x1="{spacing}" y1="0" x2="0" y2="{spacing}" stroke="{color}" stroke-width="{stroke_width}"/>'
        return SVGDef("pattern", id, content,
                    width=spacing, height=spacing,
                    patternUnits="userSpaceOnUse")



# %% ../nbs/05_terrainpatterns.ipynb #9eda318f
@patch
def ballDensity(self:TerrainPatterns, levels=6, fills=["#007fff"], prefix="ball") -> list:
    """Create density patterns using circles of increasing size."""
    ret = []
    spacing = 6  # scaled down from 60 with 0.1 scale
    
    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
        radius = min(i * 5.6 / levels + 0.2, spacing/2 - 0.1)
        
        pattern = self.circlePattern(f"{prefix}_{i}", radius=radius, spacing=spacing, color=fill)
        ret.append(pattern)
    return ret

@patch
def ballSpectrum(self:TerrainPatterns, levels=5, fills=["#007fff"], prefix="ball") -> list:
    """Create density patterns - circles shrink to middle then grow."""
    ret = []
    spacing = 6
    biggest = spacing/2 - 0.1
    smallest = 0.5
    delta = (biggest - smallest) / levels * 2
    
    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
        
        if i < levels/2:
            radius = biggest - delta * i
        elif i > levels/2:
            k = levels - i
            radius = biggest - delta * k
        else:
            radius = smallest
        
        pattern = self.circlePattern(f"{prefix}_{i}", radius=radius, spacing=spacing, color=fill)
        ret.append(pattern)
    return ret


# %% ../nbs/05_terrainpatterns.ipynb #0591ba8f
@patch
def ballScale(self:TerrainPatterns, levels=6, fills=["#007fff"], prefix="ball") -> list:
    """Create patterns using a fixed-size circle with varying scale transforms."""
    ret = []
    spacing = 60
    radius = 20
    
    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
        scale = 0.1 + i * 0.8 / levels
        
        pattern = self.circlePattern(f"{prefix}_{i}", radius=radius, spacing=spacing, color=fill)
        pattern.attributes['patternTransform'] = f'scale({scale})'
        ret.append(pattern)
    return ret


# %% ../nbs/05_terrainpatterns.ipynb #e27f6225
@patch
def ballSpectrum(self:TerrainPatterns, levels=5, fills=["#007fff"], prefix="ball") -> [SVGBuilder]:
    """Create density patterns using circles of increasing size."""
    ret = []
    

    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
    
        ballDim = 60
        biggest = ballDim/2-1 
        smallest = 5
        delta = (biggest - smallest)/levels * 2
        

        aBuilder = SVGBuilder()
        if i < levels/2:
            radius = biggest - delta * i
        elif i > levels/2:
            k = levels - i
            radius = biggest - delta * k
        else:
            radius = smallest



        
        body = f"""
        <g>
            <circle cx="{ballDim/2}" cy="{ballDim/2}" r="{radius}" style="fill:{fill};"/>
        </g>
        """
        aBuilder.blockTag = "pattern"
        aBuilder.width = ballDim
        aBuilder.height = ballDim
        scale = 0.1
        aBuilder.attributes = {
            'id': f"{prefix}_{i}",  # USE THE PREFIX!
            'patternUnits': 'userSpaceOnUse',
            'patternTransform': f'scale({scale})'
        }
        aBuilder.updateLayers([body])

        ret.append(aBuilder)
    return ret

# %% ../nbs/05_terrainpatterns.ipynb #473621ca
@patch
def makeOverlay(self:Terrain,data,patterns:[SVGBuilder])->str:
    testBody = ""
    grid = self.hexGrid

    addSet = set()

    for i, patIndex in enumerate(data):
        if patIndex >= 0 and patIndex < len(patterns):
            patName = patterns[patIndex].attributes['id']
            addSet.add(patIndex)
    
            fill = f"url(#{patName})"

            ret = "<polygon points=\""
            hex = grid.hexes[i]
            for point in hex.vertices():
                ret += f"{point.x:.0f},{point.y:.0f} "
            ret += f"\" style=\"fill:{fill}\""
            ret += "/>"

            testBody += "\t" +  ret + "\n"

    aList = list(addSet)
    aList.sort()
    for patIndex in aList:
        grid.builder.add_definition(patterns[patIndex])

    return testBody
   
        

# %% ../nbs/05_terrainpatterns.ipynb #5204513d
@patch
def overlayRegions(self: HexGrid, regions: list[HexRegion], 
                   patterns: list[SVGBuilder], f=None):
    """Apply patterns to regions. Each region gets one pattern applied to all its paths.
    
    Args:
        regions: List of HexRegion objects
        patterns: List of SVGBuilder patterns (one per region)
        f: Optional edge transform function (e.g., windy_edge())
    
    Returns:
        SVG string for the overlay layer
    """
    retLayer = ""
    borders = {}  # Shared cache across all regions
    
    # Add all pattern definitions
    for pattern in patterns:
        self.builder.add_definition(pattern)
    
    for region, pattern in zip(regions, patterns):
        patName = pattern.attributes['id']
        fill = f"url(#{patName})"
        
        # Create a style with this pattern as fill
        style = StyleCSS(f"overlay_{patName}", fill=fill, stroke="black",stroke_width=0.5)
        self.builder.add_style(style)
        
        # Get all paths for this region (handles non-contiguous)
        for path in region.trace_perimeter_cached(borders, f, style):
            retLayer += path.drawClosed()
    
    return retLayer


# %% ../nbs/05_terrainpatterns.ipynb #c5579aad
@patch
def namedBalls(patternGen:TerrainPatterns,cols=[],scale = 0.25):
    
    spacing = 60
    radius = 20

    patterns = []
    styles = []
    for pair in cols:      # fixed
        fill = pair.color
        name = pair.name
        patternName = f"{name}_pat"
        
        pattern = patternGen.circlePattern(patternName, radius=radius, spacing=spacing, color=fill)  # fixed
        pattern.attributes['patternTransform'] = f'scale({scale})'
        patterns.append(pattern)
        style = StyleCSS(name, fill=f"url(#{patternName})")
        styles.append(style)

    
    return patterns, styles

# %% ../nbs/05_terrainpatterns.ipynb #00d5e632
@patch
def precipitationStyle(self:TerrainPatterns,scale = 0.25):
    cols = [
        NamedColor("#8B4513", "Desert"),      # added comma
        NamedColor("#DEB887", "Arid"),
        NamedColor("#F0E68C", "Semi-arid"),
        NamedColor("#9ACD32", "Dry"),
        NamedColor("#32CD32", "Moderate"),
        NamedColor("#228B22", "Wet"),
        NamedColor("#006400", "Very_wet"),    # added comma
        NamedColor("#004d00", "Rainforest")
    ]

    return self.namedBalls(cols,scale)

# %% ../nbs/05_terrainpatterns.ipynb #cfee38d0
@dataclass
class PathPattern:
    color: str      # used for stroke
    name: str
    path: str = None
    fill: str = "#626261ff"  # background
    width: int = 480
    height: int = 600
    scale: float = 0.05


    def patternName(self):
        return f"{self.name}_pat"
    
    def toPattern(self):
        content = f'<g fill="{self.color}" stroke="{self.color}">\n'
        content += f'<rect fill="{self.fill}" width="{self.width}" height="{self.height}"/>\n'
        content += self.path 
        content += "\n</g>\n"
        
        pattern = SVGDef("pattern", self.patternName(), content,
                        width=self.width, height=self.height,
                        patternUnits="userSpaceOnUse")
        pattern.attributes['patternTransform'] = f'scale({self.scale})'
        return pattern


# %% ../nbs/05_terrainpatterns.ipynb #aafef6ce
@patch
def namedPatterns(patternGen:TerrainPatterns, patternDefs:[PathPattern]):
    spacing = 60
    radius = 20
    scale = 0.25

    patterns = []
    styles = []
    for patDef in patternDefs:      # fixed
        fill = patDef.color
        name = patDef.name
        patternName = patDef.patternName()
        if patDef.path is None:
            pattern = patternGen.circlePattern(patternName, radius=radius, spacing=spacing, color=fill)  # fixed
            pattern.attributes['patternTransform'] = f'scale({scale})'
        else:
            pattern = patDef.toPattern()

        patterns.append(pattern)
        style = StyleCSS(name, fill=f"url(#{patternName})")
        styles.append(style)

    
    return patterns, styles

# %% ../nbs/05_terrainpatterns.ipynb #af6ee0a5
@patch
def climateStyle(self:TerrainPatterns, scale = 0.25):
    cols = [  
        PathPattern("#64B5F6", "Marine",
    fill="#1976D2",
    path="""
<circle cx="120" cy="150" r="80" stroke-width="15" fill="none"/>
<circle cx="360" cy="150" r="80" stroke-width="15" fill="none"/>
<circle cx="240" cy="350" r="80" stroke-width="15" fill="none"/>
<circle cx="60" cy="450" r="80" stroke-width="15" fill="none"/>
<circle cx="420" cy="450" r="80" stroke-width="15" fill="none"/>
"""),

        PathPattern("#4FC3F7", "Fresh_Water",
    fill="#03A9F4",
    path="""
<circle cx="160" cy="200" r="100" stroke-width="12" fill="none"/>
<circle cx="160" cy="200" r="60" stroke-width="12" fill="none"/>
<circle cx="360" cy="400" r="80" stroke-width="12" fill="none"/>
<circle cx="360" cy="400" r="40" stroke-width="12" fill="none"/>
"""),
        PathPattern("#e3f2fd","Tundra","""<line x1="240" y1="100" x2="240" y2="500" stroke-width="40"/>
<line x1="66" y1="200" x2="414" y2="400" stroke-width="40"/>
<line x1="66" y1="400" x2="414" y2="200" stroke-width="40"/>"""),
        PathPattern("#fdd835","Desert",path = """
<line x1="0" y1="200" x2="160" y2="300" stroke-width="30"/>
<line x1="160" y1="300" x2="240" y2="150" stroke-width="30"/>
<line x1="240" y1="150" x2="480" y2="200" stroke-width="30"/>
<line x1="160" y1="300" x2="100" y2="600" stroke-width="30"/>
<line x1="240" y1="150" x2="350" y2="0" stroke-width="30"/>
<line x1="0" y1="450" x2="200" y2="500" stroke-width="30"/>
<line x1="200" y1="500" x2="320" y2="400" stroke-width="30"/>
<line x1="320" y1="400" x2="480" y2="450" stroke-width="30"/>
<line x1="200" y1="500" x2="380" y2="600" stroke-width="30"/>
"""),
        PathPattern("#9ccc65","Grassland",path = """
        <path d="M240 120A120 120 0 0 1 120 0H0a240 240 0 0 0 240 240A240 240 0 0 0 0 480h120c0-66.3 53.7-120 120-120a120 120 0 1 0 0-240Z" stroke-width="8"></path>
        """,height=480),
        PathPattern("#66BB6A","Forrest",path = """
<path d="M120 400 L120 300 L60 300 L120 200 L80 200 L120 100 L160 200 L120 200 L180 300 L120 300 Z" stroke-width="10"/>
<path d="M320 500 L320 400 L260 400 L320 300 L280 300 L320 200 L360 300 L320 300 L380 400 L320 400 Z" stroke-width="10"/>
<path d="M200 550 L200 480 L160 480 L200 400 L170 400 L200 320 L230 400 L200 400 L240 480 L200 480 Z" stroke-width="8"/>
"""),
        PathPattern("#43A047", "Jungle", path="""
<path d="M120 300 Q80 200 120 100" stroke-width="20" fill="none"/>
<path d="M120 300 Q160 200 200 120" stroke-width="20" fill="none"/>
<path d="M120 300 Q60 250 40 180" stroke-width="20" fill="none"/>
<path d="M360 450 Q320 350 360 250" stroke-width="20" fill="none"/>
<path d="M360 450 Q400 350 440 270" stroke-width="20" fill="none"/>
<path d="M360 450 Q300 400 280 330" stroke-width="20" fill="none"/>
""")
    ]
    return self.namedPatterns(cols)
    

# %% ../nbs/05_terrainpatterns.ipynb #a5569840
@patch
def namedHatchPattern(patternGen:TerrainPatterns,cols=[],stroke_width=1,spacing=10):
    
    patterns = []
    styles = []
    for pair in cols:      # fixed
        fill = pair.color
        name = pair.name
        patternName = f"{name}_pat_hatch"
        
        pattern = patternGen.crosshatchPattern(patternName,  spacing=spacing,stroke_width= stroke_width,color=fill)  # fixed
        patterns.append(pattern)
        style = StyleCSS(name, fill=f"url(#{patternName})")
        styles.append(style)

    
    return patterns, styles

# %% ../nbs/05_terrainpatterns.ipynb #84727f3d
@patch
def visualize_difference(terrain: Terrain,adjustment,thresholds = [-5, -1, 1, 5] ):
    """Visualize erosion with red (removal) and green (deposition)."""
    
   
    # 5 categories: heavy erosion, light erosion, minimal, light deposition, heavy deposition
      # Splits into 5 bins
    
    colors = [
        "#DC143C",  # Red - heavy erosion (< -5m)
        "#DC143C",  # Red - light erosion (-5 to -1m)
        "#808080",  # Gray - minimal change (-1 to 1m)
        "#32CD32",  # Green - light deposition (1 to 5m)
        "#32CD32",  # Green - heavy deposition (> 5m)
    ]
    
    # Bin adjustment values
    adj_indices = np.digitize(adjustment, thresholds)
    adj_indices = np.clip(adj_indices, 0, len(colors) - 1)
    
    # Create patterns with varying ball density
    patternGen = TerrainPatterns(self.terrain)
    patterns = patternGen.ballSpectrum(len(colors), fills=colors, prefix="erosion")
    
    # Generate overlay
    return self.makeOverlay(adj_indices, patterns)

# %% ../nbs/05_terrainpatterns.ipynb #2a224a50
# Create a terrain
@patch
def circusDemo(self:TerraDemo):
    sampleMap = TerraDemo().tiny()

    def rainfall_selector_np(values: np.ndarray) -> np.ndarray:
        # bin edges: <5 returns 0, 5-12 returns 1, 12-24 returns 2, etc.
        bins = [0.1, 5, 12, 24, 48]
        return np.digitize(values, bins) - 1 

    test_data = np.array([-1, 2, 8, 15, 30, 60, 0, 12, 48])

    indices = rainfall_selector_np(test_data)
    indices

    # Generate random rainfall data
    rainfall_data = np.random.uniform(-4, 60, len(sampleMap.elevations))
    sampleMap.fields['rainfall'] = rainfall_data

    # Get pattern indices
    pattern_indices = rainfall_selector_np(rainfall_data)
    regions = sampleMap.hexGrid.regions_by_value(pattern_indices)

    # Create patterns and overlay
    patternGen = TerrainPatterns(sampleMap)
    patterns = patternGen.ballScale(len(pattern_indices),fills=["#007fff","#d4ff00ff","#ee00ffff","#ff0099ff","#00ff1eff"])  # 5 levels
    patot = sampleMap.hexGrid.overlayRegions(regions, patterns)
    #print(patot)
    sampleMap.hexGrid.builder.adjust("regionfall",patot)
    #sampleMap.colorMap()
    #sampleMap.hexGrid.update()

    # View it
    #print(sampleMap.hexGrid.builder._header())
    return sampleMap.hexGrid.builder.show()


# %% ../nbs/05_terrainpatterns.ipynb #a869a9fd
@patch
def oceanOverlay(self: Terrain):
    terrain = self
    terrain.colorMap()
    
    # Find ocean hexes (level 0)
    ocean_hexes = terrain.find_region_at_level(0)
    ocean_region = HexRegion(hexes=ocean_hexes, hexGrid=terrain.hexGrid)
    
    # Create wave pattern with ocean blues
    patGen = TerrainPatterns(terrain)
    wave = patGen.wavePattern("ocean_waves", 
                              amplitude=4, 
                              wavelength=16, 
                              color="#1565C0",      # stroke: medium blue
                              fill="#E3F2FD")       # fill: light blue
    
    # Apply to region
    return terrain.hexGrid.overlayRegions([ocean_region], [wave])



# %% ../nbs/05_terrainpatterns.ipynb #f376dac4
@patch
def fillPattern(self:HexRegion,pattern:SVGBuilder,smooth=False):
    """Fill a region with a style.

     fill = f"url(#{patName})"

            ret = "<polygon points=\""
            hex = grid.hexes[i]
            for point in hex.vertices():
                ret += f"{point.x:.0f},{point.y:.0f} "
            ret += f"\" style=\"fill:{fill}\""
    
    
    """
    
    fill_layer = ""
    patName = pattern.attributes['id']
    fill = f"url(#{patName})"
    #fill = "#d4ff00eb"

    paths, gaps = self.trace_perimeter(style=StyleCSS("blank"),debug=False)
    #self.builder.add_style(pathstyle)

    pathLayer = ""
    for path in paths:
        if path.points[0].distance(path.points[-1]) < 40:
            cl = path.closed()
        else:
            cl = path
        
        pathLayer += "<path d=\""
        if smooth:
            curved = cl.make_windy(iterations=1, offset_factor=0.1, seed=42)
            smooth = curved.smooth(iterations=1)
            pathLayer += smooth.to_svg_path( close=True)
        else:
            
            pathLayer += cl.to_svg_path( close=True)
        pathLayer += f"\" style=\"fill:{fill}\""
        pathLayer += "/>"
        pathLayer += "\n"
    

    return pathLayer

    
    flowData = np.zeros(len(self.hexGrid.hexes)) - 1

    for i in self.hexes:
        #print(i)
        flowData[i] = 1

    flowData = [int(x) for x in flowData]
    # Create patterns and overlay
    patternGen = TerrainPatterns(self)
    patterns = patternGen.ballDensity(3,fills=fills)  # 5 levels
    self.makeOverlay(flowData, patterns)

# %% ../nbs/05_terrainpatterns.ipynb #f7211cbc
class SVGMask(Generatable):
    """SVG mask definition that can be added to SVGBuilder definitions"""
    
    def __init__(self, mask_id: str, width: int = 10000, height: int = 10000):
        self.mask_id = mask_id
        self.width = width
        self.height = height
        self.paths = []  # List of (path_d, fill_color) tuples
        self.background_color = "white"  # White = show, black = hide
    
    def add_path(self, path_d: str, fill: str = "black", smooth: bool = False):
        """Add a path to the mask. Black areas will be hidden."""
        self.paths.append((path_d, fill))
        return self
    
    def set_background(self, color: str):
        """Set mask background color (white=show, black=hide)"""
        self.background_color = color
        return self
    
    def generate(self) -> str:
        """Generate the mask definition XML"""
        ret = f'<mask id="{self.mask_id}">\n'
        ret += f'  <rect x="0" y="0" width="{self.width}" height="{self.height}" fill="{self.background_color}"/>\n'
        
        for path_d, fill in self.paths:
            ret += f'  <path d="{path_d}" fill="{fill}"/>\n'
        
        ret += '</mask>'
        return ret


# %% ../nbs/05_terrainpatterns.ipynb #5bc8eba6
@patch
def fillPatternInverted(self: HexRegion, pattern: SVGBuilder, smooth: bool = False):
    """Fill OUTSIDE a region with a pattern using a mask."""
    
    # Get the region boundary
    paths = self.trace_perimeter(style=StyleCSS("blank"), debug=False)
    
    # Create mask
    mask_id = f"mask_{id(self)}"
    mask = SVGMask(mask_id)
    
    # Add paths to mask (black = hide these areas)
    for path in paths:
        cl = path.closed() if path.points[0].distance(path.points[-1]) < 40 else path
        
        if smooth:
            curved = cl.make_windy(iterations=1, offset_factor=0.1, seed=42)
            smooth_path = curved.smooth(iterations=1)
            path_d = smooth_path.to_svg_path(close=True)
        else:
            path_d = cl.to_svg_path(close=True)
        
        mask.add_path(path_d, fill="black")
    
    # Add mask to builder definitions
    self.hexGrid.builder.add_definition(mask)
    
    # Create filled rect with mask applied
    patName = pattern.attributes['id']
    fill = f"url(#{patName})"
    
    return f'<rect x="0" y="0" width="10000" height="10000" fill="{fill}" mask="url(#{mask_id})"/>'


# %% ../nbs/05_terrainpatterns.ipynb #a265f038
@patch
def hatchLines(self: TerrainPatterns, angle: float = 45, spacing: float = 8, 
               stroke_width: float = 1.5, color: str = "#3d9fc0ff") -> SVGBuilder:
    """Create diagonal line hatch pattern."""
    
    # Pattern tile needs to be large enough for one full line repeat
    size = spacing * 2
    
    # Calculate line endpoints based on angle
    # For 45Â°, lines go from bottom-left to top-right
    body = f'''
    <g>
        <line x1="0" y1="{size}" x2="{size}" y2="0" 
              stroke="{color}" stroke-width="{stroke_width}"/>
        <line x1="-{size}" y1="{size}" x2="{size}" y2="-{size}" 
              stroke="{color}" stroke-width="{stroke_width}"/>
    </g>
    '''
    
    aBuilder = SVGBuilder()
    aBuilder.blockTag = "pattern"
    aBuilder.width = size
    aBuilder.height = size
    aBuilder.attributes = {
        'id': 'hatch_lines',
        'patternUnits': 'userSpaceOnUse',
        'patternTransform': f'rotate({angle})'
    }
    aBuilder.updateLayers([body])
    
    return aBuilder

# %% ../nbs/05_terrainpatterns.ipynb #ff4b3a54
@patch
def island(self:TerraDemo):
    mySize = MapSize(480,480)
    myBounds = MapRect(MapCord(0,0), mySize)
    sampleMap =  Terrain(myBounds,radius=15,path = "volcano.svg")
    
    sampleMap.elevations += sampleMap.volcano(center=267,adjusted=500,num_rings=6,variability=0.5,initial_threshold=0.4)

    levels = [x for x in range(len(sampleMap.elevations)-1) if sampleMap.elevationLevel(x) >= 0]

    region = HexRegion(hexes=set(levels), hexGrid=sampleMap.hexGrid)
    fills=["#3300ffeb","#3d9fc0ff"]
    patternGen = TerrainPatterns(sampleMap)
    patterns = patternGen.ballDensity(4,fills=fills)

    sampleMap.colorMap()
    sampleMap.hexGrid.update()

    myPat = patterns[1]
    #myPat = patternGen.hatchLines(angle=25, spacing=8, stroke_width=1.5, color="#3d9fc0ff")

    sampleMap.hexGrid.builder.add_definition(myPat)
    over = region.fillPatternInverted(myPat,True)
    #sampleMap.builder.adjust(f"root","")
    sampleMap.builder.adjust(f"ocean",over)
    return sampleMap

@patch
def demoAquatic(self:TerraDemo):
    sampleMap = self.island()

    

    #print(sampleMap.hexGrid.builder.xml())
    

    return sampleMap.hexGrid.builder.show()

# %% ../nbs/05_terrainpatterns.ipynb #a75e0585
@patch
def mapElement(sampleMap:Terrain,bounds:MapCord,name="compass_1",prefix="merright",style=StyleCSS("base", 
                        fill="#27ae60",  # Green
                        stroke="#c12121ff")): 
    
    # Show the terrain first
    sampleMap.colorMap()
    sampleMap.hexGrid.update()

    dim = bounds.dimensons.width
    xoffset = bounds.origin.x
    yoffset = bounds.origin.y

    
    #
    #name = 'compass_1.svg' #'merright_1svg'.
    aPat = SeaPatterns.load_pattern(name + '.svg', f"{name}_aid", prefix=prefix)

    # Override to green - all paths will have class="merright_path"
    green_style = StyleCSS(f"{prefix}_path", 
                        fill=style.properties["fill"],  # Green
                        stroke=style.properties["stroke"])
    aPat.attributes['patternUnits'] = 'userSpaceOnUse'
    aPat.attributes['patternContentUnits'] = 'objectBoundingBox'
    aPat.attributes['patternTransform'] = f'translate({xoffset},{yoffset}) scale({dim/aPat.width})'
    aPat.add_style(green_style)
    #aPat.add_style(green_style, prefix="merright")
    
    sampleMap.hexGrid.builder.add_definition(aPat)
    over = f'<rect x="{xoffset}" y="{yoffset}" width="{dim}" height="{dim}" fill="#0080ff1f"   opacity="0.8"/>'
    over = f'<rect x="{xoffset}" y="{yoffset}" width="{dim}" height="{dim}" fill="url(#{name}_aid)"   opacity="0.8"/>'
    return over
    

    

    return sampleMap.hexGrid.builder.show()

# %% ../nbs/05_terrainpatterns.ipynb #1958f05a
@patch
def styleLayerOrdered(self: HexGrid, styles: list[StyleCSS], f=None, smooth=False):
    """Generate style layer with styles applied in specified order.
    
    Args:
        styles: List of StyleCSS objects in the order to render them
        f: Optional edge transformation function
    """
    retLayer = ""
    regions = self.styleRegions()
    borders = {}
    rendered = set()

    # First: render specified styles in order
    for style in styles:
        styleName = style.name
        if styleName not in regions:
            continue
        rendered.add(styleName)
        region = regions[styleName]
        for path in region.trace_perimeter_cached(borders, f, style):
            if smooth:
                retLayer += path.sbg()
            else:
                retLayer += path.drawClosed()

    # Then: render any remaining regions
    for styleName, region in regions.items():
        if styleName in rendered:
            continue
        style = self.builder.styles.get(styleName)
        for path in region.trace_perimeter_cached(borders, f, style):
            retLayer += path.drawClosed()

    return retLayer

