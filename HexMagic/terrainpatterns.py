# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_terrainpatterns.ipynb.

# %% auto #0
__all__ = ['swampPath', 'forestPath', 'freshwaterPath', 'grasslandPath', 'TerrainPatterns', 'PathPattern', 'SVGMask']

# %% ../nbs/05_terrainpatterns.ipynb #91bb6416
#standard
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

# unique
from treelib import Tree
import heapq
from .voronoi import generate_plate_terrain
from importlib import resources



# %% ../nbs/05_terrainpatterns.ipynb #a00c60ae
from .styles import StyleCSS, SVGBuilder,SVGLayer, SVGPatternLoader, preview, app, StyleDemo, Generatable,SVGDef, NamedColor
from .primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexRegion, HexWrapper, HexPosition, PrimitiveDemo, hexBackground, windy_edge, unique_windy_edge

# %% ../nbs/05_terrainpatterns.ipynb #9d40ef74
from .terrain import Terrain, TerraDemo
Terrain.fromSeeds = generate_plate_terrain

# %% ../nbs/05_terrainpatterns.ipynb #b8ce1510
class TerrainPatterns:

    def __init__(self,terrain):
        self.terrain = terrain

    @classmethod
    def circlePattern(cls, id, radius=5, spacing=10, color="black"):
        """Generate a circle pattern definition"""
        content = f'<circle cx="{spacing/2}" cy="{spacing/2}" r="{radius}" fill="{color}"/>'
        return SVGDef("pattern", id, content, 
                    width=spacing, height=spacing, 
                    patternUnits="userSpaceOnUse")

    @classmethod
    def trianglePattern(cls, id, size=10, spacing=12, color="black"):
        """Generate an equilateral triangle pattern"""
        height = size * 0.866  # sqrt(3)/2
        points = f"0,{height} {size/2},0 {size},{height}"
        content = f'<polygon points="{points}" fill="{color}"/>'
        return SVGDef("pattern", id, content,
                    width=spacing, height=spacing,
                    patternUnits="userSpaceOnUse")

    @classmethod
    def wavePattern(cls, id, amplitude=5, wavelength=20, color="black", stroke_width=2, fill="none",scale=0.25):
        """Generate a wave pattern with optional background fill"""
        path = f"M 0,{amplitude} Q {wavelength/4},0 {wavelength/2},{amplitude} T {wavelength},{amplitude}"
        
        content = ""
        if fill != "none":
            content += f'<rect width="{wavelength}" height="{amplitude*2}" fill="{fill}"/>'
        content += f'<path d="{path}" stroke="{color}" stroke-width="{stroke_width}" fill="none"/>'

        pattern = SVGDef("pattern", id, content,
                    width=wavelength, height=amplitude*2,
                    patternUnits="userSpaceOnUse")

        pattern.attributes['patternTransform'] = f'scale({scale})'
        
        return pattern

    @classmethod
    def crosshatchPattern(cls, id, spacing=10, color="black", stroke_width=1):
        """Generate a crosshatch pattern"""
        content = f'<line x1="0" y1="0" x2="{spacing}" y2="{spacing}" stroke="{color}" stroke-width="{stroke_width}"/>'
        content += f'<line x1="{spacing}" y1="0" x2="0" y2="{spacing}" stroke="{color}" stroke-width="{stroke_width}"/>'
        return SVGDef("pattern", id, content,
                    width=spacing, height=spacing,
                    patternUnits="userSpaceOnUse")



# %% ../nbs/05_terrainpatterns.ipynb #9eda318f
@patch
def ballDensity(self:TerrainPatterns, levels=6, fills=["#007fff"], prefix="ball") -> list:
    """Create density patterns using circles of increasing size."""
    ret = []
    spacing = 6  # scaled down from 60 with 0.1 scale
    
    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
        radius = min(i * 5.6 / levels + 0.2, spacing/2 - 0.1)
        
        pattern = self.circlePattern(f"{prefix}_{i}", radius=radius, spacing=spacing, color=fill)
        ret.append(pattern)
    return ret

@patch
def ballSpectrum(self:TerrainPatterns, levels=5, fills=["#007fff"], prefix="ball") -> list:
    """Create density patterns - circles shrink to middle then grow."""
    ret = []
    spacing = 6
    biggest = spacing/2 - 0.1
    smallest = 0.5
    delta = (biggest - smallest) / levels * 2
    
    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
        
        if i < levels/2:
            radius = biggest - delta * i
        elif i > levels/2:
            k = levels - i
            radius = biggest - delta * k
        else:
            radius = smallest
        
        pattern = self.circlePattern(f"{prefix}_{i}", radius=radius, spacing=spacing, color=fill)
        ret.append(pattern)
    return ret


# %% ../nbs/05_terrainpatterns.ipynb #0591ba8f
@patch
def ballScale(self:TerrainPatterns, levels=6, fills=["#007fff"], prefix="ball") -> list:
    """Create patterns using a fixed-size circle with varying scale transforms."""
    ret = []
    spacing = 60
    radius = 20
    
    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
        scale = 0.1 + i * 0.8 / levels
        
        pattern = self.circlePattern(f"{prefix}_{i}", radius=radius, spacing=spacing, color=fill)
        pattern.attributes['patternTransform'] = f'scale({scale})'
        ret.append(pattern)
    return ret


# %% ../nbs/05_terrainpatterns.ipynb #e27f6225
@patch
def ballSpectrum(self:TerrainPatterns, levels=5, fills=["#007fff"], prefix="ball") -> [SVGBuilder]:
    """Create density patterns using circles of increasing size."""
    ret = []
    

    for i in range(levels):
        colorIndex = min(i, len(fills)-1)
        fill = fills[colorIndex]
    
        ballDim = 60
        biggest = ballDim/2-1 
        smallest = 5
        delta = (biggest - smallest)/levels * 2
        

        aBuilder = SVGBuilder()
        if i < levels/2:
            radius = biggest - delta * i
        elif i > levels/2:
            k = levels - i
            radius = biggest - delta * k
        else:
            radius = smallest



        
        body = f"""
        <g>
            <circle cx="{ballDim/2}" cy="{ballDim/2}" r="{radius}" style="fill:{fill};"/>
        </g>
        """
        aBuilder.blockTag = "pattern"
        aBuilder.width = ballDim
        aBuilder.height = ballDim
        scale = 0.1
        aBuilder.attributes = {
            'id': f"{prefix}_{i}",  # USE THE PREFIX!
            'patternUnits': 'userSpaceOnUse',
            'patternTransform': f'scale({scale})'
        }
        aBuilder.updateLayers([body])

        ret.append(aBuilder)
    return ret

# %% ../nbs/05_terrainpatterns.ipynb #473621ca
@patch
def makeOverlay(self:Terrain,data,patterns:[SVGBuilder])->str:
    testBody = ""
    grid = self.hexGrid

    addSet = set()

    for i, patIndex in enumerate(data):
        if patIndex >= 0 and patIndex < len(patterns):
            patName = patterns[patIndex].attributes['id']
            addSet.add(patIndex)
    
            fill = f"url(#{patName})"

            ret = "<polygon points=\""
            hex = grid.hexes[i]
            for point in hex.vertices():
                ret += f"{point.x:.0f},{point.y:.0f} "
            ret += f"\" style=\"fill:{fill}\""
            ret += "/>"

            testBody += "\t" +  ret + "\n"

    aList = list(addSet)
    aList.sort()
    for patIndex in aList:
        grid.builder.add_definition(patterns[patIndex])

    return testBody
   
        

# %% ../nbs/05_terrainpatterns.ipynb #5204513d
@patch
def overlayRegions(self: HexGrid, regions: list[HexRegion], 
                   patterns: list[SVGBuilder], f=None):
    """Apply patterns to regions. Each region gets one pattern applied to all its paths.
    
    Args:
        regions: List of HexRegion objects
        patterns: List of SVGBuilder patterns (one per region)
        f: Optional edge transform function (e.g., windy_edge())
    
    Returns:
        SVG string for the overlay layer
    """
    retLayer = ""
    borders = {}  # Shared cache across all regions
    
    # Add all pattern definitions
    for pattern in patterns:
        self.builder.add_definition(pattern)
    
    for region, pattern in zip(regions, patterns):
        patName = pattern.attributes['id']
        fill = f"url(#{patName})"
        
        # Create a style with this pattern as fill
        style = StyleCSS(f"overlay_{patName}", fill=fill, stroke="black",stroke_width=0.5)
        self.builder.add_style(style)
        
        # Get all paths for this region (handles non-contiguous)
        for path in region.trace_perimeter_cached(borders, f, style):
            retLayer += path.drawClosed()
    
    return retLayer


# %% ../nbs/05_terrainpatterns.ipynb #c5579aad
@patch
def namedBalls(patternGen:TerrainPatterns,cols=[],scale = 0.25):
    
    spacing = 60
    radius = 20

    patterns = []
    styles = []
    for pair in cols:      # fixed
        fill = pair.color
        name = pair.name
        patternName = f"{name}_pat"
        
        pattern = patternGen.circlePattern(patternName, radius=radius, spacing=spacing, color=fill)  # fixed
        pattern.attributes['patternTransform'] = f'scale({scale})'
        patterns.append(pattern)
        style = StyleCSS(name, fill=f"url(#{patternName})")
        styles.append(style)

    
    return patterns, styles

# %% ../nbs/05_terrainpatterns.ipynb #00d5e632
@patch
def precipitationStyle(self:TerrainPatterns,scale = 0.25):
    cols = [
        NamedColor("#8B4513", "Desert"),      # added comma
        NamedColor("#DEB887", "Arid"),
        NamedColor("#F0E68C", "Semi-arid"),
        NamedColor("#9ACD32", "Dry"),
        NamedColor("#32CD32", "Moderate"),
        NamedColor("#228B22", "Wet"),
        NamedColor("#006400", "Very_wet"),    # added comma
        NamedColor("#004d00", "Rainforest")
    ]

    return self.namedBalls(cols,scale)

# %% ../nbs/05_terrainpatterns.ipynb #b21299bb
swampPath="swamp.txt"

# %% ../nbs/05_terrainpatterns.ipynb #73edf4ae
forestPath = "forest.txt"

# %% ../nbs/05_terrainpatterns.ipynb #51b3a598
freshwaterPath="freshwater.txt"

# %% ../nbs/05_terrainpatterns.ipynb #d2b6ea5b
grasslandPath = "grassland.txt"

# %% ../nbs/05_terrainpatterns.ipynb #35c59550
@dataclass
class PathPattern:
    color: str
    name: str
    path: str = None
    fill: str = "#626261ff"
    # Design dimensions (what your SVG paths use)
    design_width: int = 480
    design_height: int = 600
    # Final tile size
    tile_size: int = 60
    # For clustered patterns
    canvasMult: float = None
    n_elements: int = 25
    cluster_prob: float = 0.4
    cluster_size: int = 3
    seed: int = None

    def patternName(self):
        return f"{self.name}_pat"
    
    def get_scale(self):
        """Calculate scale to fit design into tile"""
        if self.canvasMult:
            canvas_size = max(self.design_width, self.design_height) * self.canvasMult
            return self.tile_size / canvas_size
        return self.tile_size / max(self.design_width, self.design_height)






# %% ../nbs/05_terrainpatterns.ipynb #8bcaebe3
@patch
def clustered_pattern(self:PathPattern, symbol_id,fill=None) -> ([SVGDef], StyleCSS):
    """Generate a pattern with random clusters of elements."""
    if self.seed is not None:
        random.seed(self.seed)
    
    # Create large canvas for clustering
    canvas_w = self.design_width * self.canvasMult
    canvas_h = self.design_height * self.canvasMult

    if fill is None:
        fill = self.fill

    # Load symbol and get its approximate size for edge detection
    with resources.files('HexMagic').joinpath('data/patterns/climate/' + self.path).open() as f:
        symbol_def_content = f.read()
    
    symbol_def = SVGDef("symbol", symbol_id, symbol_def_content)
    
    # Estimate symbol size (you might need to adjust this based on your symbols)
    symbol_size = max(self.design_width, self.design_height) * 1.5  # Max scale is 1.4
    margin = symbol_size / 2  # Keep elements this far from edges
    
    # Create clustered uses
    uses = []
    i = 0
    while i < self.n_elements:
        # Place within safe bounds
        x = random.uniform(margin, canvas_w - margin)
        y = random.uniform(margin, canvas_h - margin)
        
        if random.random() < self.cluster_prob:
            for _ in range(random.randint(2, self.cluster_size)):
                # Cluster offset - keep it small enough to stay in bounds
                offset_limit = min(margin * 0.5, canvas_w * 0.02)
                cx = x + random.gauss(0, offset_limit)
                cy = y + random.gauss(0, offset_limit)
                # Clamp to safe bounds
                cx = max(margin, min(canvas_w - margin, cx))
                cy = max(margin, min(canvas_h - margin, cy))
                
                scale = random.uniform(0.6, 1.4)
                rot = 0
                uses.append(f'<use href="#{symbol_id}" x="{cx:.1f}" y="{cy:.1f}" '
                           f'transform="translate({cx:.1f},{cy:.1f}) rotate({rot:.1f}) scale({scale:.2f}) translate({-cx:.1f},{-cy:.1f})"/>')
                i += 1
                if i >= self.n_elements: break
        else:
            scale = random.uniform(0.6, 1.4)
            rot = 0
            uses.append(f'<use href="#{symbol_id}" x="{x:.1f}" y="{y:.1f}" '
                       f'transform="translate({x:.1f},{y:.1f}) rotate({rot:.1f}) scale({scale:.2f}) translate({-x:.1f},{-y:.1f})"/>')
            i += 1
    
    # Build pattern content
    content = f'<rect fill="{fill}" width="{canvas_w}" height="{canvas_h}"/>\n'
    content += f'<g fill="{self.color}" stroke="{self.color}">\n'
    content += '\n'.join(uses)
    content += '\n</g>'
    
    # Create pattern with scale to fit tile_size
    pattern_def = SVGDef("pattern", self.patternName(), content,
                        width=canvas_w, height=canvas_h,
                        patternUnits="userSpaceOnUse")
    pattern_def.attributes['patternTransform'] = f'scale({self.get_scale()})'
    
    return [symbol_def, pattern_def], StyleCSS(self.name, fill=f"url(#{self.patternName()})")


# %% ../nbs/05_terrainpatterns.ipynb #9463037b
@patch
def single_pattern(self:PathPattern,fill=None) -> ([SVGDef], StyleCSS):
    """Generate a simple repeating pattern."""
    with resources.files('HexMagic').joinpath('data/patterns/climate/' + self.path).open() as f:
        pattern_content = f.read()

    if fill is None:
        fill = self.fill
    
    content = f'<rect fill="{fill}" width="{self.design_width}" height="{self.design_height}"/>\n'
    content += f'<g fill="{self.color}" stroke="{self.color}">\n'
    content += pattern_content 
    content += '\n</g>'
    
    pattern = SVGDef("pattern", self.patternName(), content,
                    width=self.design_width, height=self.design_height,
                    patternUnits="userSpaceOnUse")
    pattern.attributes['patternTransform'] = f'scale({self.get_scale()})'
    
    return [pattern], StyleCSS(self.name, fill=f"url(#{self.patternName()})")

@patch
def toPattern(self:PathPattern,fill=None) -> tuple:
    """Generate pattern - dispatches to clustered or single."""
    if self.canvasMult is not None:
        return self.clustered_pattern(symbol_id=f"{self.name}_symbol",fill = fill)
    else:
        return self.single_pattern(fill=fill)

# %% ../nbs/05_terrainpatterns.ipynb #772eb04f
@patch
def climateStyle(self:TerrainPatterns, tile_size=1000, commonFill=None)->([SVGDef],[StyleCSS]):
    cols = [  
        PathPattern("#5F9EA0", "Marine", fill="#6B8A8E", path="marine.txt",
                   design_width=480, design_height=600, tile_size=tile_size/10),
        
        PathPattern("#2F4F4F", "Fresh_Water", fill="#ecf2f8ff", path="freshwater.txt",
                   design_width=480, design_height=600, tile_size=tile_size/10),
        
        PathPattern("#708090", "Tundra", fill="#F0EDE5", path="tundra.txt",
                   design_width=480, design_height=600, tile_size=tile_size/4,
                   canvasMult=6, n_elements=15, cluster_prob=0),
        
        PathPattern("#CD853F", "Desert", fill="#FAE8D0", path="desert.txt",
                   design_width=480, design_height=600, tile_size=tile_size,
                   canvasMult=6, n_elements=10, cluster_prob=0.1),
        
        PathPattern("#6B8E23", "Grassland", fill="#F5F0DC", path="grassland.txt",
                   design_width=2600, design_height=3000, tile_size=tile_size*2,
                   canvasMult=6, n_elements=200),
        
        PathPattern("#355E3B", "Forrest", fill="#EDF2E8", path="forest.txt",
                   design_width=1300, design_height=1500, n_elements=80,tile_size=tile_size,
                   canvasMult=6),
        
        PathPattern("#2E4A3B", "Jungle", fill="#E8F0E4", path="swamp.txt",
                   design_width=1100, design_height=1200, tile_size=tile_size,  n_elements=70,
                   canvasMult=6)
    ]
    
    patterns = []
    styles = []
    for patDef in cols:
        pats, style = patDef.toPattern(fill=commonFill)
        patterns.extend(pats)
        styles.append(style)
    
    return patterns, styles

# %% ../nbs/05_terrainpatterns.ipynb #a5569840
@patch
def namedHatchPattern(patternGen:TerrainPatterns,cols=[],stroke_width=1,spacing=10):
    
    patterns = []
    styles = []
    for pair in cols:      # fixed
        fill = pair.color
        name = pair.name
        patternName = f"{name}_pat_hatch"
        
        pattern = patternGen.crosshatchPattern(patternName,  spacing=spacing,stroke_width= stroke_width,color=fill)  # fixed
        patterns.append(pattern)
        style = StyleCSS(name, fill=f"url(#{patternName})")
        styles.append(style)

    
    return patterns, styles

# %% ../nbs/05_terrainpatterns.ipynb #84727f3d
@patch
def visualize_difference(terrain: Terrain,adjustment,thresholds = [-5, -1, 1, 5] ):
    """Visualize erosion with red (removal) and green (deposition)."""
    
   
    # 5 categories: heavy erosion, light erosion, minimal, light deposition, heavy deposition
      # Splits into 5 bins
    
    colors = [
        "#DC143C",  # Red - heavy erosion (< -5m)
        "#DC143C",  # Red - light erosion (-5 to -1m)
        "#808080",  # Gray - minimal change (-1 to 1m)
        "#32CD32",  # Green - light deposition (1 to 5m)
        "#32CD32",  # Green - heavy deposition (> 5m)
    ]
    
    # Bin adjustment values
    adj_indices = np.digitize(adjustment, thresholds)
    adj_indices = np.clip(adj_indices, 0, len(colors) - 1)
    
    # Create patterns with varying ball density
    patternGen = TerrainPatterns(terrain)
    patterns = patternGen.ballSpectrum(len(colors), fills=colors, prefix="erosion")
    
    # Generate overlay
    return terrain.makeOverlay(adj_indices, patterns)

# %% ../nbs/05_terrainpatterns.ipynb #2a224a50
# Create a terrain
@patch
def circusDemo(self:TerraDemo):
    sampleMap = TerraDemo().tiny()

    def rainfall_selector_np(values: np.ndarray) -> np.ndarray:
        # bin edges: <5 returns 0, 5-12 returns 1, 12-24 returns 2, etc.
        bins = [0.1, 5, 12, 24, 48]
        return np.digitize(values, bins) - 1 

    test_data = np.array([-1, 2, 8, 15, 30, 60, 0, 12, 48])

    indices = rainfall_selector_np(test_data)
    indices

    # Generate random rainfall data
    rainfall_data = np.random.uniform(-4, 60, len(sampleMap.elevations))
    sampleMap.fields['rainfall'] = rainfall_data

    # Get pattern indices
    pattern_indices = rainfall_selector_np(rainfall_data)
    regions = sampleMap.hexGrid.regions_by_value(pattern_indices)

    # Create patterns and overlay
    patternGen = TerrainPatterns(sampleMap)
    patterns = patternGen.ballScale(len(pattern_indices),fills=["#007fff","#d4ff00ff","#ee00ffff","#ff0099ff","#00ff1eff"])  # 5 levels
    patot = sampleMap.hexGrid.overlayRegions(regions, patterns)
    #print(patot)
    sampleMap.hexGrid.builder.adjust("regionfall",patot)
    #sampleMap.colorMap()
    #sampleMap.hexGrid.update()

    # View it
    #print(sampleMap.hexGrid.builder._header())
    return sampleMap.hexGrid.builder.show()


# %% ../nbs/05_terrainpatterns.ipynb #a869a9fd
@patch
def oceanOverlay(self: Terrain):
    terrain = self
    terrain.colorMap()
    
    # Find ocean hexes (level 0)
    ocean_hexes = terrain.find_region_at_level(0)
    ocean_region = HexRegion(hexes=ocean_hexes, hexGrid=terrain.hexGrid)
    
    # Create wave pattern with ocean blues
    patGen = TerrainPatterns(terrain)
    wave = patGen.wavePattern("ocean_waves", 
                              amplitude=4, 
                              wavelength=16, 
                              color="#1565C0",      # stroke: medium blue
                              fill="#E3F2FD")       # fill: light blue
    
    # Apply to region
    return terrain.hexGrid.overlayRegions([ocean_region], [wave])



# %% ../nbs/05_terrainpatterns.ipynb #f376dac4
@patch
def fillPattern(self:HexRegion,pattern:SVGBuilder,smooth=False):
    """Fill a region with a style.

     fill = f"url(#{patName})"

            ret = "<polygon points=\""
            hex = grid.hexes[i]
            for point in hex.vertices():
                ret += f"{point.x:.0f},{point.y:.0f} "
            ret += f"\" style=\"fill:{fill}\""
    
    
    """
    
    fill_layer = ""
    patName = pattern.attributes['id']
    fill = f"url(#{patName})"
    #fill = "#d4ff00eb"

    paths, gaps = self.trace_perimeter(style=StyleCSS("blank"),debug=False)
    #self.builder.add_style(pathstyle)

    pathLayer = ""
    for path in paths:
        if path.points[0].distance(path.points[-1]) < 40:
            cl = path.closed()
        else:
            cl = path
        
        pathLayer += "<path d=\""
        if smooth:
            curved = cl.make_windy(iterations=1, offset_factor=0.1, seed=42)
            smooth = curved.smooth(iterations=1)
            pathLayer += smooth.to_svg_path( close=True)
        else:
            
            pathLayer += cl.to_svg_path( close=True)
        pathLayer += f"\" style=\"fill:{fill}\""
        pathLayer += "/>"
        pathLayer += "\n"
    

    return pathLayer

    
    flowData = np.zeros(len(self.hexGrid.hexes)) - 1

    for i in self.hexes:
        #print(i)
        flowData[i] = 1

    flowData = [int(x) for x in flowData]
    # Create patterns and overlay
    patternGen = TerrainPatterns(self)
    patterns = patternGen.ballDensity(3,fills=fills)  # 5 levels
    self.makeOverlay(flowData, patterns)

# %% ../nbs/05_terrainpatterns.ipynb #f7211cbc
class SVGMask(Generatable):
    """SVG mask definition that can be added to SVGBuilder definitions"""
    
    def __init__(self, mask_id: str, width: int = 10000, height: int = 10000):
        self.mask_id = mask_id
        self.width = width
        self.height = height
        self.paths = []  # List of (path_d, fill_color) tuples
        self.background_color = "white"  # White = show, black = hide
    
    def add_path(self, path_d: str, fill: str = "black", smooth: bool = False):
        """Add a path to the mask. Black areas will be hidden."""
        self.paths.append((path_d, fill))
        return self
    
    def set_background(self, color: str):
        """Set mask background color (white=show, black=hide)"""
        self.background_color = color
        return self
    
    def generate(self) -> str:
        """Generate the mask definition XML"""
        ret = f'<mask id="{self.mask_id}">\n'
        ret += f'  <rect x="0" y="0" width="{self.width}" height="{self.height}" fill="{self.background_color}"/>\n'
        
        for path_d, fill in self.paths:
            ret += f'  <path d="{path_d}" fill="{fill}"/>\n'
        
        ret += '</mask>'
        return ret


# %% ../nbs/05_terrainpatterns.ipynb #5bc8eba6
@patch
def fillPatternInverted(self: HexRegion, pattern: SVGBuilder, smooth: bool = False):
    """Fill OUTSIDE a region with a pattern using a mask."""
    
    # Get the region boundary
    paths = self.trace_perimeter(style=StyleCSS("blank"), debug=False)
    
    # Create mask
    mask_id = f"mask_{id(self)}"
    mask = SVGMask(mask_id)
    
    # Add paths to mask (black = hide these areas)
    for path in paths:
        cl = path.closed() if path.points[0].distance(path.points[-1]) < 40 else path
        
        if smooth:
            curved = cl.make_windy(iterations=1, offset_factor=0.1, seed=42)
            smooth_path = curved.smooth(iterations=1)
            path_d = smooth_path.to_svg_path(close=True)
        else:
            path_d = cl.to_svg_path(close=True)
        
        mask.add_path(path_d, fill="black")
    
    # Add mask to builder definitions
    self.hexGrid.builder.add_definition(mask)
    
    # Create filled rect with mask applied
    patName = pattern.attributes['id']
    fill = f"url(#{patName})"
    
    return f'<rect x="0" y="0" width="10000" height="10000" fill="{fill}" mask="url(#{mask_id})"/>'


# %% ../nbs/05_terrainpatterns.ipynb #a265f038
@patch
def hatchLines(self: TerrainPatterns, angle: float = 45, spacing: float = 8, 
               stroke_width: float = 1.5, color: str = "#3d9fc0ff") -> SVGBuilder:
    """Create diagonal line hatch pattern."""
    
    # Pattern tile needs to be large enough for one full line repeat
    size = spacing * 2
    
    # Calculate line endpoints based on angle
    # For 45Â°, lines go from bottom-left to top-right
    body = f'''
    <g>
        <line x1="0" y1="{size}" x2="{size}" y2="0" 
              stroke="{color}" stroke-width="{stroke_width}"/>
        <line x1="-{size}" y1="{size}" x2="{size}" y2="-{size}" 
              stroke="{color}" stroke-width="{stroke_width}"/>
    </g>
    '''
    
    aBuilder = SVGBuilder()
    aBuilder.blockTag = "pattern"
    aBuilder.width = size
    aBuilder.height = size
    aBuilder.attributes = {
        'id': 'hatch_lines',
        'patternUnits': 'userSpaceOnUse',
        'patternTransform': f'rotate({angle})'
    }
    aBuilder.updateLayers([body])
    
    return aBuilder

# %% ../nbs/05_terrainpatterns.ipynb #ff4b3a54
@patch
def island(self:TerraDemo):
    mySize = MapSize(480,480)
    myBounds = MapRect(MapCord(0,0), mySize)
    sampleMap =  Terrain(myBounds,radius=15,path = "volcano.svg")
    
    sampleMap.elevations += sampleMap.volcano(center=267,adjusted=500,num_rings=6,variability=0.5,initial_threshold=0.4)

    levels = [x for x in range(len(sampleMap.elevations)-1) if sampleMap.elevationLevel(x) >= 0]

    region = HexRegion(hexes=set(levels), hexGrid=sampleMap.hexGrid)
    fills=["#3300ffeb","#3d9fc0ff"]
    patternGen = TerrainPatterns(sampleMap)
    patterns = patternGen.ballDensity(4,fills=fills)

    sampleMap.colorMap()
    sampleMap.hexGrid.update()

    myPat = patterns[1]
    #myPat = patternGen.hatchLines(angle=25, spacing=8, stroke_width=1.5, color="#3d9fc0ff")

    sampleMap.hexGrid.builder.add_definition(myPat)
    over = region.fillPatternInverted(myPat,True)
    #sampleMap.builder.adjust(f"root","")
    sampleMap.builder.adjust(f"ocean",over)
    return sampleMap

@patch
def demoAquatic(self:TerraDemo):
    sampleMap = self.island()

    

    #print(sampleMap.hexGrid.builder.xml())
    

    return sampleMap.hexGrid.builder.show()

# %% ../nbs/05_terrainpatterns.ipynb #a75e0585
@patch
def mapElement(sampleMap:Terrain,bounds:MapCord,name="compass_1",prefix="merright",style=StyleCSS("base", 
                        fill="#27ae60",  # Green
                        stroke="#c12121ff")): 
    
    # Show the terrain first
    sampleMap.colorMap()
    sampleMap.hexGrid.update()

    dim = bounds.dimensons.width
    xoffset = bounds.origin.x
    yoffset = bounds.origin.y

    
    #
    #name = 'compass_1.svg' #'merright_1svg'.
    aPat = SeaPatterns.load_pattern(name + '.svg', f"{name}_aid", prefix=prefix)

    # Override to green - all paths will have class="merright_path"
    green_style = StyleCSS(f"{prefix}_path", 
                        fill=style.properties["fill"],  # Green
                        stroke=style.properties["stroke"])
    aPat.attributes['patternUnits'] = 'userSpaceOnUse'
    aPat.attributes['patternContentUnits'] = 'objectBoundingBox'
    aPat.attributes['patternTransform'] = f'translate({xoffset},{yoffset}) scale({dim/aPat.width})'
    aPat.add_style(green_style)
    #aPat.add_style(green_style, prefix="merright")
    
    sampleMap.hexGrid.builder.add_definition(aPat)
    over = f'<rect x="{xoffset}" y="{yoffset}" width="{dim}" height="{dim}" fill="#0080ff1f"   opacity="0.8"/>'
    over = f'<rect x="{xoffset}" y="{yoffset}" width="{dim}" height="{dim}" fill="url(#{name}_aid)"   opacity="0.8"/>'
    return over
    

    

    return sampleMap.hexGrid.builder.show()

# %% ../nbs/05_terrainpatterns.ipynb #1958f05a
@patch
def styleLayerOrdered(self: HexGrid, styles: list[StyleCSS],  f=None, smooth=False,inset=None):
    """Generate style layer with styles applied in specified order.
    
    Args:
        styles: List of StyleCSS objects in the order to render them
        f: Optional edge transformation function
    """
    retLayer = ""
    regions = self.styleRegions()
    borders = {}
    rendered = set()
    if inset is None:
        inset = 1

    # First: render specified styles in order
    for style in styles:
        styleName = style.name
        if styleName not in regions:
            continue
        rendered.add(styleName)
        region = regions[styleName]
        for path in region.trace_perimeter_cached(borders, f, style, inset=inset):
            if smooth:
                retLayer += path.sbg()
            else:
                retLayer += path.drawClosed()

    # Then: render any remaining regions
    for styleName, region in regions.items():
        if styleName in rendered:
            continue
        style = self.builder.styles.get(styleName)
        for path in region.trace_perimeter_cached(borders, f, style):
            retLayer += path.drawClosed()

    return retLayer


# %% ../nbs/05_terrainpatterns.ipynb #fa480f96
@patch
def contorOverlay(self:Terrain,stroke_width=4,f=None,commonStroke=None):
    if commonStroke is None:
        contorColors = [StyleCSS(f"{x.name}_stroked",fill="none",stroke = x.properties["fill"],stroke_width = stroke_width)  for x in self.colorLevels]
    else:
        contorColors = [StyleCSS(f"{x.name}_stroked",fill="none",stroke = commonStroke,stroke_width = stroke_width)  for x in self.colorLevels]
    numHeights = len(contorColors)
    if numHeights < 1:
        return 0
    for color in contorColors:
        self.hexGrid.builder.add_style(color)

    seaStroke = StyleCSS("seaStroke",fill="none",stroke = self.seaLevel.properties["fill"],stroke_width = stroke_width)
    self.hexGrid.builder.add_style(seaStroke)
   
    for i in range(len(self.elevations)):
        height = int(self.elevations[i]  / self.elevationDelta)

        aLevel =  seaStroke
        if self.elevations[i]  > 0:
            if height < numHeights:
                aLevel = contorColors[height]
            else:
                aLevel = contorColors[-1]
        self.hexGrid.hexes[i].style = aLevel
    return self.hexGrid.styleLayerOrdered(
        styles=contorColors,
        f=f)
