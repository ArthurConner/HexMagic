"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/tutorials/math.ipynb.

# %% auto 0
__all__ = ['sampleHex', 'hexStyle', 'canvas', 'grid', 'arrowLayer', 'eastDir', 'start', 'perimeter_style', 'region', 'paths',
           'overlay', 'showEast', 'showRing', 'flip', 'roll', 'hexes_in_range', 'line_demo', 'range_demo',
           'rotation_demo', 'demo_region_spiral_with_arrows', 'demo_region_erosion', 'demo_voronoi_growth_simple']

# %% ../../nbs/tutorials/math.ipynb 5
#import nbdev; nbdev.nbdev_export()
import sys
import math
from fastcore.basics import patch

# %% ../../nbs/tutorials/math.ipynb 8
from ..plot.math import  MapCord 
from ..plot.Hex import Hex


# %% ../../nbs/tutorials/math.ipynb 10
sampleHex = Hex(radius=50,center=MapCord(100,100))

sampleHex.vertices(), "\n-- We round edges so we can compare --\n", sampleHex.edges()

# %% ../../nbs/tutorials/math.ipynb 11
from ..styles import StyleCSS,  SVGBuilder

# %% ../../nbs/tutorials/math.ipynb 12
#some drawing setup 
hexStyle = StyleCSS("HexStyle",fill="yellow",stroke="blue",stroke_width=2)
canvas = SVGBuilder()
canvas.width=200 ;canvas.height=200
canvas.add_style(hexStyle)

#add our hex to the canvas
sampleHex = Hex(radius=50,center=MapCord(100,100),style=hexStyle)
canvas.adjust("main",sampleHex.svg())

#show our work
canvas.show()
canvas.adjust("main",sampleHex.svg())

#show our work
canvas.show()

# %% ../../nbs/tutorials/math.ipynb 17
grid = sampleGrid(makeLabels=True)
grid.builder.show()

# %% ../../nbs/tutorials/math.ipynb 19
from ..plot.HexPosition import HexPosition 
from ..plot.math import MapPath
grid = sampleGrid()

#mark the treasure
grid.hexes[grid.midpoint].label = "X"

#lets have a directions layer
arrowLayer = ""

#Use the realtive position class called HexPosition
for position in HexPosition.directions():
    i = grid.hexposition_to_index(position, 12)
    grid.hexes[i].label = position.label
    arrowLayer += grid.arrow(12,i)

grid.update()

#we can add a layer or update one in a builder using the adjust method
grid.builder.adjust("arrows",arrowLayer)

grid.builder.show()

# %% ../../nbs/tutorials/math.ipynb 20
eastDir = HexPosition.E
eastDir,  2 * eastDir

# %% ../../nbs/tutorials/math.ipynb 21
def showEast(middleIndex=12):
    grid = sampleGrid()

    #lets have a directions layer
    arrowLayer = ""
    
    #Mark our starting point
    grid.hexes[middleIndex].label = str(middleIndex)

    #Get a Direction
    eastDir = HexPosition.E

    #go part way
    i = grid.hexposition_to_index(eastDir, middleIndex)
    grid.hexes[i].label = "near"
    arrowLayer += grid.arrow(middleIndex,i)

    #keep going
    farEast = 2 * eastDir 
    j = grid.hexposition_to_index(farEast, middleIndex)
    grid.hexes[j].label = "far"
    arrowLayer += grid.arrow(i,j)

    grid.update()
    grid.builder.adjust("arrows",arrowLayer)
    return grid.builder.show()
showEast(12)


# %% ../../nbs/tutorials/math.ipynb 23
showEast(6)

# %% ../../nbs/tutorials/math.ipynb 25
def showRing(middleIndex=12,ring=1):
    grid = sampleGrid()
    
    grid.hexes[middleIndex].label = "X"


    #lets have a directions layer
    arrowLayer = ""
    #Get a Direction
    eastDir = HexPosition.E

    #go out to the edge
    s = middleIndex
    for k in range(ring):
        i = grid.hexposition_to_index(eastDir, s)
        grid.hexes[i].label = f"r {k+1}"
        arrowLayer += grid.arrow(s,i)
        s = i

    origin = HexPosition.origin()

    #now lets go through the positions. by default it starts in the east like the sunrise.
    positions = origin.ring(ring)
    for pos in positions:
        i = grid.hexposition_to_index(pos,middleIndex ) 
        grid.hexes[i].label = f"r {pos.label}"
        if s != i:
            arrowLayer += grid.arrow(s,i)
        s = i

    grid.update()
    grid.builder.adjust("arrows",arrowLayer)
    return grid.builder.show()
    
showRing(12)

# %% ../../nbs/tutorials/math.ipynb 26
showRing(12,ring=2)

# %% ../../nbs/tutorials/math.ipynb 32
def flip(h):
    return (-HexPosition.direction(h)).desc()


flip("E")

# %% ../../nbs/tutorials/math.ipynb 34
def roll(h):
    """ Geometric meaning**: Rotation by 60째 counter-clockwise around the origin."""
    pos = -HexPosition.direction(h)
    return HexPosition(pos.s,pos.q,pos.r).desc()
   

#Rolling six times returns to the original position, giving us **cyclic order**.
start = "E"
for I in range(6):
    print(start)
    start = roll(start)

#**Algebraic significance**: Roll generates **rotational symmetry**, the six-fold symmetry that makes hexagons special.


# %% ../../nbs/tutorials/math.ipynb 40
def hexes_in_range(n):
    """ finding all hexes within distance N from origin: """
    results = []
    for q in range(-n, n + 1):
        for r in range(max(-n, -q - n), min(n, -q + n) + 1):
            s = -q - r
            results.append(HexPosition(q, r, s))
    return results

hexes_in_range(3)

# %% ../../nbs/tutorials/math.ipynb 42
def line_demo(start_idx=20, end_idx=8):
    """Demo showing line drawing between two hexes using cube coordinates"""
    grid = sampleGrid()
    # Clear the axis arrows from sampleGrid
    grid.builder.adjust("axis", "")
    
    # Mark start and end
    grid.hexes[start_idx].label = "Start"
    grid.hexes[end_idx].label = "End"

    location = grid.index_to_hexposition
    
    # Get the hex positions. This defaults to postion 0
    start_pos = location(start_idx)
    end_pos = location(end_idx)
    
    # Draw a line between them using cube coordinate interpolation
    path_positions = start_pos.line_to(end_pos)
    
    arrowLayer = ""
    prev_idx = start_idx
    
    for i, pos in enumerate(path_positions[1:], 1):  # Skip first (it's the start)
        curr_idx = grid.hexposition_to_index(pos)
        
        # Label intermediate hexes
        if curr_idx != end_idx and curr_idx >= 0:
            grid.hexes[curr_idx].label = str(i)
        
        # Draw arrow if valid index
        if curr_idx >= 0:
            arrowLayer += grid.arrow(prev_idx, curr_idx)
            prev_idx = curr_idx
    
    grid.update()
    grid.builder.adjust("arrows", arrowLayer)
    return grid.builder.show()

line_demo(20, 8)


# %% ../../nbs/tutorials/math.ipynb 43
def range_demo( max_distance=2):
    """Demo showing all hexes within a certain distance"""
    
    grid = sampleGrid(3, fill="lightgray")
    center_idx = grid.midpoint

    # Mark center
    grid.hexes[center_idx].label = "0"
    
    # Get center position
    center_pos = grid.index_to_hexposition(center_idx)
    
    # Color hexes by distance
    colors = [StyleCSS(x,fill=x,stroke="blue",stroke_width=2) for x in ["green","yellow", "orange", "red", "purple"]]
    for color in colors:
        grid.builder.add_style(color)
    
    for distance in range(1, max_distance + 1):
        # Get all positions at this distance
        positions = center_pos.ring(distance)
        
        for pos in positions:
            try:
                idx = grid.hexposition_to_index(pos, center_idx)
                if 0 <= idx < len(grid.hexes):
                    grid.hexes[idx].label = str(distance)
                    grid.hexes[idx].style = colors[distance-1]
                    # You could change fill color here if we modify the hex style
            except:
                pass  # Position outside grid
    
    grid.update()
    return grid.builder.show()

range_demo(3)


# %% ../../nbs/tutorials/math.ipynb 44
def rotation_demo(center_idx=12):
    """Demo showing rotation around a center hex"""
    grid = sampleGrid()
    # Clear the axis arrows from sampleGrid
    grid.builder.adjust("axis", "")
    
    grid.hexes[center_idx].label = "Center"
    
    # Start with a position to the east
    start_pos = HexPosition.E
    start_idx = grid.hexposition_to_index(2 * start_pos , center_idx)
    grid.hexes[start_idx].label = "0째"
    
    arrowLayer = ""
    prev_idx = start_idx
    
    # Rotate around 60째 at a time
    for i in range(1, 6):
        # Rotate the position
        rotated_pos = 2 * start_pos.rotate(-i)
        curr_idx = grid.hexposition_to_index(rotated_pos, center_idx)
        
        grid.hexes[curr_idx].label = f"{i*60}째"
        arrowLayer += grid.arrow(prev_idx, curr_idx)
        prev_idx = curr_idx
    
    # Close the loop
    arrowLayer += grid.arrow(prev_idx, start_idx)
    
    grid.update()
    grid.builder.adjust("arrows", arrowLayer)
    return grid.builder.show()

rotation_demo(12)


# %% ../../nbs/tutorials/math.ipynb 45
def demo_region_spiral_with_arrows():
    """Demo showing a region growing in a spiral pattern with arrows"""
    grid = sampleGrid(4, fill="lightgray")
    
    # Create gradient of colors
    colors = StyleCSS.seaborn("BuGn",37)
    
    arrow_style = StyleCSS("spiral_arrow", stroke="#333333", stroke_width=2, fill="none")
    
    for color in colors:
        grid.builder.add_style(color)
    grid.builder.add_style(arrow_style)
    
    center = grid.midpoint
    
    # Use the spiral method from HexPosition
    spiral_positions = HexPosition.origin().spiral(3)
    
    arrow_layer = ""
    prev_idx = None
    
    for i, pos in enumerate(spiral_positions):
        idx = grid.hexposition_to_index(pos, center)
        if 0 <= idx < len(grid.hexes):
            grid.hexes[idx].style = colors[i % len(colors)]
            grid.hexes[idx].label = str(i)
            
            # Draw arrow from previous hex to current
            if prev_idx is not None and prev_idx >= 0:
                arrow_layer += grid.arrow(prev_idx, idx, style=arrow_style)
            
            prev_idx = idx
    
    grid.update()
    grid.builder.adjust("arrows", arrow_layer)
    return grid.builder.show()



# %% ../../nbs/tutorials/math.ipynb 46
demo_region_spiral_with_arrows()

# %% ../../nbs/tutorials/math.ipynb 48
from ..region import HexRegion

# %% ../../nbs/tutorials/math.ipynb 51
grid = sampleGrid(3, fill="lightgray")
perimeter_style=StyleCSS("perimeter_path", fill="red",  stroke="#ba3ca3ff", stroke_width=3)

region = HexRegion(set([grid.midpoint,grid.midpoint+1]), grid) 

paths = region.trace_perimeter(style=perimeter_style)
grid.builder.add_style(perimeter_style)
overlay = "" + "".join([x.drawPloy() for x in paths])
grid.builder.adjust("regionBorder",overlay)
grid.builder.show()

# %% ../../nbs/tutorials/math.ipynb 52
grid = sampleGrid(3, fill="lightgray")
perimeter_style=StyleCSS("perimeter_path", fill="red",  stroke="#ba3ca3ff", stroke_width=3)

region = HexRegion(set([grid.midpoint,grid.midpoint+1,grid.midpoint//2]), grid) 

paths = region.trace_perimeter(style=perimeter_style)
grid.builder.add_style(perimeter_style)
overlay = "" + "".join([x.drawPloy() for x in paths])
grid.builder.adjust("regionBorder",overlay)
grid.builder.show()

# %% ../../nbs/tutorials/math.ipynb 54
def demo_region_erosion():
    """Demo showing a region eroding from outside in"""
    grid = sampleGrid(4, fill="lightgray")

    # We can do this first because we are going to add layers on top of it
    grid.update()

    stages = [
        StyleCSS(f"erode{i}", fill=color, stroke="blue", stroke_width=2)
        for i, color in enumerate(["#2c3e50", "#34495e", "#7f8c8d", "#95a5a6", "#bdc3c7"])
    ]


    
    for style in stages:
        grid.builder.add_style(style)
    
    center = grid.midpoint
    large_region = HexRegion(
        set(grid.hexposition_to_index(pos, center) 
            for pos in HexPosition.origin().spiral(3)
            if grid.hexposition_to_index(pos, center) >= 0),
        grid
    )
    
    # First pass: create layers and count them
    current_region = large_region
    stage = 0

    while len(current_region.hexes) > 0 and stage < len(stages):
        boundaries = current_region.trace_perimeter(style=stages[stage])
        layerId = f"stage{stage}"
        grid.builder.adjust(layerId, "\n".join([x.drawPloy() for x in boundaries]))
        current_region = current_region.inside()
        stage += 1
   
    return grid.builder

demo_region_erosion().show()

# %% ../../nbs/tutorials/math.ipynb 62
def demo_voronoi_growth_simple():
    """Simpler Voronoi growth using HexRegion list"""
    grid = sampleGrid(5, fill="lightgray")
    grid.update()
    
    colors = [
        StyleCSS("region0", fill="#ff6b6b", stroke="darkred", stroke_width=0),
        StyleCSS("region1", fill="#4ecdc4", stroke="darkblue", stroke_width=0),
        StyleCSS("region2", fill="#95e1d3", stroke="darkgreen", stroke_width=0),
        StyleCSS("region3", fill="#f38181", stroke="darkorange", stroke_width=0),
    ]
    layer_names = []
    
    perimeter_style = StyleCSS("perimeter_path", fill="none", stroke="#333", stroke_width=3)
    arrow_style = StyleCSS("growth_arrow", stroke="#333333", stroke_width=2, fill="none")
    boundary_layer = ""
    for style in colors + [perimeter_style, arrow_style]:
        grid.builder.add_style(style)
    
    seeds = [
        grid.nCols * 1 + 1,
        grid.nCols * 1 + (grid.nCols - 2),
        grid.nCols * (grid.nRows - 2) + 1,
        grid.nCols * (grid.nRows - 2) + (grid.nCols - 2),
    ]
    
    regions = [HexRegion({seed}, grid) for seed in seeds]
    
    for i, seed in enumerate(seeds):
        grid.hexes[seed].style = colors[i]
        grid.hexes[seed].label = str(i)
    
    claimed = set(seeds)
    total = grid.nRows * grid.nCols
    
    
    # Grow until everything is claimed
    for round_num in range(30):
        arrow_layer = ""
        if len(claimed) >= total:
            break
        
        # Collect ALL unclaimed candidates and which regions want them
        candidates = {}  # hex_idx -> [(region_idx, source, dist), ...]
        
        for i, region in enumerate(regions):
            centroid_idx = region.centroid_hex()
            centroid_pos = grid.index_to_hexposition(centroid_idx)
            
            outside = region.outside()
            for candidate in outside.hexes:
                if candidate in claimed:
                    continue
                    
                neighbors = grid.neighborsOf(candidate)
                source = next((n for n in neighbors if n in region.hexes), None)
                
                if source is not None:
                    candidate_pos = grid.index_to_hexposition(candidate)
                    dist = candidate_pos.distance(centroid_pos)
                    
                    if candidate not in candidates:
                        candidates[candidate] = []
                    candidates[candidate].append((i, source, dist))
        
        if not candidates:
            break
        
        # Assign each candidate to closest region (or first if tied)
        for candidate, claimants in candidates.items():
            claimants.sort(key=lambda x: (x[2], x[0]))  # Sort by dist, then region idx for ties
            region_idx, source, dist = claimants[0]
            
            claimed.add(candidate)
            regions[region_idx] = HexRegion(regions[region_idx].hexes | {candidate}, grid)
            grid.hexes[candidate].style = colors[region_idx]
            arrow_layer += grid.arrow(source, candidate, style=arrow_style)
    
        for region in regions:
            paths = region.trace_perimeter(style=perimeter_style)
            boundary_layer += "".join([x.make_windy(iterations=2, offset_factor=0.2).svg() for x in paths])
        arrowName = f"arrows_{round_num}"
        grid.builder.adjust(arrowName, arrow_layer)
        layer_names.append(arrowName)
    grid.update()

    anim = LoopingLayerAnimation(layer_names, visible_count=2, step_duration=0.5, fade_duration=0.1, dim_opacity=0)
    apply_looping_animation( grid.builder,anim)
    
    grid.builder.adjust("boundaries", boundary_layer)
    return grid.builder.show()

