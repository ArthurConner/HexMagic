"""Cube coordinate system for hexagonal grids"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/plots/02b_Position.ipynb.

# %% auto #0
__all__ = ['HexPosition', 'directions_in_cone', 'hex_in_cone', 'GosperCurve']

# %% ../../nbs/plots/02b_Position.ipynb #74969d80
import numpy as np
import math
from functools import reduce
from dataclasses import dataclass, field
from fastcore.basics import patch
from ..styles import StyleCSS

# %% ../../nbs/plots/02b_Position.ipynb #4878eb51
from .primitives import MapCord, MapPath , PrimitiveDemo

# %% ../../nbs/plots/02b_Position.ipynb #53f003f8
@dataclass
class HexPosition:
    _coords: np.ndarray = field(default_factory=lambda: np.array([0, 0, 0]))
    label: str = ""

    _theDirs = {(1, 0, -1):"E",
        (1, -1, 0):"NE",
        (0, -1, 1):"NW",
        (-1, 0, 1):"W",
        (-1, 1, 0):"SW", 
        (0, 1, -1):"SE",
        (0, 0, 0):"X"
        }

        # Add reverse mapping
    _labelToDirs = {v: k for k, v in _theDirs.items()}
    _rings = []
    _neigbors = []
    
    def __init__(self, q: int = 0, r: int = 0, s: int = 0, label: str = ""):
        self._coords = np.array([q, r, s])
        self.label = label
    
    @property
    def q(self) -> int: return int(self._coords[0])
    
    @property
    def r(self) -> int: return int(self._coords[1])
    
    @property
    def s(self) -> int: return int(self._coords[2])

    @classmethod 
    def direction(cls, lbl):
        coords = HexPosition._labelToDirs.get(lbl, (0, 0, 0))
        return cls(*coords, label=lbl)
     
    def desc(self):
        return HexPosition._theDirs.get((self.q,self.r,self.s),  self.label)

    @classmethod
    def origin(cls)->'HexPosition':
        return HexPosition(0,0,0,"origin")
   
    @classmethod
    def directions(cls):

        return HexPosition._orderDirs 

    def copy(self,label:None):
        if label is None:
            label = self.label
        return HexPosition(self.q,self.r,self.s,label)

    @property
    def cube_coords(self):
        return (self.q, self.r, self.s)
    
    def encode(self) -> str:
        """Encode as string like '2^3' (ring^position)"""
        return f"{self.q}^{self.r}^{self.s}"

   
    
    def pixel(self, hex_radius: float, center: MapCord) -> tuple[float, float]:
        """Convert HexPosition cube coordinates to pixel position for pointy-top hex."""
        x = hex_radius * (math.sqrt(3) * self.q + math.sqrt(3)/2 * self.r)
        y = hex_radius * (3/2 * self.r)
        return MapCord(center.x + x, center.y + y)
    
    @staticmethod
    def decode(s: str) -> 'HexPosition':
        """Decode from string like '2^3'"""
        vals = s.split('^')
        return HexPosition(q=int(vals[0]), r=int(vals[1]),s=int(vals[2]))

    @staticmethod
    def _cube_round(q: float, r: float, s: float) -> 'HexPosition':
        """Round fractional cube coords to nearest valid hex."""
        rq, rr, rs = round(q), round(r), round(s)
        dq, dr, ds = abs(rq - q), abs(rr - r), abs(rs - s)
        
        # Adjust the largest diff to maintain q + r + s = 0
        if dq > dr and dq > ds:
            rq = -rr - rs
        elif dr > ds:
            rr = -rq - rs
        else:
            rs = -rq - rr
        
        return HexPosition(int(rq), int(rr), int(rs))

    @staticmethod
    def average(positions: list['HexPosition']) -> 'HexPosition':
        """Calculate the average position of a list of HexPositions."""
        if not positions:
            return HexPosition.origin()
        
        total = sum(positions, HexPosition.origin())
        return HexPosition._cube_round(total.q / len(positions), 
                                        total.r / len(positions), 
                                        total.s / len(positions))

    @staticmethod
    def weighted_average(positions: list['HexPosition'], weights: list[float]) -> 'HexPosition':
        """Calculate weighted average of HexPositions.
        
        Args:
            positions: List of HexPositions
            weights: List of weights (same length as positions)
        """
        if not positions or not weights:
            return HexPosition.origin()
        
        if len(positions) != len(weights):
            raise ValueError("positions and weights must have same length")
        

        weighted_sum = reduce(lambda acc, pw: acc + pw[1] * pw[0], 
                            zip(positions, weights), 
                            HexPosition.origin())
        
        total_weight = sum(weights)
        if total_weight == 0:
            return HexPosition.origin()
        
        return HexPosition._cube_round(weighted_sum.q / total_weight,
                                        weighted_sum.r / total_weight,
                                        weighted_sum.s / total_weight)


HexPosition._orderDirs = [HexPosition.direction(lbl) for lbl in ["SW","W","NW", "NE", "E", "SE"]]


# %% ../../nbs/plots/02b_Position.ipynb #f790748d
@patch
def distance(self: HexPosition, other: HexPosition) -> int:
    """Cube coordinate distance using numpy"""
    return int(np.abs(self._coords - other._coords).sum() // 2)

@patch
def __add__(self: HexPosition, other: 'HexPosition') -> 'HexPosition':
    return HexPosition(*(self._coords + other._coords))

@patch
def __sub__(self: HexPosition, other: 'HexPosition') -> 'HexPosition':
    return HexPosition(*(self._coords - other._coords))

@patch
def __rmul__(self: HexPosition, scalar: int) -> 'HexPosition':
    return HexPosition(*(self._coords * scalar))

@patch
def __neg__(self: HexPosition) -> 'HexPosition':
    return HexPosition(*(-self._coords))

@patch
def __abs__(self: HexPosition) -> int:
    """Distance from origin: abs(pos)"""
    return self.distance(HexPosition.origin())

@patch
def __eq__(self: HexPosition, other) -> bool:
    """Equality: pos1 == pos2"""
    if not isinstance(other, HexPosition):
        return False
    return self.q == other.q and self.r == other.r and self.s == other.s


@patch
def __hash__(self: HexPosition) -> int:
    """Hash for use in sets/dicts"""
    return hash((self.q, self.r,self.s))

# %% ../../nbs/plots/02b_Position.ipynb #54b01dfe
@patch
def __repr__(self: HexPosition) -> str:
    """Better string representation"""
    if self.label:
        return f"HexPosition({self.q}, {self.r}, {self.s}, '{self.label}')"
    return f"HexPosition({self.q}, {self.r}, {self.s})"

# %% ../../nbs/plots/02b_Position.ipynb #5fd6c384
@patch
def rotate_left(self: HexPosition) -> 'HexPosition':
    """Rotate 60° counter-clockwise: (q,r,s) -> (-s,-q,-r)"""
    return HexPosition(*(-np.roll(self._coords, 1)))

@patch
def rotate_right(self: HexPosition) -> 'HexPosition':
    """Rotate 60° clockwise: (q,r,s) -> (-r,-s,-q)"""
    return HexPosition(*(-np.roll(self._coords, -1)))

@patch
def rotate(self: HexPosition, steps: int = 1) -> HexPosition:
    """Rotate around origin. Positive = counter-clockwise, negative = clockwise."""
    steps = steps % 6
    coords = self._coords
    # Apply sign pattern: even rotations keep sign, odd rotations negate
    sign = 1 if steps % 2 == 0 else -1
    rolled = np.roll(coords, steps)
    return HexPosition(*(sign * rolled), label=self.label)

# %% ../../nbs/plots/02b_Position.ipynb #5d356d35
@patch
def _ring(self: HexPosition, radius: int, clockwise: bool = True) -> list['HexPosition']:
    """Generate all HexPositions in a ring at given radius from center."""
    if radius == 0:
        return [self]
    
    results = []
    current = self + radius * HexPosition.direction("E")
    
    # SW for counter-clockwise, SE for clockwise
    direction = HexPosition.direction("E").rotate(2 if not clockwise else -2)
    rotation = 1 if not clockwise else -1
    
    for side in range(6):
        for _ in range(radius):
            results.append(current)
            current = current + direction
        direction = direction.rotate(rotation)
    
    return results

# %% ../../nbs/plots/02b_Position.ipynb #1ca8a637
@patch
def _neighbor(self: HexPosition, direction: int) -> 'HexPosition':
    """Get neighbor in direction (0-5, starting East and going counter-clockwise)"""
    directions = HexPosition.directions()
    return self + directions[direction % 6]

HexPosition._rings = [HexPosition.origin()._ring(i) for i in range(10)]
HexPosition._neighbors = [HexPosition.origin()._neighbor(i) for i in range(6)]


# %% ../../nbs/plots/02b_Position.ipynb #5863d287
@patch
def ring(self: HexPosition, radius: int, clockwise: bool = True) -> list['HexPosition']:
    """Generate all HexPositions in a ring at given radius from center.
    
    Uses cached rings for radius < 10 when clockwise and centered at origin.
    """
    # Fast path: use cached rings if at origin, clockwise, and radius < 10
    if radius < 10 and clockwise and self.q == 0 and self.r == 0 and self.s == 0:
        return HexPosition._rings[radius]
    
    # Fast path: use cached rings and offset if radius < 10 and clockwise
    if radius < 10 and clockwise:
        return [self + pos for pos in HexPosition._rings[radius]]
    
    # Slow path: compute on demand
    return self._ring(radius, clockwise)

# %% ../../nbs/plots/02b_Position.ipynb #bcda199c
@patch
def neighbor(self: HexPosition, direction: int) -> 'HexPosition':
    """Get neighbor in direction (0-5, starting East going counter-clockwise).
    
    Uses cached neighbor offsets for better performance.
    """
    # Use cached neighbors
    return self + HexPosition._neighbors[direction % 6]

# %% ../../nbs/plots/02b_Position.ipynb #20b9d358
@patch
def line_to(self: HexPosition, other: HexPosition) -> list[HexPosition]:
    """Get line of hexes from self to other using linear interpolation"""
    n = self.distance(other)
    if n == 0:
        return [self]

    results = []
    for i in range(n + 1):
        t = i / n
        # Lerp in cube coordinates using numpy
        coords = self._coords + (other._coords - self._coords) * t
        results.append(HexPosition._cube_round(*coords))

    return results

# %% ../../nbs/plots/02b_Position.ipynb #659022c7
@patch
def path_through_waypoints(self: HexPosition, waypoints: list[HexPosition], 
                           destination: HexPosition) -> list[HexPosition]:
    """Create a path from self through all waypoints to destination.
    
    Args:
        waypoints: List of intermediate points to visit
        destination: Final destination
        use_lines: If True, use straight lines. If False, use radial paths (default)
    """
    if not waypoints:
        return self.line_to(destination) 
    
    full_path = []
    current = self
    path_method = (lambda a, b: a.line_to(b)) 
    
    # Go through each waypoint
    for waypoint in waypoints:
        segment = path_method(current, waypoint)
        # Avoid duplicates at segment boundaries
        if full_path and segment and full_path[-1].cube_coords == segment[0].cube_coords:
            full_path.extend(segment[1:])
        else:
            full_path.extend(segment)
        current = waypoint
    
    # Final segment to destination
    final_segment = path_method(current, destination)
    if full_path and final_segment and full_path[-1].cube_coords == final_segment[0].cube_coords:
        full_path.extend(final_segment[1:])
    else:
        full_path.extend(final_segment)
    
    return full_path

# %% ../../nbs/plots/02b_Position.ipynb #f54c740d
@patch
def move_in(self: HexPosition, center: HexPosition) -> HexPosition:
    """Move one step toward center."""
    if self == center:
        return self
    return self.line_to(center)[1]

@patch
def move_out(self: HexPosition, center: HexPosition) -> HexPosition:
    """Move one step away from center."""
    if self == center:
        return self
    return 2 * self - self.move_in(center)


# Set direction attributes
for x in ["E","NE","NW", "W","SW", "SE"]:
    setattr(HexPosition, x, HexPosition.direction(x))

# %% ../../nbs/plots/02b_Position.ipynb #bd7d2f31
@patch
def postionDemo(self: PrimitiveDemo):
    east = HexPosition.E
    print(f"this is east {HexPosition.E}")
    middle = HexPosition.origin()
    print(f"this is middle {middle}")
    ring = middle.ring(8)[:5]
    print(f"this is the first few in the ring 8 away frome east {ring}")
    
    path = middle.line_to(HexPosition(6, 3, -9))
    print(f"making a line {path}")

    print("This is how we would walk from one to another")
    start = middle
    for pos in path:
        print((pos - start).desc())
        start = pos

    lineMiddle = HexPosition.average(path)
    print(f"the middle of the line is {lineMiddle}")

# %% ../../nbs/plots/02b_Position.ipynb #e61b9e1f
def directions_in_cone(flow_dir: HexPosition, allowed_rotations: int) -> set[HexPosition]:
    """Get all directions within N rotations of flow_dir."""
    dirs = {flow_dir}
    current_left = flow_dir
    current_right = flow_dir
    for _ in range(allowed_rotations):
        current_left = current_left.rotate_left()
        current_right = current_right.rotate_right()
        dirs.add(current_left)
        dirs.add(current_right)
    return dirs

def hex_in_cone(hex_pos: HexPosition, flow_dir: HexPosition, allowed_rotations: int) -> bool:
    """Check if hex_pos is within cone defined by flow_dir ± allowed_rotations."""
    if abs(hex_pos) == 0:
        return True
    
    # Get direction of first step from origin toward hex_pos
    path_to_hex = HexPosition.origin().line_to(hex_pos)
    if len(path_to_hex) < 2:
        return True
    
    first_step = path_to_hex[1] - path_to_hex[0]  # Direction toward hex
    
    allowed = directions_in_cone(flow_dir, allowed_rotations)
    return first_step in allowed


# %% ../../nbs/plots/02b_Position.ipynb #b4323ed6
@patch
def spiral(self: HexPosition, radius: int,clockwise=True) -> list[HexPosition]:
    """Get all hexes in a true spiral pattern from center out to radius.
    
    Returns hexes in order where each hex is adjacent to the previous one,
    creating a continuous spiral path rather than concentric rings.
    """
    if radius == 0:
        return [self]
    
    results = [self]  # Start at center
    current = self
    
    # Start moving east
    last_direction = HexPosition.direction("E")
    
    for ring in range(1, radius + 1):
        # Move out one step to start the new ring
        current = current + last_direction
        results.append(current)
        
        # Walk around this ring - 6 sides, 'ring' steps per side
        for side in range(6):
            # Rotate counter-clockwise to next direction
            if clockwise:
                last_direction = last_direction.rotate_right()
            else:
                last_direction = last_direction.rotate_left()
            
            # Walk 'ring' steps in this direction
            # (but skip the first step on first side since we already moved out)
            steps = ring if side > 0 else ring - 1
            for step in range(steps):
                current = current + last_direction
                results.append(current)
    
    return results

# %% ../../nbs/plots/02b_Position.ipynb #6ffb4efc
class GosperCurve:
    """Generate Gosper curves using L-system rules and cube coordinates."""
    
    def __init__(self, order: int = 3):
        self.order = order
        
    @staticmethod
    def _expand_lsystem(axiom: str, rules: dict, iterations: int) -> str:
        """Expand an L-system string."""
        current = axiom
        for _ in range(iterations):
            current = ''.join(rules.get(c, c) for c in current)
        return current
    
    @classmethod
    def generate_path(cls, order: int, start: HexPosition = None) -> list[HexPosition]:
        """
        Generate a Gosper curve path using L-system.
        
        The Gosper curve L-system:
        - Axiom: A
        - Rules: A -> A-B--B+A++AA+B-
                 B -> +A-BB--B-A++A+B
        - +: turn left 60° (counter-clockwise)
        - -: turn right 60° (clockwise)
        """
        start = start or HexPosition.origin()
        
        expanded = cls._expand_lsystem(
            axiom="A",
            rules={'A': "A-B--B+A++AA+B-", 'B': "+A-BB--B-A++A+B"},
            iterations=order
        )
        
        path = [start]
        current_pos = start
        current_dir = HexPosition.direction("E")
        
        for symbol in expanded:
            if symbol in ('A', 'B'):
                current_pos = current_pos + current_dir
                path.append(current_pos)
            elif symbol == '+':
                current_dir = current_dir.rotate(1)
            elif symbol == '-':
                current_dir = current_dir.rotate(-1)
        
        return path
    
    @classmethod
    def generate_terdragon(cls, order: int, start: HexPosition = None) -> list[HexPosition]:
        """
        Generate a Terdragon curve (triangular variant).
        
        L-system:
        - Axiom: F
        - Rules: F -> F+F-F
        - +: turn left 120° (2 hex steps)
        - -: turn right 120°
        """
        start = start or HexPosition.origin()
        
        expanded = cls._expand_lsystem(
            axiom="F",
            rules={'F': "F+F-F"},
            iterations=order
        )
        
        path = [start]
        current_pos = start
        current_dir = HexPosition.direction("E")
        
        for symbol in expanded:
            if symbol == 'F':
                current_pos = current_pos + current_dir
                path.append(current_pos)
            elif symbol == '+':
                current_dir = current_dir.rotate(2)
            elif symbol == '-':
                current_dir = current_dir.rotate(-2)
        
        return path
    
    @classmethod
    def generate_peano_hex(cls, order: int, start: HexPosition = None) -> list[HexPosition]:
        """
        Generate a hexagonal Peano curve (space-filling).
        
        L-system:
        - Axiom: XF
        - Rules: X -> XF+YF+XF-F-YF-F-XF+YF-X
                 Y -> YF-XF-YF+F+XF+F+YF-XF+Y
        """
        start = start or HexPosition.origin()
        
        expanded = cls._expand_lsystem(
            axiom="XF",
            rules={
                'X': "XF+YF+XF-F-YF-F-XF+YF-X",
                'Y': "YF-XF-YF+F+XF+F+YF-XF+Y"
            },
            iterations=order
        )
        
        path = [start]
        current_pos = start
        current_dir = HexPosition.direction("E")
        
        for symbol in expanded:
            if symbol == 'F':
                current_pos = current_pos + current_dir
                path.append(current_pos)
            elif symbol == '+':
                current_dir = current_dir.rotate(1)
            elif symbol == '-':
                current_dir = current_dir.rotate(-1)
        
        return path
    
    @staticmethod
    def calculate_bounds(hex_path: list[HexPosition]) -> tuple[int, int, int, int]:
        """Calculate bounding box: (min_q, max_q, min_r, max_r)"""
        if not hex_path:
            return (0, 0, 0, 0)
        
        qs = [h.q for h in hex_path]
        rs = [h.r for h in hex_path]
        return (min(qs), max(qs), min(rs), max(rs))
    
    @staticmethod
    def center_path(hex_path: list[HexPosition]) -> list[HexPosition]:
        """Center a path around the origin."""
        if not hex_path:
            return []
        
        min_q, max_q, min_r, max_r = GosperCurve.calculate_bounds(hex_path)
        center_q = (min_q + max_q) // 2
        center_r = (min_r + max_r) // 2
        offset = HexPosition(center_q, center_r, -center_q - center_r)
        
        return [pos - offset for pos in hex_path]
    
    @staticmethod
    def path_to_mappath(hex_path: list[HexPosition], 
                        hex_radius: float = 20.0,
                        center: MapCord = None,
                        style: StyleCSS = None) -> MapPath:
        """Convert a HexPosition path to a MapPath for rendering."""
        center = center or MapCord(400, 400)
        style = style or StyleCSS("gosper", stroke="#2196F3", stroke_width=2, fill="none")
        
        pixel_points = [hexpos.pixel(hex_radius, center) for hexpos in hex_path]
        return MapPath(pixel_points, style)
