"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_voronoi.ipynb.

# %% auto 0
__all__ = ['voronoi_seeds', 'PlateKind', 'Plate', 'mark_oceanic_plates', 'calculate_distances_from_ocean',
           'generate_plate_terrain']

# %% ../nbs/04_voronoi.ipynb 4
#data
from collections import namedtuple, defaultdict
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#math
from random import randint
import numpy as np

from fastcore.basics import patch

# %% ../nbs/04_voronoi.ipynb 6
from .primitives import  MapCord , HexPosition,  MapSize, MapRect, MapCord, MapPath ,HexGrid, HexRegion, Hex


# %% ../nbs/04_voronoi.ipynb 7
from .styles import StyleCSS,  SVGBuilder

# %% ../nbs/04_voronoi.ipynb 8
from sklearn.cluster import KMeans

# %% ../nbs/04_voronoi.ipynb 19
def voronoi_seeds(rows, cols, num_seeds, elimination_rate=0.3, max_offset=3, s=None,debug=False):
    """
    Generate evenly-spaced seeds with randomization for Voronoi diagram.
    
    Args:
        rows: Number of rows in grid
        cols: Number of columns in grid
        num_seeds: Target number of seeds (approximate)
        elimination_rate: Fraction of initial seeds to remove (0-1)
        max_offset: Maximum random offset in each direction
        seed: Random seed for reproducibility
    
    Returns:
        Array of (row, col) coordinates and corresponding 1D indexes
    """
    if s is not None:
        np.random.seed(s)
    

    # Calculate spacing to get approximately num_seeds AFTER elimination
    total_cells = rows * cols
    target_before_elimination = num_seeds / (1 - elimination_rate)
    spacing = int(np.sqrt(total_cells / target_before_elimination))
    spacing = max(1, spacing)

    
    # Create evenly spaced grid
    row_coords = np.arange(spacing//2, rows, spacing)
    col_coords = np.arange(spacing//2, cols, spacing)
    rr, cc = np.meshgrid(row_coords, col_coords)
    seeds = np.column_stack([rr.ravel(), cc.ravel()])
    
    if debug:
        print(f"Initial seeds: {len(seeds)} (spacing={spacing})")
    
    # Elimination step
    keep_mask = np.random.random(len(seeds)) > elimination_rate
    seeds = seeds[keep_mask]
    if debug:
        print(f"After elimination: {len(seeds)}")
    
    # Offset step
    offsets = np.random.uniform(-max_offset, max_offset, size=seeds.shape)
    seeds = seeds + offsets
    
    # Clip to valid range and convert to integers
    seeds[:, 0] = np.clip(seeds[:, 0], 0, rows - 1)
    seeds[:, 1] = np.clip(seeds[:, 1], 0, cols - 1)
    seeds = seeds.astype(int)
    
    # Remove duplicates
    seeds = np.unique(seeds, axis=0)
    if debug:
        print(f"Final unique seeds: {len(seeds)}")
    
    # Convert to 1D indexes
    indexes = seeds[:, 0] * cols + seeds[:, 1]
    
    return seeds, indexes




# %% ../nbs/04_voronoi.ipynb 21
class PlateKind(Enum):
    oceanic = 0        # Ocean/sea
    continental = 1    # Lakes/rivers
    island_arc = 2        # Cold, low precipitation
    mixed = 3        # Hot/cold, very low precipitation
class Plate:
    def __init__(self,region:HexRegion,symbol="â™ ï¸",direction=4):
        self.region = region
        self.symbol = symbol
        self.direction = HexPosition.directions()[direction]
        self.kind = PlateKind.oceanic
        self.oceanDistance = 0
        

    def changeDirection(self,direction):
        self.direction = HexPosition.directions()[direction]


    @property
    def hexes(self):
        return self.region.hexes

    @classmethod
    def colors(cls):
        return {
    PlateKind.oceanic: [
        "#2E5266",  # Deep ocean blue
        "#1A4B68",  # Dark blue-gray
        "#2A5674",  # Steel blue
        "#345D7E",  # Slate blue
        "#3E6888",  # Ocean blue
    ],
    PlateKind.continental: [
        "#8B7355",  # Sandy brown
        "#A08968",  # Warm brown
        "#7A6A53",  # Earth brown
        "#9B8B6F",  # Tan brown
        "#6B5D47",  # Dark earth
    ],
    PlateKind.mixed: [
        "#5C6F7A",  # Blue-gray
        "#6A7B85",  # Slate gray
        "#7A8C95",  # Light slate
        "#4D5E69",  # Dark slate
        "#556673",  # Medium slate
    ],
    PlateKind.island_arc: [
    "#6B8E7F",  # Volcanic green-gray
    "#7A9B8C",  # Sage green
    "#5A7A6B",  # Dark moss
    "#8AA599",  # Light seafoam
    "#4F6B5E",  # Deep forest-gray
]

}
    def encode(self) -> str:
        dir_idx = HexPosition.directions().index(self.direction)
        hexes_str = ','.join(str(h) for h in sorted(self.region.hexes))
        return f"{self.symbol}\t{self.kind.value}\t{dir_idx}\t{hexes_str}"

    @classmethod
    def decode(cls, s: str, hex_grid: HexGrid) -> 'Plate':
        parts = s.split('\t')
        symbol = parts[0]
        kind = PlateKind(int(parts[1]))
        direction = int(parts[2])
        hexes = set(int(h) for h in parts[3].split(','))
        region = HexRegion(hexes, hex_grid=hex_grid)
        plate = cls(region, symbol=symbol, direction=direction)
        plate.kind = kind
        return plate



    @classmethod
    def icon(cls, index:int,plates:['Plate'])->str:
        for plate in plates:
            if index in plate.region.hexes:
                return plate.symbol
        return str(index)

    @classmethod
    def voronoi(cls,grid:HexGrid,amount:int=10,sym=["â™£ï¸","â™¦ï¸","â™¥ï¸","â™ ï¸"])->['Plate']:

        seeds = voronoi_seeds(grid.nRows,grid.nCols,amount)[1]

        plates = []
        claimed = set()
        for i, seed in enumerate(seeds):
            icon = str(i)
            if i < len(sym):
                icon = sym[i]
            reg = HexRegion(set([seed]), hex_grid = grid ) # Set of hex indices
            plate = Plate(reg,symbol=icon)
            claimed.add(seed)
            plates.append(plate)

        total = grid.nRows * grid.nCols 

        while len(claimed) < total:
            for plate in plates:
                reg = plate.region.outside()
                adds =[x for x in reg.hexes if x not in claimed]
                for add in adds:
                    claimed.add(add)
                    plate.hexes.add(add)
        return plates

# %% ../nbs/04_voronoi.ipynb 28
def mark_oceanic_plates(plates, ocean_fraction=0.4, seed=None):
    """
    Randomly mark some plates as oceanic.
    
    Args:
        plates: List of Plate objects
        ocean_fraction: Fraction of plates to mark as oceanic (0-1)
        seed: Random seed for reproducibility
    
    Returns:
        Modified plates list
    """
    if seed is not None:
        np.random.seed(seed)
    
    num_ocean = int(len(plates) * ocean_fraction)
    ocean_indices = np.random.choice(len(plates), size=num_ocean, replace=False)
    
    for i in ocean_indices:
        plates[i].kind = PlateKind.oceanic
    
    # Mark the rest as continental
    for i, plate in enumerate(plates):
        if i not in ocean_indices:
            plate.kind = PlateKind.continental
    
    return plates




# %% ../nbs/04_voronoi.ipynb 29
def calculate_distances_from_ocean(plates, grid):
    """
    Calculate distance from each plate to nearest oceanic plate centroid.
    """
  
    # Get oceanic plate centroids
    ocean_centroids = []
    for plate in plates:
        if plate.kind == PlateKind.oceanic:
            centroid_idx = plate.region.centroid_hex()
            centroid_pos = grid.index_to_hexposition(centroid_idx)
            ocean_centroids.append(centroid_pos)
    
    if not ocean_centroids:
        print("Warning: No oceanic plates found!")
        return 

    for plate in plates:
        if plate.kind != PlateKind.oceanic:
            centroid_idx = plate.region.centroid_hex()
            hex_pos = grid.index_to_hexposition(centroid_idx)
            plate.oceanDistance = min(hex_pos.distance(ocean_pos) for ocean_pos in ocean_centroids)
   


# %% ../nbs/04_voronoi.ipynb 32
def _merge_plates(voronoi_plates: List['Plate'], 
                 hex_grid: 'HexGrid',
                 target_count: int = 3,
                 debug: bool = False) -> List['Plate']:
    """Merge small voronoi plates into larger tectonic plates using k-means."""
    
    # Separate by kind
    oceanic = [p for p in voronoi_plates if p.kind == PlateKind.oceanic]
    continental = [p for p in voronoi_plates if p.kind == PlateKind.continental]
    
    if debug:
        print(f"\n=== MERGING PLATES ===")
        print(f"Input: {len(oceanic)} oceanic + {len(continental)} continental = {len(voronoi_plates)} total")
        print(f"Target: {target_count} plates")
    
    # Decide split between oceanic and continental
    total = len(voronoi_plates)
    n_oceanic = max(1, round(target_count * len(oceanic) / total))
    n_continental = max(1, target_count - n_oceanic)
    
    if debug:
        print(f"Splitting: {n_oceanic} oceanic + {n_continental} continental")
    
    merged = []
    
    def cluster_plates(plates, k):
        if len(plates) <= k:
            return [[p] for p in plates]
        
        # Get centroids as (x, y) coordinates
        centroids = []
        for plate in plates:
            center_idx = plate.region.centroid_hex()
            center_hex = hex_grid.hexes[center_idx]
            centroids.append((center_hex.center.x, center_hex.center.y))
        
        centroids = np.array(centroids)
        
        kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
        labels = kmeans.fit_predict(centroids)
        
        clusters = defaultdict(list)
        for plate, label in zip(plates, labels):
            clusters[label].append(plate)
        
        return list(clusters.values())
    
    # Cluster and merge oceanic plates
    if oceanic:
        oceanic_clusters = cluster_plates(oceanic, n_oceanic)
        for cluster in oceanic_clusters:
            all_hexes = set()
            for plate in cluster:
                all_hexes.update(plate.hexes)
            
            region = HexRegion(hexes=all_hexes, hex_grid=hex_grid)
            merged_plate = Plate(region, symbol="ðŸŒŠ")
            merged_plate.kind = PlateKind.oceanic
            merged.append(merged_plate)
    
    # Cluster and merge continental plates
    if continental:
        continental_clusters = cluster_plates(continental, n_continental)
        for cluster in continental_clusters:
            all_hexes = set()
            for plate in cluster:
                all_hexes.update(plate.hexes)
            
            region = HexRegion(hexes=all_hexes, hex_grid=hex_grid)
            merged_plate = Plate(region, symbol="ðŸ”ï¸")
            merged_plate.kind = PlateKind.continental
            merged.append(merged_plate)
    
    if debug:
        print(f"\nOutput: {len(merged)} merged plates")
        for i, plate in enumerate(merged):
            print(f"  Plate {i} ({plate.kind.name}): {len(plate.hexes)} hexes")
    
    return merged




# %% ../nbs/04_voronoi.ipynb 35
from .terrain import Terrain

# %% ../nbs/04_voronoi.ipynb 36
def generate_plate_terrain(bounds, radius=20, num_plates=10, final_plates=4, slope=20,variation=40, ocean_fraction=0.4, seed=None):
    """
    Generate terrain based on tectonic plates using Voronoi regions.
    
    Args:
        bounds: MapRect defining the terrain bounds
        radius: Hex radius
        num_plates: Number of tectonic plates
        ocean_fraction: Fraction of plates that are oceanic
        seed: Random seed for reproducibility
    
    Returns:
        Terrain object with plate-based elevations
    """
    if seed is not None:
        np.random.seed(seed)
    
    # Create terrain and grid
    terrain = Terrain(bounds, radius=radius)
    grid = terrain.hexGrid
    
    # Generate Voronoi plates
    plates = Plate.voronoi(grid, num_plates)
    
    # Mark some as oceanic
    plates = mark_oceanic_plates(plates, ocean_fraction=ocean_fraction, seed=seed)
    
    # Calculate distances from ocean
    calculate_distances_from_ocean(plates, grid)
    
    # Generate elevations based on plate properties
    elevations = np.zeros(len(grid.hexes))
    
    for plate in plates:
        if plate.kind == PlateKind.oceanic:
            # Ocean plates are low elevation (negative)
            base_elevation = -100
            variation = 30
        else:
            # Continental plates elevation based on distance from ocean
            # Farther from ocean = higher elevation
            base_elevation = 50 + (plate.oceanDistance * slope)
            
        
        # Add random variation to each hex in the plate
        for hex_idx in plate.hexes:
            elevation = base_elevation + np.random.uniform(-variation, variation)
            elevations[hex_idx] = elevation
    
    # Smooth the elevations at plate boundaries
    smoothed = elevations.copy()
    for i in range(len(grid.hexes)):
        neighbors = grid.neighborsOf(i)
        if neighbors:
            # Average with neighbors for smoothing
            neighbor_vals = [elevations[n] for n in neighbors if n < len(elevations)]
            if neighbor_vals:
                smoothed[i] = 0.7 * elevations[i] + 0.3 * np.mean(neighbor_vals)
    
    terrain.elevations = smoothed
    terrain.colorMap()
    if final_plates is not None:
        plates = _merge_plates(plates,grid, target_count=final_plates)
    
    return terrain, plates 



Terrain.fromSeeds = generate_plate_terrain
