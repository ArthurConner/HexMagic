"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_voronoi.ipynb.

# %% auto #0
__all__ = ['voronoi_seeds', 'PlateKind', 'Plate', 'mark_oceanic_plates', 'mark_oceanic_by_sides', 'generate_plate_terrain']

# %% ../nbs/04_voronoi.ipynb #5e918f30
#data
from collections import namedtuple, defaultdict
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#math
import random
from random import randint
import numpy as np

from fastcore.basics import patch

# %% ../nbs/04_voronoi.ipynb #0318af9c
from .primitives import  MapCord , HexPosition,  MapSize, MapRect, MapCord, MapPath ,HexGrid, HexRegion, Hex
from .primitives import MapRect, HexGrid


# %% ../nbs/04_voronoi.ipynb #612b0872
from .styles import StyleCSS,  SVGBuilder

# %% ../nbs/04_voronoi.ipynb #517d274f
from sklearn.cluster import KMeans

# %% ../nbs/04_voronoi.ipynb #a915b993
def voronoi_seeds(rows, cols, num_seeds, elimination_rate=0.3, max_offset=3, s=None,debug=False):
    """
    Generate evenly-spaced seeds with randomization for Voronoi diagram.
    
    Args:
        rows: Number of rows in grid
        cols: Number of columns in grid
        num_seeds: Target number of seeds (approximate)
        elimination_rate: Fraction of initial seeds to remove (0-1)
        max_offset: Maximum random offset in each direction
        seed: Random seed for reproducibility
    
    Returns:
        Array of (row, col) coordinates and corresponding 1D indexes
    """
    if s is not None:
        np.random.seed(s)
    

    # Calculate spacing to get approximately num_seeds AFTER elimination
    total_cells = rows * cols
    target_before_elimination = num_seeds / (1 - elimination_rate)
    spacing = int(np.sqrt(total_cells / target_before_elimination))
    spacing = max(1, spacing)

    
    # Create evenly spaced grid
    row_coords = np.arange(spacing//2, rows, spacing)
    col_coords = np.arange(spacing//2, cols, spacing)
    rr, cc = np.meshgrid(row_coords, col_coords)
    seeds = np.column_stack([rr.ravel(), cc.ravel()])
    
    if debug:
        print(f"Initial seeds: {len(seeds)} (spacing={spacing})")
    
    # Elimination step
    keep_mask = np.random.random(len(seeds)) > elimination_rate
    seeds = seeds[keep_mask]
    if debug:
        print(f"After elimination: {len(seeds)}")
    
    # Offset step
    offsets = np.random.uniform(-max_offset, max_offset, size=seeds.shape)
    seeds = seeds + offsets
    
    # Clip to valid range and convert to integers
    seeds[:, 0] = np.clip(seeds[:, 0], 0, rows - 1)
    seeds[:, 1] = np.clip(seeds[:, 1], 0, cols - 1)
    seeds = seeds.astype(int)
    
    # Remove duplicates
    seeds = np.unique(seeds, axis=0)
    if debug:
        print(f"Final unique seeds: {len(seeds)}")
    
    # Convert to 1D indexes
    indexes = seeds[:, 0] * cols + seeds[:, 1]
    
    return seeds, indexes




# %% ../nbs/04_voronoi.ipynb #eec15a39
class PlateKind(Enum):
    oceanic = 0        # Ocean/sea
    continental = 1    # Lakes/rivers
    island_arc = 2        # Cold, low precipitation
    mixed = 3        # Hot/cold, very low precipitation

# %% ../nbs/04_voronoi.ipynb #d7fb48a0
class Plate:
    def __init__(self,region:HexRegion,symbol="â™ ï¸",direction=4):
        self.region = region
        self.symbol = symbol
        self.direction = HexPosition.directions()[direction]
        self.kind = PlateKind.oceanic
        self.oceanDistance = 0
        

    def changeDirection(self,direction):
        self.direction = HexPosition.directions()[direction]


    @property
    def hexes(self):
        return self.region.hexes

    @classmethod
    def colors(cls):
        return {
    PlateKind.oceanic: [
        "#2E5266",  # Deep ocean blue
        "#1A4B68",  # Dark blue-gray
        "#2A5674",  # Steel blue
        "#345D7E",  # Slate blue
        "#3E6888",  # Ocean blue
    ],
    PlateKind.continental: [
        "#8B7355",  # Sandy brown
        "#A08968",  # Warm brown
        "#7A6A53",  # Earth brown
        "#9B8B6F",  # Tan brown
        "#6B5D47",  # Dark earth
    ],
    PlateKind.mixed: [
        "#5C6F7A",  # Blue-gray
        "#6A7B85",  # Slate gray
        "#7A8C95",  # Light slate
        "#4D5E69",  # Dark slate
        "#556673",  # Medium slate
    ],
    PlateKind.island_arc: [
    "#6B8E7F",  # Volcanic green-gray
    "#7A9B8C",  # Sage green
    "#5A7A6B",  # Dark moss
    "#8AA599",  # Light seafoam
    "#4F6B5E",  # Deep forest-gray
]

}
    def encode(self) -> str:
        dir_idx = HexPosition.directions().index(self.direction)
        hexes_str = ','.join(str(h) for h in sorted(self.region.hexes))
        return f"{self.symbol}\t{self.kind.value}\t{dir_idx}\t{hexes_str}"

    @classmethod
    def decode(cls, s: str, hex_grid: HexGrid) -> 'Plate':
        parts = s.split('\t')
        symbol = parts[0]
        kind = PlateKind(int(parts[1]))
        direction = int(parts[2])
        hexes = set(int(h) for h in parts[3].split(','))
        region = HexRegion(hexes, hex_grid=hex_grid)
        plate = cls(region, symbol=symbol, direction=direction)
        plate.kind = kind
        return plate



    @classmethod
    def icon(cls, index:int,plates:['Plate'])->str:
        for plate in plates:
            if index in plate.region.hexes:
                return plate.symbol
        return str(index)

    @classmethod
    def voronoi(cls,grid:HexGrid,amount:int=10,sym=["â™£ï¸","â™¦ï¸","â™¥ï¸","â™ ï¸"])->['Plate']:

        seeds = voronoi_seeds(grid.nRows,grid.nCols,amount)[1]

        plates = []
        claimed = set()
        for i, seed in enumerate(seeds):
            icon = str(i)
            if i < len(sym):
                icon = sym[i]
            reg = HexRegion(set([seed]), hexGrid = grid ) # Set of hex indices
            plate = Plate(reg,symbol=icon)
            claimed.add(seed)
            plates.append(plate)

        total = grid.nRows * grid.nCols 

        while len(claimed) < total:
            for plate in plates:
                reg = plate.region.outside()
                adds =[x for x in reg.hexes if x not in claimed]
                for add in adds:
                    claimed.add(add)
                    plate.hexes.add(add)
        return plates

    @classmethod
    def boundaries(cls: type, plates: list['Plate']) -> set[HexPosition]:
        """Find hexes at edges between adjacent plates."""
        boundary = set()
        plate_map = {}  # position -> plate_id
        
        for i, plate in enumerate(plates):
            for p in plate.positions():
                plate_map[p] = i
        
        for plate_id, plate in enumerate(plates):
            for p in plate.positions():
                for d in range(6):
                    neighbor = p.neighbor(d)
                    neighbor_plate = plate_map.get(neighbor)
                    if neighbor_plate is not None and neighbor_plate != plate_id:
                        boundary.add(p)
                        break
        return boundary

    @classmethod
    def merge_plates(cls, voronoi_plates: List['Plate'], 
                 hex_grid: 'HexGrid',
                 target_count: int = 3,
                 debug: bool = False) -> List['Plate']:
        """Merge small voronoi plates into larger tectonic plates using k-means."""
        
        # Separate by kind
        oceanic = [p for p in voronoi_plates if p.kind == PlateKind.oceanic]
        continental = [p for p in voronoi_plates if p.kind == PlateKind.continental]
        
        if debug:
            print(f"\n=== MERGING PLATES ===")
            print(f"Input: {len(oceanic)} oceanic + {len(continental)} continental = {len(voronoi_plates)} total")
            print(f"Target: {target_count} plates")
        
        # Decide split between oceanic and continental
        total = len(voronoi_plates)
        n_oceanic = max(1, round(target_count * len(oceanic) / total))
        n_continental = max(1, target_count - n_oceanic)
        
        if debug:
            print(f"Splitting: {n_oceanic} oceanic + {n_continental} continental")
        
        merged = []
        
        def cluster_plates(plates, k):
            if len(plates) <= k:
                return [[p] for p in plates]
            
            # Get centroids as (x, y) coordinates
            centroids = []
            for plate in plates:
                center_idx = plate.region.centroid_hex()
                center_hex = hex_grid.hexes[center_idx]
                centroids.append((center_hex.center.x, center_hex.center.y))
            
            centroids = np.array(centroids)
            
            kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
            labels = kmeans.fit_predict(centroids)
            
            clusters = defaultdict(list)
            for plate, label in zip(plates, labels):
                clusters[label].append(plate)
            
            return list(clusters.values())
        
        # Cluster and merge oceanic plates
        if oceanic:
            oceanic_clusters = cluster_plates(oceanic, n_oceanic)
            for cluster in oceanic_clusters:
                all_hexes = set()
                for plate in cluster:
                    all_hexes.update(plate.hexes)
                
                region = HexRegion(hexes=all_hexes, hexGrid=hex_grid)
                merged_plate = Plate(region, symbol="ðŸŒŠ")
                merged_plate.kind = PlateKind.oceanic
                merged.append(merged_plate)
        
        # Cluster and merge continental plates
        if continental:
            continental_clusters = cluster_plates(continental, n_continental)
            for cluster in continental_clusters:
                all_hexes = set()
                for plate in cluster:
                    all_hexes.update(plate.hexes)
                
                region = HexRegion(hexes=all_hexes, hexGrid=hex_grid)
                merged_plate = Plate(region, symbol="ðŸ”ï¸")
                merged_plate.kind = PlateKind.continental
                merged.append(merged_plate)
        
        if debug:
            print(f"\nOutput: {len(merged)} merged plates")
            for i, plate in enumerate(merged):
                print(f"  Plate {i} ({plate.kind.name}): {len(plate.hexes)} hexes")
        
        return merged

# %% ../nbs/04_voronoi.ipynb #b425d4fe
@patch
def positions(self: Plate) -> set[HexPosition]:
    """Get all hex positions in this plate."""
    return self.region.to_positions()

@patch
def centroid_position(self: Plate) -> HexPosition:
    """Get plate centroid as HexPosition."""
    return self.region.centroid_position()

@patch
def subdivide(self: Plate, depth: int = 2, min_size: int = 10, 
              seeds_per_level: int = 3) -> list['Plate']:
    """Recursively subdivide this plate using Voronoi."""
    positions = self.positions()
    
    if depth <= 0 or len(positions) < min_size:
        return [self]
    
    pos_list = list(positions)
    n_seeds = min(seeds_per_level, len(pos_list))
    seeds = random.sample(pos_list, n_seeds)
    
    # Assign each position to nearest seed
    regions: dict[int, set[HexPosition]] = {}
    for p in positions:
        closest = min(range(len(seeds)), key=lambda i: p.distance(seeds[i]))
        regions[closest] = regions.get(closest, set())
        regions[closest].add(p)
    
    # Convert back to index-based HexRegions and create sub-plates
    sub_plates = []
    for region_positions in regions.values():
        indices = {self.region.hexGrid.hexposition_to_index(p) for p in region_positions}
        indices = {i for i in indices if i >= 0}  # Filter invalid
        if indices:
            sub_region = HexRegion(indices, hexGrid=self.region.hexGrid)
            sub_plate = Plate(sub_region, symbol=self.symbol)
            sub_plate.kind = self.kind
            
            # Recurse
            if depth > 1 and len(indices) >= min_size:
                sub_plates.extend(sub_plate.subdivide(depth - 1, min_size, seeds_per_level))
            else:
                sub_plates.append(sub_plate)
    
    return sub_plates




# %% ../nbs/04_voronoi.ipynb #32dd0b44
@patch
def plateOverlay(grid:HexGrid,plates:['Plate'],palette="hls",f=None,smooth=False):
    
    styles = StyleCSS.seaborn(palette, len(plates))

    for i, plate in enumerate(plates):
        plateStyle = styles[i]
        grid.builder.add_style(plateStyle)
        for k in plate.hexes:
            grid.hexes[k].style = plateStyle

    return grid.styleLayer(f=f,smooth=smooth)

# %% ../nbs/04_voronoi.ipynb #249a7b61
def mark_oceanic_plates(plates, ocean_fraction=0.4, seed=None):
    """
    Randomly mark some plates as oceanic.
    
    Args:
        plates: List of Plate objects
        ocean_fraction: Fraction of plates to mark as oceanic (0-1)
        seed: Random seed for reproducibility
    
    Returns:
        Modified plates list
    """
    if seed is not None:
        np.random.seed(seed)
    
    num_ocean = int(len(plates) * ocean_fraction)
    ocean_indices = np.random.choice(len(plates), size=num_ocean, replace=False)
    
    for i in ocean_indices:
        plates[i].kind = PlateKind.oceanic
    
    # Mark the rest as continental
    for i, plate in enumerate(plates):
        if i not in ocean_indices:
            plate.kind = PlateKind.continental
    
    return plates




# %% ../nbs/04_voronoi.ipynb #2e65213a
def mark_oceanic_by_sides(plates, grid, factor=1.5, oceanic_sides=['N', 'E', 'S', 'W']):
    """
    Mark plates as oceanic if they touch specified map edges.
    
    Args:
        plates: List of Plate objects
        grid: HexGrid
        bounds: MapRect with min_x, max_x, min_y, max_y
        oceanic_sides: List of sides - 'N', 'E', 'S', 'W'
                      e.g. ['N','E','S'] for a peninsula open to the west
    """
    # Build a set of edge hex indices for each side
    edge_hexes = set()
    margin = grid.radius * factor  # tolerance for edge detection
    bounds = grid.bounds
    max_y = bounds.maxY() - margin
    min_y = bounds.minY() + margin
    max_x = bounds.maxX() - margin
    min_x = bounds.minX() + margin
  
    for i, hx in enumerate(grid.hexes):
        
        x = hx.center.x
        y = hx.center.y
        
        
        if 'N' in oceanic_sides and y <= min_y :
            edge_hexes.add(i)
        if 'S' in oceanic_sides and y >= max_y:
            edge_hexes.add(i)
        if 'E' in oceanic_sides and x >= max_x:
            edge_hexes.add(i)
        if 'W' in oceanic_sides and x <= min_x:
            edge_hexes.add(i)
    
    # Mark plates that intersect with edge hexes as oceanic
    for plate in plates:
        plate_hexes = set(plate.hexes)
        if plate_hexes & edge_hexes:  # intersection
            plate.kind = PlateKind.oceanic

    
    return plates


# %% ../nbs/04_voronoi.ipynb #a4519b93
@patch
def calculate_distances_from_ocean(grid:HexGrid,plates:[Plate]):
    """
    Calculate distance from each plate to nearest oceanic plate centroid.
    """
  
    # Get oceanic plate centroids
    ocean_centroids = []
    for plate in plates:
        if plate.kind == PlateKind.oceanic:
            centroid_idx = plate.region.centroid_hex()
            centroid_pos = grid.index_to_hexposition(centroid_idx)
            ocean_centroids.append(centroid_pos)
    
    if not ocean_centroids:
        print("Warning: No oceanic plates found!")
        return 

    for plate in plates:
        if plate.kind != PlateKind.oceanic:
            centroid_idx = plate.region.centroid_hex()
            hex_pos = grid.index_to_hexposition(centroid_idx)
            plate.oceanDistance = min(hex_pos.distance(ocean_pos) for ocean_pos in ocean_centroids)
   


# %% ../nbs/04_voronoi.ipynb #33445248
from .terrain import Terrain

# %% ../nbs/04_voronoi.ipynb #6a9a3548
@patch
def adjust_by_distance(terrain: Terrain, plate: Plate,
                       from_pos: HexPosition = None,
                       height_func=None) -> None:
    """
    Adjust terrain height for hexes in a plate based on distance from a reference point.
    
    Args:
        terrain: Terrain object with elevations
        plate: Single plate to adjust
        from_pos: Reference position (defaults to plate centroid)
        height_func: fn(base_height, distance) -> new_height
                    Default creates a peak at center that falls off with distance
    """
    grid = plate.region.hexGrid
    
    if from_pos is None:
        from_pos = plate.centroid_position()
    
    if height_func is None:
        # Default: peak at center, falls off linearly
        height_func = lambda base, dist: base + max(0, 8 - dist * 1.5)
    
    for idx in plate.hexes:
        if idx < len(terrain.elevations):
            hex_pos = grid.index_to_hexposition(idx)
            dist = hex_pos.distance(from_pos)
            terrain.elevations[idx] = height_func(terrain.elevations[idx], dist)

# %% ../nbs/04_voronoi.ipynb #96586ed1
def _elevation_crater(grid, plates, params, scale):
    """Ring mountains around central depressions (calderas)."""
    elevations = np.zeros(len(grid.hexes))
    
    for plate in plates:
        centroid = plate.centroid_position()
        
        if plate.kind == PlateKind.oceanic:
            base, ring_radius, rim_height = -50 * scale, 2, 30
        else:
            base, ring_radius, rim_height = 40 * scale, 3, params['peak_height'] * 0.6
        
        for idx in plate.hexes:
            pos = grid.index_to_hexposition(idx)
            dist = pos.distance(centroid)
            
            # Ring shape: peak at ring_radius, lower inside and outside
            ring_effect = rim_height * max(0, 1 - abs(dist - ring_radius) / 2) * scale
            # Depression in center
            if dist < ring_radius * 0.5:
                ring_effect = -20 * scale
            
            elevations[idx] = base + ring_effect + np.random.uniform(-params['variation']*0.3, params['variation']*0.3)
    
    return elevations

# %% ../nbs/04_voronoi.ipynb #8f84b70b
def _elevation_rift(grid, plates, boundaries, params, scale):
    """Valleys at boundaries (divergent plates), plateaus elsewhere."""
    elevations = np.zeros(len(grid.hexes))
    
    plate_map = {idx: p for p in plates for idx in p.hexes}
    
    for i in range(len(grid.hexes)):
        plate = plate_map.get(i)
        if plate is None:
            continue
        
        pos = grid.index_to_hexposition(i)
        dist_to_boundary = min((pos.distance(b) for b in boundaries), default=10)
        
        if plate.kind == PlateKind.oceanic:
            base = -60 * scale
        else:
            base = 60 * scale
            # Valley AT boundary, rising to plateaus
            rift_depth = max(0, 3 - dist_to_boundary) * 40 * scale
            base -= rift_depth
        
        elevations[i] = base + np.random.uniform(-params['variation'], params['variation']) * scale * 0.3
    
    return elevations


# %% ../nbs/04_voronoi.ipynb #c4bae956
def generate_plate_terrain(
    bounds, 
    radius=20,
    # Plate generation
    num_plates=10,
    subdivisions=3,
    min_subplate_size=3,
    # Ocean configuration  
    ocean_fraction=0.4,
    oceanic_sides=[],
    edge_factor=1.5,
    # Terrain character
    age='middle',  # 'young', 'middle', 'old'
    formation_type='ocean_distance',  # 'ridge', 'volcanic', 'rolling'
    # Fine-tuning
    elevation_scale=1.0,
    seed=None
):
    """
    Generate terrain based on tectonic plates.
    
    Args:
        bounds: MapRect defining terrain bounds
        radius: Hex radius
        num_plates: Initial number of large plates (for coastlines)
        subdivisions: Depth of plate subdivision for detail
        min_subplate_size: Minimum hex count per subplate
        ocean_fraction: Fraction of initial plates marked oceanic
        oceanic_sides: List of sides ['N','E','S','W'] that are ocean
        edge_factor: How far from edge to mark as oceanic
        age: 'young' (sharp), 'middle', 'old' (eroded)
        formation_type: 'ocean_distance', 'ridge', 'volcanic', 'rolling'
        elevation_scale: Multiplier for all elevations
        seed: Random seed
    
    Returns:
        (Terrain, plates) tuple
    """
    if seed is not None:
        np.random.seed(seed)
        random.seed(seed)
    
    # Age presets
    age_params = {
        'young':  {'slope': 30, 'variation': 50, 'smoothing': 1, 'peak_height': 200},
        'middle': {'slope': 20, 'variation': 40, 'smoothing': 3, 'peak_height': 150},
        'old':    {'slope': 10, 'variation': 20, 'smoothing': 6, 'peak_height': 80},
    }
    params = age_params.get(age, age_params['middle'])
    
    # Create terrain and grid
    terrain = Terrain(bounds, radius=radius)
    grid = terrain.hexGrid
    
    # Phase 1: Generate coarse plates for coastlines
    coarse_plates = Plate.voronoi(grid, num_plates)
    
    # Mark oceanic plates
    coarse_plates = mark_oceanic_plates(coarse_plates, ocean_fraction=ocean_fraction, seed=seed)
    if oceanic_sides:
        mark_oceanic_by_sides(coarse_plates, grid, factor=edge_factor, oceanic_sides=oceanic_sides)
    
    # Phase 2: Subdivide for detail (preserving plate kind)
    plates = []
    for plate in coarse_plates:
        sub = plate.subdivide(depth=subdivisions, min_size=min_subplate_size)
        plates.extend(sub)
    
    # Calculate ocean distances
    grid.calculate_distances_from_ocean(plates)
    
    # Get boundaries for ridge-based terrain
    boundaries = Plate.boundaries(plates)
    
    # Initialize elevations
    elevations = np.zeros(len(grid.hexes))
    
    # Generate elevations based on formation type
    if formation_type == 'ocean_distance':
        elevations = _elevation_ocean_distance(grid, plates, params, elevation_scale)
    elif formation_type == 'ridge':
        elevations = _elevation_ridge(grid, plates, boundaries, params, elevation_scale)
    elif formation_type == 'volcanic':
        elevations = _elevation_volcanic(grid, plates, params, elevation_scale)
    elif formation_type == 'rolling':
        elevations = _elevation_rolling(grid, plates, params, elevation_scale)
    elif formation_type == 'rift':
        elevations = _elevation_rift(grid, plates, params, elevation_scale)
    elif formation_type == 'crater':
        elevations = _elevation_crater(grid, plates, params, elevation_scale)
    else:
        raise ValueError(f"Unknown formation_type: {formation_type}")
    
    # Apply smoothing based on age
    for _ in range(params['smoothing']):
        elevations = _smooth_elevations(grid, elevations)
    
    terrain.elevations = elevations
    terrain.colorMap()
    
    return terrain, plates


def _elevation_ocean_distance(grid, plates, params, scale):
    """Original approach: elevation based on distance from ocean."""
    elevations = np.zeros(len(grid.hexes))
    
    for plate in plates:
        if plate.kind == PlateKind.oceanic:
            base = -100 * scale
            var = params['variation'] * 0.5
        else:
            base = (50 + plate.oceanDistance * params['slope']) * scale
            var = params['variation']
        
        for idx in plate.hexes:
            elevations[idx] = base + np.random.uniform(-var, var) * scale
    
    return elevations


def _elevation_ridge(grid, plates, boundaries, params, scale):
    """Mountains form at plate boundaries."""
    elevations = np.zeros(len(grid.hexes))
    
    # Build plate lookup
    plate_map = {}
    for plate in plates:
        for idx in plate.hexes:
            plate_map[idx] = plate
    
    for i, hx in enumerate(grid.hexes):
        plate = plate_map.get(i)
        if plate is None:
            continue
        
        pos = grid.index_to_hexposition(i)
        
        # Distance to nearest boundary
        if boundaries:
            dist_to_boundary = min(pos.distance(b) for b in boundaries)
        else:
            dist_to_boundary = 10
        
        if plate.kind == PlateKind.oceanic:
            # Ocean: slight trench near boundaries
            base = -80 * scale
            boundary_effect = -max(0, 2 - dist_to_boundary) * 10 * scale
        else:
            # Continental: ridges at boundaries
            base = 30 * scale
            ridge_height = max(0, 4 - dist_to_boundary) * params['peak_height'] / 4 * scale
            boundary_effect = ridge_height
        
        var = params['variation'] * 0.5
        elevations[i] = base + boundary_effect + np.random.uniform(-var, var) * scale
    
    return elevations


def _elevation_volcanic(grid, plates, params, scale):
    """Peaks at plate centroids (volcanic islands, mountain cores)."""
    elevations = np.zeros(len(grid.hexes))
    
    for plate in plates:
        centroid = plate.centroid_position()
        
        if plate.kind == PlateKind.oceanic:
            base = -60 * scale
            peak = params['peak_height'] * 0.3 * scale  # Underwater volcanoes
        else:
            base = 40 * scale
            peak = params['peak_height'] * scale
        
        for idx in plate.hexes:
            pos = grid.index_to_hexposition(idx)
            dist = pos.distance(centroid)
            
            # Peak at center, falls off
            height = max(0, peak - dist * params['slope'])
            var = params['variation'] * 0.3
            elevations[idx] = base + height + np.random.uniform(-var, var) * scale
    
    return elevations


def _elevation_rolling(grid, plates, params, scale):
    """Gentle rolling terrain with minimal features."""
    elevations = np.zeros(len(grid.hexes))
    
    for plate in plates:
        if plate.kind == PlateKind.oceanic:
            base = -30 * scale
        else:
            base = 20 + plate.oceanDistance * params['slope'] * 0.3
            base *= scale
        
        var = params['variation'] * 0.7
        for idx in plate.hexes:
            elevations[idx] = base + np.random.uniform(-var, var) * scale
    
    return elevations


def _smooth_elevations(grid, elevations):
    """Single smoothing pass averaging with neighbors."""
    smoothed = elevations.copy()
    for i in range(len(grid.hexes)):
        neighbors = grid.neighborsOf(i)
        if neighbors:
            neighbor_vals = [elevations[n] for n in neighbors if n < len(elevations)]
            if neighbor_vals:
                smoothed[i] = 0.7 * elevations[i] + 0.3 * np.mean(neighbor_vals)
    return smoothed


Terrain.fromSeeds = generate_plate_terrain

