# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_weather.ipynb.

# %% auto #0
__all__ = ['WeatherColor']

# %% ../nbs/06_weather.ipynb #d3dd5cf1
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

#custom
import inspect
import copy
import colorsys
from importlib import resources

from .styles import StyleCSS, SVGBuilder, SVGLayer, SVGPatternLoader, preview, app, StyleDemo, LayerAnimation
from .primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexWrapper, HexPosition, hexBackground, HexRegion, windy_edge,unique_windy_edge
from .terrain import  TerraDemo, Terrain, GeoBounds, ClimatePreset
from .terrainpatterns import TerrainPatterns
#from HexMagic.river import River, SoilSystem, ErosionModel

# %% ../nbs/06_weather.ipynb #f6041f38
from .terrainpatterns import TerrainPatterns

# %% ../nbs/06_weather.ipynb #96feb0e5
#from HexMagic.river import River, RiverDemo

# %% ../nbs/06_weather.ipynb #c8f8bc45
import math
from collections import deque

# %% ../nbs/06_weather.ipynb #2585598c
import orographic_precipitation as op



# %% ../nbs/06_weather.ipynb #88bcbd26
@patch
def _compute_hex_coordinates(self: Terrain):
    """Compute lat/lon for each hex center."""
    if self.geo is None:
        return
    
    grid = self.hexGrid
    
    # Store lat/lon for each hex
    self.fields['latitude'] = np.zeros(len(self.elevations))
    self.fields['longitude'] = np.zeros(len(self.elevations))
    
    for idx in range(len(self.elevations)):
        row = idx // grid.nCols
        col = idx % grid.nCols
        
        # Normalize to [0, 1]
        row_norm = row / (grid.nRows - 1) if grid.nRows > 1 else 0.5
        col_norm = col / (grid.nCols - 1) if grid.nCols > 1 else 0.5
        
        # Map to geographic coordinates
        # Note: row 0 = top = max latitude
        self.fields['latitude'][idx] = self.geo.lat_max - row_norm * (self.geo.lat_max - self.geo.lat_min)
        self.fields['longitude'][idx] = self.geo.lon_min + col_norm * (self.geo.lon_max - self.geo.lon_min)

# %% ../nbs/06_weather.ipynb #5aa6f966
@patch
def grid_resolution_meters(self: Terrain):
    """Calculate dx, dy in meters for the grid."""
    if self.geo is None:
        return None, None
    
    # Meters per degree at center latitude
    lat_center = (self.geo.lat_min + self.geo.lat_max) / 2
    lat_rad = math.radians(lat_center)
    
    meters_per_lat = 111132.92  # ~constant
    meters_per_lon = 111132.92 * math.cos(lat_rad)
    
    # Resolution per grid cell
    lat_span = self.geo.lat_max - self.geo.lat_min
    lon_span = self.geo.lon_max - self.geo.lon_min
    
    dy = (lat_span / self.hexGrid.nRows) * meters_per_lat
    dx = (lon_span / self.hexGrid.nCols) * meters_per_lon
    
    return dx, dy



# %% ../nbs/06_weather.ipynb #c50c61ff
@patch
def compute_precipitation_sb(self: Terrain,
                              wind_speed=15.0,
                              wind_dir=270.0,
                              precip_base=0.3,
                              # Atmospheric parameters with typical values
                              nm=0.005,         # moist stability frequency [1/s]
                              hw=2500.0,        # water vapor scale height [m]
                              cw=0.005,         # uplift sensitivity [kg/m³]
                              conv_time=1000.0, # conversion time [s]
                              fall_time=1000.0 , # fallout time [s]
                              debug = False
                            
                             ):
    """
    Compute orographic precipitation using Smith-Barstad (2004) model.
    
    Args:
        wind_speed: Wind speed in m/s (typical: 10-20)
        wind_dir: Wind direction in degrees (270 = from west)
        precip_base: Background precipitation rate in mm/h (typical: 0.1-1.0)
        nm: Moist stability frequency [1/s] (typical: 0.005)
        hw: Water vapor scale height [m] (typical: 2000-3000)
        cw: Uplift sensitivity [kg/m³] (typical: 0.003-0.006)
        conv_time: Cloud water conversion time [s] (typical: 500-1500)
        fall_time: Hydrometeor fallout time [s] (typical: 500-1500)
    
    Returns:
        Annual precipitation in mm
    """
    
    
    if self.geo is None:
        raise ValueError("Geographic bounds not set. Use terrain.geo = GeoBounds(...)")
    
    # Get 2D elevation array
    grid = self.hexGrid
    elev_2d = self.elevations.reshape(grid.nRows, grid.nCols)
    
    # Get grid resolution in meters
    dx, dy = self.grid_resolution_meters()
    
    if debug:
        print(f"Grid: {grid.nRows} x {grid.nCols}")
        print(f"Resolution: dx={dx:.0f}m (~{dx/1000:.1f}km), dy={dy:.0f}m (~{dy/1000:.1f}km)")
        print(f"Latitude: {self.geo.lat_min}° to {self.geo.lat_max}° (center: {(self.geo.lat_min + self.geo.lat_max)/2:.1f}°)")
        print(f"Wind: {wind_speed} m/s from {wind_dir}°")
        print(f"Background precip: {precip_base} mm/h")
    
    # Run Smith-Barstad model with all required parameters
    precip_rate = op.compute_orographic_precip(
        elev_2d, dx, dy,
        latitude=(self.geo.lat_min + self.geo.lat_max) / 2,
        wind_speed=wind_speed,
        wind_dir=wind_dir,
        precip_base=precip_base,
        precip_min=0.01,
        nm=nm,
        hw=hw,
        cw=cw,
        conv_time=conv_time,
        fall_time=fall_time
    )
    
    # Convert mm/h to annual mm
    hours_per_year = 8760
    annual_precip = precip_rate * hours_per_year
    
    # Flatten and store
    self.fields['precipitation'] = annual_precip.flatten()
    self.fields['precip_rate_mmh'] = precip_rate.flatten()
    
    if debug:
        print(f"\nPrecipitation range: {annual_precip.min():.0f} - {annual_precip.max():.0f} mm/year")
        print(f"Mean: {annual_precip.mean():.0f} mm/year")
    
    return self.fields['precipitation']


# %% ../nbs/06_weather.ipynb #2ee0ad71
@patch
def compute_distance_from_coast(self: Terrain):
    """Calculate distance from coast for each hex using BFS."""
    
    
    n_hexes = len(self.elevations)
    distances = np.full(n_hexes, np.inf)
    
    # Find all coastal hexes (at or below sea level)
    coastal = [i for i in range(n_hexes) if self.elevations[i] <= 0]
    
    # BFS to calculate distances
    queue = deque()
    for coast_idx in coastal:
        distances[coast_idx] = 0
        queue.append((coast_idx, 0))
    
    visited = set(coastal)
    
    while queue:
        current_idx, dist = queue.popleft()
        
        # Check all neighbors
        neighbors = self.ring(current_idx, 1)
        for neighbor in neighbors:
            if neighbor >= 0 and neighbor not in visited:
                distances[neighbor] = dist + 1
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    self.fields['distance_to_coast'] = distances.astype(float)
    return self.fields['distance_to_coast']



# %% ../nbs/06_weather.ipynb #a30b1c86
@patch
def compute_temperature(self: Terrain,
                        base_temp_south=20.0,    # Southern coast 
                        base_temp_north=14.0,    # Northern coast  
                        lapse_rate=6.5):         # °C per 1000m
    """
    Temperature model for California - mean annual temperature.
    Continentality affects seasonal range, not annual mean.
    """
    if 'distance_to_coast' not in self.fields:
        self.compute_distance_from_coast()
    
    # Latitude-based baseline
    if 'latitude' in self.fields and self.geo:
        lat_fraction = (self.fields['latitude'] - self.geo.lat_min) / (self.geo.lat_max - self.geo.lat_min)
        base_temp = base_temp_south + (base_temp_north - base_temp_south) * lat_fraction
    else:
        base_temp = np.full(len(self.elevations), (base_temp_south + base_temp_north) / 2)
    
    # Apply elevation lapse rate
    temp = base_temp - (self.elevations / 1000.0) * lapse_rate
    
    self.fields['temperature'] = temp
    return temp


# %% ../nbs/06_weather.ipynb #a9531ee8
@patch
def validate_coastal_temps(self: Terrain):
    """Check that coastal areas aren't getting tundra temperatures."""
    if 'distance_to_coast' not in self.fields or 'temperature' not in self.fields:
        return "Missing required fields"
    
    # Check coastal hexes (distance <= 2)
    coastal_mask = self.fields['distance_to_coast'] <= 2
    coastal_temps = self.fields['temperature'][coastal_mask]
    coastal_elevs = self.elevations[coastal_mask]
    
    print("=== COASTAL VALIDATION ===")
    print(f"Coastal hexes: {coastal_mask.sum()}")
    print(f"Temp range: {coastal_temps.min():.1f}°C to {coastal_temps.max():.1f}°C")
    print(f"Elevation range: {coastal_elevs.min():.0f}m to {coastal_elevs.max():.0f}m")
    print(f"Mean temp: {coastal_temps.mean():.1f}°C")
    
    # Check for problematic cold coastal areas
    cold_coastal = (coastal_mask) & (self.fields['temperature'] < 10)
    if cold_coastal.sum() > 0:
        print(f"\n⚠️  {cold_coastal.sum()} coastal hexes < 10°C")
        cold_elevs = self.elevations[cold_coastal]
        print(f"   These are at elevations: {cold_elevs.min():.0f}m to {cold_elevs.max():.0f}m")
        print(f"   (Likely coastal mountains - OK for biomes)")
    else:
        print(f"\n✓ No unrealistic cold coastal areas")
    
    # Check high elevation inland
    high_inland = (self.fields['distance_to_coast'] > 5) & (self.elevations > 2000)
    if high_inland.sum() > 0:
        high_temps = self.fields['temperature'][high_inland]
        print(f"\nHigh mountains (>2000m, inland):")
        print(f"  Count: {high_inland.sum()}")
        print(f"  Temp range: {high_temps.min():.1f}°C to {high_temps.max():.1f}°C")


# %% ../nbs/06_weather.ipynb #8291f368
@patch
def climate_readiness(self: Terrain):
    """Check what fields are available for climate classification."""
    required = ['elevation', 'temperature', 'precipitation']
    optional = ['latitude', 'longitude', 'distance_to_coast']
    
    print("=== CLIMATE READINESS ===")
    print("\nRequired fields:")
    print(f"  elevation:     {'✓' if len(self.elevations) > 0 else '✗'}")
    print(f"  temperature:   {'✓' if 'temperature' in self.fields else '✗'}")
    print(f"  precipitation: {'✓' if 'precipitation' in self.fields else '✗'}")
    
    print("\nOptional fields:")
    for field in optional:
        print(f"  {field:20s} {'✓' if field in self.fields else '✗'}")
    
    print("\nAvailable fields:")
    for field in sorted(self.fields.keys()):
        print(f"  - {field}")



# %% ../nbs/06_weather.ipynb #15497168
@patch
def shrinkWeather(self: Terrain, scale=0.5,sample_radius=1):
    """Downsample terrain with all weather data preserved.
    
    This intelligently handles:
    - Elevation (max to preserve peaks)
    - Temperature (weighted average)
    - Precipitation (weighted average)
    - Distance to coast (min - closest coast matters)
    - Geographic coordinates (weighted average)
    
    Args:
        scale: Fraction of original size (0.5 = half size, 0.33 = third size)
    """
    
    # Helper to get hex pattern for sampling
    def hexes_in_range(n):
        """Finding all hexes within distance N from origin"""
        results = []
        for q in range(-n, n + 1):
            for r in range(max(-n, -q - n), min(n, -q + n) + 1):
                s = -q - r
                results.append(HexPosition(q, r, s))
        return results
    
    ring_pattern = hexes_in_range(sample_radius)
    
    # Start with elevation using max (preserve peaks)
    new_elevations, nRows, nCols = self.convolution(
        self.elevations, ring_pattern, scale, method='max')
    
    # Create new terrain with downsampled grid
    grid = HexGrid(
        nRows=nRows,
        nCols=nCols,
        radius=self.hexGrid.radius,
        style=self.hexGrid.style
    )
    
    mySize = MapSize(400, 400)  # These get dropped
    myBounds = MapRect(MapCord(0, 0), mySize)
    new_terrain = Terrain(myBounds, radius=15)
    new_terrain.hexGrid = grid
    new_terrain.elevations = new_elevations
    
    # Copy style properties
    new_terrain.colorLevels = self.colorLevels.copy() if self.colorLevels else None
    new_terrain.elevationDelta = self.elevationDelta
    new_terrain.seaLevel = self.seaLevel
    new_terrain.climate = self.climate
    
    # Downsample all fields with appropriate methods
    field_methods = {
        'temperature': 'weighted_avg',
        'precipitation': 'weighted_avg',
        'precip_rate_mmh': 'weighted_avg',
        'distance_to_coast': 'min',  # Closest coast matters
        'latitude': 'weighted_avg',
        'longitude': 'weighted_avg',
        'temp_range': 'weighted_avg'
    }
    
    for field_name, method in field_methods.items():
        if field_name in self.fields:
            downsampled, _, _ = self.convolution(
                self.fields[field_name], ring_pattern, scale, method=method)
            new_terrain.fields[field_name] = downsampled
    
    # Add color styles
    if new_terrain.colorLevels:
        for color in new_terrain.colorLevels:
            new_terrain.hexGrid.builder.add_style(color)
    
    
    return new_terrain


# %% ../nbs/06_weather.ipynb #f91c9d0b
@patch
def weatherPatterns(self:TerrainPatterns):
    return {
    'tropical': ClimatePreset(
        name='Tropical',
        lat_range=(0, 15),
        base_temp_range=(26, 28),
        wind_speed=8.0,
        wind_dir=90.0,
        precip_base=0.2,
        nm=0.008,
        hw=2500.0,
        cw=0.004,
        conv_time=1000.0,
        fall_time=1000.0,
        lapse_rate=5.5,
        precip_bins=(1500, 2500, 4000, 6000),  # High rainfall expected
        description="Hot, humid, high rainfall. Trade winds from east."
    ),
    
    'subtropical': ClimatePreset(
        name='Subtropical',
        lat_range=(15, 30),
        base_temp_range=(20, 24),
        wind_speed=10.0,
        wind_dir=270.0,
        precip_base=0.12,
        nm=0.009,
        hw=2200.0,
        cw=0.003,
        conv_time=1200.0,
        fall_time=1200.0,
        lapse_rate=6.0,
        precip_bins=(600, 1000, 1800, 3000),  # Moderate
        description="Warm, moderate rainfall. Mediterranean-like."
    ),
    
    'mediterranean': ClimatePreset(
        name='Mediterranean',
        lat_range=(30, 45),
        base_temp_range=(14, 18),
        wind_speed=12.0,
        wind_dir=270.0,
        precip_base=0.08,
        nm=0.01,
        hw=2000.0,
        cw=0.0025,
        conv_time=1500.0,
        fall_time=1500.0,
        lapse_rate=6.5,
        precip_bins=(250, 500, 900, 1400),  # Drier
        description="Mild winters, dry summers. California-like."
    ),
    
    'temperate': ClimatePreset(
        name='Temperate',
        lat_range=(35, 55),
        base_temp_range=(8, 14),
        wind_speed=15.0,
        wind_dir=270.0,
        precip_base=0.15,
        nm=0.012,
        hw=1800.0,
        cw=0.003,
        conv_time=1500.0,
        fall_time=1500.0,
        lapse_rate=6.5,
        precip_bins=(800, 1400, 2200, 3500),  # Wet
        description="Four seasons, moderate rainfall. Pacific Northwest-like."
    ),
    
    'continental': ClimatePreset(
        name='Continental',
        lat_range=(40, 60),
        base_temp_range=(2, 10),
        wind_speed=12.0,
        wind_dir=270.0,
        precip_base=0.08,
        nm=0.013,
        hw=1600.0,
        cw=0.002,
        conv_time=2000.0,
        fall_time=2000.0,
        lapse_rate=7.0,
        precip_bins=(200, 400, 700, 1200),  # Dry interior
        description="Hot summers, cold winters, low rainfall. Central Asia-like."
    ),
    
    'subarctic': ClimatePreset(
        name='Subarctic',
        lat_range=(55, 70),
        base_temp_range=(-5, 5),
        wind_speed=10.0,
        wind_dir=270.0,
        precip_base=0.05,
        nm=0.015,
        hw=1400.0,
        cw=0.0015,
        conv_time=2500.0,
        fall_time=2500.0,
        lapse_rate=7.5,
        precip_bins=(150, 300, 500, 800),  # Low precipitation
        description="Long cold winters, short cool summers. Alaska-like."
    ),
    
    'arctic': ClimatePreset(
        name='Arctic',
        lat_range=(70, 85),
        base_temp_range=(-15, -5),
        wind_speed=8.0,
        wind_dir=0.0,
        precip_base=0.02,
        nm=0.018,
        hw=1200.0,
        cw=0.001,
        conv_time=3000.0,
        fall_time=3000.0,
        lapse_rate=8.0,
        precip_bins=(50, 100, 200, 400),  # Very dry
        description="Extremely cold, very low precipitation. Ice cap climate."
    ),
    
    'monsoon': ClimatePreset(
        name='Monsoon',
        lat_range=(10, 25),
        base_temp_range=(24, 28),
        wind_speed=12.0,
        wind_dir=135.0,
        precip_base=0.25,
        nm=0.007,
        hw=2800.0,
        cw=0.005,
        conv_time=800.0,
        fall_time=800.0,
        lapse_rate=5.5,
        precip_bins=(2000, 3500, 5500, 8000),  # Extreme rainfall
        description="Extreme seasonal rainfall. India/Southeast Asia-like."
    ),
    
    'oceanic': ClimatePreset(
        name='Oceanic',
        lat_range=(40, 60),
        base_temp_range=(8, 12),
        wind_speed=18.0,
        wind_dir=270.0,
        precip_base=0.2,
        nm=0.01,
        hw=2000.0,
        cw=0.004,
        conv_time=1000.0,
        fall_time=1000.0,
        lapse_rate=6.0,
        precip_bins=(1000, 1800, 2800, 4000),  # Very wet
        description="Mild, wet year-round. British Isles-like."
    ),
}

# %% ../nbs/06_weather.ipynb #22b762d3
@patch
def compute_weather(self:Terrain, 
    force_recompute: bool = False, #don't recompute when you don't have to
    debug=False):
    """
    Apply the stored climate preset to compute precipitation, temperature, and climate zones.
    
    Args:
        terrain: Terrain with climate_preset set
        force_recompute: Recompute even if fields already exist
    """
    terrain = self
    preset = terrain.climate
   

    # Compute precipitation
    if 'precipitation' not in terrain.fields or force_recompute:
        if debug:
            print("\nComputing precipitation...")
        terrain.compute_precipitation_sb(
            wind_speed=preset.wind_speed,
            wind_dir=preset.wind_dir,
            precip_base=preset.precip_base,
            nm=preset.nm,
            hw=preset.hw,
            cw=preset.cw,
            conv_time=preset.conv_time,
            fall_time=preset.fall_time,
            debug = debug
        )
    
    # Compute distance to coast
    if 'distance_to_coast' not in terrain.fields or force_recompute:
        if debug:
            print("Computing distance to coast...")
        terrain.compute_distance_from_coast()
    
    # Compute temperature
    if 'temperature' not in terrain.fields or force_recompute:
        if debug:
            print("Computing temperature...")
        terrain.compute_temperature(
            base_temp_south=preset.base_temp_range[0],
            base_temp_north=preset.base_temp_range[1],
            lapse_rate=preset.lapse_rate
        )



# %% ../nbs/06_weather.ipynb #19c9a2de
@patch
def bayArea_map(self:TerraDemo):
    """Load Maui terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/BayArea.txt').open() as f:
        return Terrain.decode(f.read())


# %% ../nbs/06_weather.ipynb #49bd4428
@patch
def aussie_map(self:TerraDemo):
    """Load Maui terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/australia.txt').open() as f:
        return Terrain.decode(f.read())

# %% ../nbs/06_weather.ipynb #8517d8be
@patch
def california_map(self: TerraDemo):
    """Load California terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/ca_nv_elevation_grid.txt').open() as f:
        return Terrain.decode(f.read())
    
    # Set the geographic bounds that match your data
    terrain_ca.geo = GeoBounds(
        lat_min=32.5,   # Southern California/Nevada border
        lat_max=42.0,   # Northern California/Oregon border
        lon_min=-124.5, # Pacific coast
        lon_max=-114.5  # Eastern Nevada
    )
    
    # Compute hex coordinates
    terrain_ca._compute_hex_coordinates()
    terrain_ca.climate = ClimatePreset(
    name='California',
    lat_range=(32.5, 42.0),  # Your actual CA bounds
    base_temp_range=(20, 14),  # Warmer south, cooler north
    wind_speed=10.0,
    wind_dir=270.0,  # Pacific winds from west
    precip_base=0.1,
    nm=0.01,
    hw=2000.0,
    cw=0.002,
    conv_time=2000.0,
    fall_time=2000.0,
    lapse_rate=6.5,
    precip_bins=(200, 500, 1000, 2000),  # Desert to rainforest range
    description="Mediterranean with extreme orographic effects. Mojave to redwoods."
)
    terrain_ca.hexGrid.adjustRadius(30)
    with open('../HexMagic/data/templates/ca_nv_elevation_grid.txt', 'w') as f:
        f.write(terrain_ca.encode())
    
    return terrain_ca

# %% ../nbs/06_weather.ipynb #4b499236
@patch
def maui_map(self:TerraDemo):
    """Load Maui terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/maui.txt').open() as f:
        return Terrain.decode(f.read())
    
    # Set Maui's geographic bounds
    terrain.geo = GeoBounds(
        lat_min=20.57,   # Southern tip (near Makena)
        lat_max=21.03,   # Northern tip (near Kahakuloa)
        lon_min=-156.69, # Western tip (West Maui)
        lon_max=-155.97  # Eastern tip (Haleakalā/Hāna)
    )
    
    # Compute hex coordinates
    terrain._compute_hex_coordinates()
    
    # Maui-specific precipitation model
    # Trade winds from northeast at ~50-60 degrees
    terrain.climate = ClimatePreset(
    name='Maui',
    lat_range=(20.57, 21.03),  # Your actual CA bounds
    base_temp_range=(26, 28),
    wind_speed=8.0,        # Slightly stronger trade winds
    wind_dir=50.0,         
    precip_base=0.15,      # MUCH higher base moisture (tropical ocean)
    nm=0.008,              # Less stable (more convection)
    hw=2500.0,             # Higher moisture scale height
    cw=0.003,              # MUCH stronger orographic effect
    conv_time=1000.0,      # Faster conversion
    fall_time=1000.0 
    )

    with open('../HexMagic/data/templates/maui.txt', 'w') as f:
        f.write(terrain.encode())


    return terrain




# %% ../nbs/06_weather.ipynb #c8df8f67
@patch
def validate_coastal_temps(self: Terrain):
    """Check that coastal areas aren't getting tundra temperatures."""
    if 'distance_to_coast' not in self.fields or 'temperature' not in self.fields:
        return "Missing required fields"
    
    # Check coastal hexes (distance <= 2)
    coastal_mask = self.fields['distance_to_coast'] <= 2
    coastal_temps = self.fields['temperature'][coastal_mask]
    coastal_elevs = self.elevations[coastal_mask]
    
    print("=== COASTAL VALIDATION ===")
    print(f"Coastal hexes: {coastal_mask.sum()}")
    print(f"Temp range: {coastal_temps.min():.1f}°C to {coastal_temps.max():.1f}°C")
    print(f"Elevation range: {coastal_elevs.min():.0f}m to {coastal_elevs.max():.0f}m")
    print(f"Mean temp: {coastal_temps.mean():.1f}°C")
    
    # Check for problematic cold coastal areas
    cold_coastal = (coastal_mask) & (self.fields['temperature'] < 10)
    if cold_coastal.sum() > 0:
        print(f"\n⚠️  {cold_coastal.sum()} coastal hexes < 10°C")
        cold_elevs = self.elevations[cold_coastal]
        print(f"   These are at elevations: {cold_elevs.min():.0f}m to {cold_elevs.max():.0f}m")
        print(f"   (Likely coastal mountains - OK for biomes)")
    else:
        print(f"\n✓ No unrealistic cold coastal areas")
    
    # Check high elevation inland
    high_inland = (self.fields['distance_to_coast'] > 5) & (self.elevations > 2000)
    if high_inland.sum() > 0:
        high_temps = self.fields['temperature'][high_inland]
        print(f"\nHigh mountains (>2000m, inland):")
        print(f"  Count: {high_inland.sum()}")
        print(f"  Temp range: {high_temps.min():.1f}°C to {high_temps.max():.1f}°C")


# %% ../nbs/06_weather.ipynb #05b2494e
@patch
def sanFran_map(self: TerraDemo):
    """Load San Francisco terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/san_francisco.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    # San Francisco area bounds
    terrain.geo = GeoBounds(
        lat_min=37.70,
        lat_max=37.85,
        lon_min=-122.52,
        lon_max=-122.35
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='San Francisco',
        lat_range=(37, 38),
        base_temp_range=(14, 13),  # Famously cool and stable
        wind_speed=15.0,
        wind_dir=270.0,  # Westerlies off Pacific
        precip_base=0.06,
        nm=0.01,
        hw=2000.0,
        cw=0.002,
        conv_time=1500.0,
        fall_time=1500.0,
        lapse_rate=6.5,
        precip_bins=(300, 500, 800, 1200),
        description="Cool Mediterranean. Famous fog from cold Pacific upwelling."
    )
    
    return terrain

@patch
def agincourt_map(self: TerraDemo):
    """Load Agincourt terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/agincourt.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    # Agincourt is in Pas-de-Calais, northern France
    terrain.geo = GeoBounds(
        lat_min=50.40,
        lat_max=50.55,
        lon_min=2.05,
        lon_max=2.25
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Oceanic Northern France',
        lat_range=(50, 51),
        base_temp_range=(10, 11),  # Mild oceanic
        wind_speed=12.0,
        wind_dir=250.0,  # Prevailing SW winds from Atlantic
        precip_base=0.12,
        nm=0.012,
        hw=1800.0,
        cw=0.003,
        conv_time=1200.0,
        fall_time=1200.0,
        lapse_rate=6.0,
        precip_bins=(600, 800, 1000, 1400),
        description="Oceanic climate. Wet, mild year-round. Atlantic influence."
    )
    
    return terrain


# %% ../nbs/06_weather.ipynb #a9100325
@patch
def pompeii_map(self: TerraDemo):
    """Load Pompeii terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/pompeii.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    # Pompeii area - near Naples, includes Vesuvius
    terrain.geo = GeoBounds(
        lat_min=40.70,
        lat_max=40.85,
        lon_min=14.40,
        lon_max=14.55
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Mediterranean Italy',
        lat_range=(40, 41),
        base_temp_range=(16, 15),  # Warm Mediterranean
        wind_speed=8.0,
        wind_dir=240.0,  # SW winds from Tyrrhenian Sea
        precip_base=0.10,
        nm=0.01,
        hw=2000.0,
        cw=0.003,
        conv_time=1500.0,
        fall_time=1500.0,
        lapse_rate=6.5,
        precip_bins=(400, 700, 1000, 1400),
        description="Classic Mediterranean. Hot dry summers, mild wet winters."
    )
    
    return terrain

@patch
def iwo_jima_map(self: TerraDemo):
    """Load Iwo Jima terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/iwo_jima.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    # Iwo Jima - small volcanic island in Pacific
    terrain.geo = GeoBounds(
        lat_min=24.73,
        lat_max=24.80,
        lon_min=141.28,
        lon_max=141.35
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Subtropical Pacific',
        lat_range=(24, 25),
        base_temp_range=(23, 24),  # Warm year-round
        wind_speed=10.0,
        wind_dir=70.0,  # Trade winds from ENE
        precip_base=0.15,
        nm=0.008,
        hw=2400.0,
        cw=0.004,
        conv_time=1000.0,
        fall_time=1000.0,
        lapse_rate=5.5,
        precip_bins=(800, 1200, 1800, 2500),
        description="Subtropical oceanic. Warm, humid. Typhoon season June-Oct."
    )
    
    return terrain

@patch
def normandy_map(self: TerraDemo):
    """Load Normandy terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/normandy.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    # Normandy beaches area
    terrain.geo = GeoBounds(
        lat_min=49.30,
        lat_max=49.45,
        lon_min=-0.95,
        lon_max=-0.75
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Oceanic Normandy',
        lat_range=(49, 50),
        base_temp_range=(11, 10),  # Cool oceanic
        wind_speed=14.0,
        wind_dir=260.0,  # Prevailing westerlies from Atlantic
        precip_base=0.14,
        nm=0.012,
        hw=1800.0,
        cw=0.003,
        conv_time=1200.0,
        fall_time=1200.0,
        lapse_rate=6.0,
        precip_bins=(650, 850, 1100, 1500),
        description="Oceanic. Mild, wet year-round. Strong Atlantic influence."
    )
    
    return terrain

@patch
def grand_canyon_map(self: TerraDemo):
    """Load Grand Canyon terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/grand_canyon.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    # Grand Canyon area
    terrain.geo = GeoBounds(
        lat_min=35.95,
        lat_max=36.25,
        lon_min=-112.30,
        lon_max=-111.90
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='High Desert Arizona',
        lat_range=(35, 37),
        base_temp_range=(14, 12),  # Varies hugely with elevation
        wind_speed=8.0,
        wind_dir=240.0,  # SW monsoon influence in summer
        precip_base=0.03,  # Very dry
        nm=0.015,
        hw=1500.0,
        cw=0.002,
        conv_time=2000.0,
        fall_time=2000.0,
        lapse_rate=7.0,  # Steeper due to dry air
        precip_bins=(150, 300, 450, 700),  # Desert precipitation
        description="High desert. Extreme elevation range (rim to river ~1500m). Hot summers, cold winters at rim."
    )
    
    return terrain


# %% ../nbs/06_weather.ipynb #3df56371
@patch
def sydney_map(self: TerraDemo):
    """Load Sydney terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/sydney.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    terrain.geo = GeoBounds(
        lat_min=-34.05,
        lat_max=-33.70,
        lon_min=150.95,
        lon_max=151.35
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Humid Subtropical Sydney',
        lat_range=(-34, -33),
        base_temp_range=(18, 17),  # Mild year-round
        wind_speed=10.0,
        wind_dir=90.0,  # Easterlies from Pacific
        precip_base=0.12,
        nm=0.01,
        hw=2200.0,
        cw=0.003,
        conv_time=1200.0,
        fall_time=1200.0,
        lapse_rate=6.0,
        precip_bins=(600, 900, 1200, 1600),
        description="Humid subtropical. Warm summers, mild winters. Rain year-round."
    )
    
    return terrain

@patch
def hong_kong_map(self: TerraDemo):
    """Load Hong Kong terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/hong_kong.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    terrain.geo = GeoBounds(
        lat_min=22.15,
        lat_max=22.55,
        lon_min=113.85,
        lon_max=114.40
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Subtropical Monsoon Hong Kong',
        lat_range=(22, 23),
        base_temp_range=(23, 22),  # Hot and humid
        wind_speed=10.0,
        wind_dir=135.0,  # SE monsoon in summer
        precip_base=0.18,
        nm=0.008,
        hw=2600.0,
        cw=0.004,
        conv_time=900.0,
        fall_time=900.0,
        lapse_rate=5.5,
        precip_bins=(1200, 1800, 2400, 3200),
        description="Subtropical monsoon. Hot wet summers, mild dry winters. Typhoon season."
    )
    
    return terrain


# %% ../nbs/06_weather.ipynb #83fabb6e
@patch
def reykjavik_map(self: TerraDemo):
    """Load Reykjavik terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/reykjavik.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    terrain.geo = GeoBounds(
        lat_min=63.95,
        lat_max=64.20,
        lon_min=-22.10,
        lon_max=-21.70
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Subarctic Oceanic Iceland',
        lat_range=(63, 65),
        base_temp_range=(5, 4),  # Cool year-round, Gulf Stream moderates
        wind_speed=14.0,
        wind_dir=240.0,  # SW winds from Atlantic
        precip_base=0.10,
        nm=0.013,
        hw=1600.0,
        cw=0.003,
        conv_time=1800.0,
        fall_time=1800.0,
        lapse_rate=6.5,
        precip_bins=(400, 700, 1000, 1400),
        description="Subarctic oceanic. Mild for latitude due to Gulf Stream. Windy, changeable."
    )
    
    return terrain

@patch
def rio_map(self: TerraDemo):
    """Load Rio de Janeiro terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/rio.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    terrain.geo = GeoBounds(
        lat_min=-23.10,
        lat_max=-22.75,
        lon_min=-43.55,
        lon_max=-43.10
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Tropical Rio',
        lat_range=(-23, -22),
        base_temp_range=(25, 26),  # Hot year-round
        wind_speed=8.0,
        wind_dir=90.0,  # Trade winds from east/Atlantic
        precip_base=0.15,
        nm=0.007,
        hw=2600.0,
        cw=0.004,
        conv_time=900.0,
        fall_time=900.0,
        lapse_rate=5.5,
        precip_bins=(1000, 1400, 1800, 2500),
        description="Tropical savanna. Hot humid summers, warm dry winters. Orographic rain on mountains."
    )
    
    return terrain

@patch
def santorini_map(self: TerraDemo):
    """Load Santorini terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/santorini.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    terrain.geo = GeoBounds(
        lat_min=36.35,
        lat_max=36.48,
        lon_min=25.35,
        lon_max=25.50
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Mediterranean Aegean',
        lat_range=(36, 37),
        base_temp_range=(18, 17),  # Warm Mediterranean
        wind_speed=12.0,
        wind_dir=350.0,  # Etesian/Meltemi winds from north in summer
        precip_base=0.04,  # Very dry
        nm=0.012,
        hw=1800.0,
        cw=0.002,
        conv_time=1800.0,
        fall_time=1800.0,
        lapse_rate=6.5,
        precip_bins=(200, 350, 500, 700),
        description="Hot-summer Mediterranean. Very dry summers, mild wet winters. Strong summer winds."
    )
    
    return terrain

@patch
def kathmandu_map(self: TerraDemo):
    """Load Kathmandu terrain with proper geographic bounds."""
    with resources.files('HexMagic').joinpath('data/templates/kathmandu.txt').open() as f:
        terrain = Terrain.decode(f.read())
    
    terrain.geo = GeoBounds(
        lat_min=27.60,
        lat_max=27.80,
        lon_min=85.25,
        lon_max=85.45
    )
    
    terrain._compute_hex_coordinates()
    
    terrain.climate = ClimatePreset(
        name='Subtropical Highland Monsoon',
        lat_range=(27, 28),
        base_temp_range=(20, 18),  # Moderate due to elevation (~1400m)
        wind_speed=6.0,
        wind_dir=180.0,  # Monsoon from south in summer
        precip_base=0.12,
        nm=0.008,
        hw=2400.0,
        cw=0.005,  # Strong orographic effect - Himalayas!
        conv_time=800.0,
        fall_time=800.0,
        lapse_rate=6.0,
        precip_bins=(800, 1200, 1800, 2500),
        description="Subtropical highland with monsoon. Warm wet summers, cool dry winters. Extreme orographic effects."
    )
    
    return terrain


# %% ../nbs/06_weather.ipynb #c343dfdb
@patch
def visualize_precipitation(self: Terrain, layer_name="precipitation",f=None):
    """Visualize precipitation with color gradient and legend."""
    if 'precipitation' not in self.fields:
        print("Computing precipitation first...")
        self.compute_precipitation_sb()
    
    precip = self.fields['precipitation']
    
    # Precipitation thresholds (mm/year)
    thresholds = [0, 150, 300, 500, 750, 1000, 1500, 2000]
    
    # Get patterns from precipitationStyle
    patGen = TerrainPatterns(self)
    terrain = self

    terrain.colorMap()
    
    # Find ocean hexes (level 0)
    ocean_hexes = terrain.find_region_at_level(0)
    ocean_region = HexRegion(hexes=ocean_hexes, hexGrid=terrain.hexGrid)
    
    # Create wave pattern with ocean blues
   
    wave = patGen.wavePattern("ocean_waves_pat", 
                              amplitude=4, 
                              wavelength=16, 
                              color="#1565C0",      # stroke: medium blue
                              fill="#E3F2FD")       # fill: light blue

    oceanStyle = StyleCSS("ocean_waves", fill=f"url(#ocean_waves_pat)")
    self.builder.add_definition(wave)
    self.builder.add_style(oceanStyle)

    patterns, styles = patGen.precipitationStyle(0.1)
    
    # Add patterns to builder
    for p in patterns:
        self.builder.add_definition(p)

    for s in styles:
        self.builder.add_style(s)
    
    # Bin precipitation values
    precip_indices = np.digitize(precip, thresholds) - 1
    precip_indices = np.clip(precip_indices, 0, len(patterns) - 1)
    
    sgrid = self.hexGrid
   
    climateRegions = sgrid.regions_by_value(precip_indices)

    for region in climateRegions:
        idx  =  region.hexes.pop()
        region.hexes.add(idx)
        
        styleI = int(precip_indices[idx])
        style = styles[styleI]
        for i in region:
            sgrid.hexes[i].style = style

    for i in ocean_region:
        sgrid.hexes[i].style = oceanStyle

    overlay =  sgrid.styleLayerOrdered(
        styles=styles,
        f=f)


   
    sgrid.builder.adjust(layer_name,overlay)

    legend = sgrid.builder.legendOverlay(styles)
    sgrid.builder.adjust("legend", legend)
    



# %% ../nbs/06_weather.ipynb #2f3095d3
@patch
def dotted_field(self: Terrain, field='precipitation',
                  flow_levels: int = 5,
                  min_density: float = 0.25,  # Minimum dot density for dry areas
                  color:str = "#cccccc",
                  debug: bool = False) -> str:
    """Combine climate colors with precipitation-based dot density.
    
    Args:
        flow_levels: Number of dot density levels (default 5)
        min_density: Minimum density for low-precip areas (0.25 = 25%)
        debug: Print pattern generation info
    
    Returns:
        SVG string for the overlay
    """
    
    if  field not in self.fields:
        raise ValueError(f"Need both {field} computed")
    
    
    # Generate patterns for each climate type
    patternGen = TerrainPatterns(self)
    all_patterns = []
      
        # Create flow_levels density patterns for this climate color
    patterns = patternGen.ballDensity(
        levels=flow_levels + 3,
        fills=[color],
        prefix=f"{field}_ball"
    )[:flow_levels]
        
    if debug:
        print(f"{climate_type.name}: generated {len(patterns)} patterns with color {color}")
    
    all_patterns.extend(patterns)
    
    # Build overlay
    grid = self.hexGrid
    overlay = ""
    used_patterns = set()
    
    precip_data = self.fields[field]
    
    # Find max precipitation for normalization
    max_precip = precip_data.max()
    min_precip = precip_data.min()
    
    if debug:
        print(f"\n{field} range: {min_precip:.0f} - {max_precip:.0f} mm/year")
        print(f"Min density: {min_density * 100}%")
    
    # Generate hex polygons
    for i, precip in enumerate(precip_data):
        
        # Normalize precipitation to [min_density, 1.0] range
        if max_precip > min_precip:
            normalized_precip = (precip - min_precip) / (max_precip - min_precip)  # [0, 1]
            # Scale to [min_density, 1.0]
            scaled_precip = min_density + normalized_precip * (1.0 - min_density)
            precip_level = int(scaled_precip * (flow_levels - 1))
            precip_level = min(precip_level, flow_levels - 1)
        else:
            precip_level = 0
        
        # Calculate pattern index: climate_val * flow_levels + precip_level
        pattern_idx =  precip_level
        
        # Bounds check
        if pattern_idx >= 0 and pattern_idx < len(all_patterns):
            used_patterns.add(pattern_idx)
            
            patName = all_patterns[pattern_idx].attributes['id']
            fill = f"url(#{patName})"
            
            # Generate polygon
            hex_obj = grid.hexes[i]
            ret = "<polygon points=\""
            for point in hex_obj.vertices():
                ret += f"{point.x:.0f},{point.y:.0f} "
            ret += f"\" style=\"fill:{fill}\"/>"
            
            overlay += "\t" + ret + "\n"
    
    # Add used patterns to builder
    for pattern_idx in sorted(used_patterns):
        grid.builder.add_definition(all_patterns[pattern_idx])
    
    if debug:
        print(f"\nUsed {len(used_patterns)} patterns out of {len(all_patterns)}")
    
    return overlay


# %% ../nbs/06_weather.ipynb #da46243c
@patch
def add_rain_overlay(self: Terrain, layer_name="climate_precip",debug=False):
    """Combine climate colors with precipitation-based dot density."""
   
    overlay =  self.dotted_field(debug=debug)
    self.hexGrid.builder.adjust(layer_name, overlay)
    
    return self

# %% ../nbs/06_weather.ipynb #ff0e9cee
class WeatherColor:
    """Color scheme for weather map."""

    def __init__(self,color: str = "#000000"):
        self.color = color  # <-- Need the assignment!
        self.r, self.g, self.b = int(color[1:3], 16), int(color[3:5], 16), int(color[5:7], 16)
        self.h, self.l, self.s = colorsys.rgb_to_hls(self.r/255, self.g/255, self.b/255)

    def __str__(self):
        return self.color

    def __repr__(self):
        return f"r:{self.r:02} g:{self.g:02} b:{self.b:02}   "

    
    @staticmethod
    def temp_to_color(temp: float) -> 'WeatherColor':
        """Map temperature to smooth weather map gradient (purple → blue → green → yellow → red)."""
  
        
        # Define color stops: (temperature, hex_color)
        stops = [
            (-15, "#8B4789"),  # Purple (very cold)
            (0,   "#4A90E2"),  # Blue (freezing)
            (10,  "#50C878"),  # Green (cool)
            (20,  "#F4D03F"),  # Yellow (warm)
            (30,  "#E74C3C"),  # Red (hot)
        ]
        
        # Clamp temperature to range
        if temp <= stops[0][0]:
            return stops[0][1]
        if temp >= stops[-1][0]:
            return stops[-1][1]
        
        # Find the two stops to interpolate between
        for i in range(len(stops) - 1):
            temp1, color1 = stops[i]
            temp2, color2 = stops[i + 1]
            
            if temp1 <= temp <= temp2:
                # Calculate interpolation factor (0 to 1)
                factor = (temp - temp1) / (temp2 - temp1)
                
                # Convert hex to RGB
                r1, g1, b1 = int(color1[1:3], 16), int(color1[3:5], 16), int(color1[5:7], 16)
                r2, g2, b2 = int(color2[1:3], 16), int(color2[3:5], 16), int(color2[5:7], 16)
                
                # Interpolate in RGB space
                r = int(r1 + (r2 - r1) * factor)
                g = int(g1 + (g2 - g1) * factor)
                b = int(b1 + (b2 - b1) * factor)
                
                return WeatherColor(f"#{r:02x}{g:02x}{b:02x}")
        
        return WeatherColor("#808080" ) # Fallback gray
    
   
    def adjust_brightness(self, elevation: float, max_elev: float = 3000.0, range_pct: float = 0.10) -> 'WeatherColor':
        """Adjust color brightness based on elevation.
        
        Args:
            color: Hex color string
            elevation: Elevation in meters
            max_elev: Maximum elevation for normalization
            range_pct: Brightness adjustment range (0.10 = ±10%)
        """
        
        color = self.color
        
        # Normalize elevation to [-1, 1] range
        elev_norm = np.clip(elevation / max_elev, 0, 1) * 2 - 1
        
        # Adjust lightness: higher elevation = brighter (within range_pct)
        l = self.l + (elev_norm * range_pct)
        l = np.clip(l, 0, 1)
        
        # Convert back to RGB
        r, g, b = colorsys.hls_to_rgb(self.h, l, self.s)
        
        return  WeatherColor(f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}")
    
    
    def adjust_saturation(self, precip: float, climate_preset: ClimatePreset) -> 'WeatherColor':
        """Adjust color saturation based on precipitation.
        
        Args:
            color: Hex color string
            precip: Precipitation in mm/year
            climate_preset: ClimatePreset with precip_bins
        """
        color = self.color
        
        # Normalize precipitation using climate's bins
        bins = climate_preset.precip_bins
        if precip <= bins[0]:
            sat_factor = 0.5  # Very dry = 50% saturation
        elif precip >= bins[-1]:
            sat_factor = 1.0  # Very wet = 100% saturation
        else:
            # Linear interpolation between bins
            for i in range(len(bins) - 1):
                if bins[i] <= precip <= bins[i+1]:
                    sat_factor = 0.5 + 0.5 * ((precip - bins[i]) / (bins[i+1] - bins[i]))
                    break
        
       
        
        # Adjust saturation
        s = self.s * sat_factor
        s = np.clip(s, 0, 1)
        
        # Convert back to RGB
        r, g, b = colorsys.hls_to_rgb(self.h, self.l, s)
        
        return WeatherColor(f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}")

@patch
def render_icon_temperature(self: Terrain, ocean_color: str = "#2c5f8d") -> str:
    """Render hexes with inline fill based on temperature gradient.
    
    Args:
        ocean_color: Solid color for ocean hexes
    
    Returns:
        SVG string with solid-colored hexes
    """
    if 'temperature' not in self.fields:
        raise ValueError("Temperature field not computed")
    
    if 'precipitation' not in self.fields:
        raise ValueError("Precipitation field not computed")
    
    overlay = ""
    grid = self.hexGrid
    
    # Find max elevation for normalization
    land_elevs = self.elevations[self.elevations > 0]
    max_elev = land_elevs.max() if len(land_elevs) > 0 else 3000.0
    
    for i in range(len(self.elevations)):
        if self.elevations[i] <= 0:
            # Ocean
            color = ocean_color
        else:
            # Land: temperature gradient
            temp = self.fields['temperature'][i]
            color = WeatherColor.temp_to_color(temp)
            
            # Modulate by elevation (brightness)
            color = color.adjust_brightness( self.elevations[i], max_elev)
            
            # Modulate by precipitation (saturation)
            if self.climate:
                color = color.adjust_saturation( self.fields['precipitation'][i], self.climate)
        
        # Generate polygon with inline fill
        hex_obj = grid.hexes[i]
        points = " ".join([f"{p.x:.0f},{p.y:.0f}" for p in hex_obj.vertices()])
        overlay += f'\t<polygon points="{points}" fill="{color}"/>\n'
    
    return overlay
