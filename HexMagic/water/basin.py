# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/water/basin.ipynb.

# %% auto #0
__all__ = ['DrainageBasins']

# %% ../../nbs/water/basin.ipynb #dbb6cb4a
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum
import heapq

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

#custom
import copy

# %% ../../nbs/water/basin.ipynb #f400829f
from ..styles import StyleCSS, SVGBuilder, SVGLayer, SVGPatternLoader, preview, app, StyleDemo, LayerAnimation
from ..primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexWrapper, HexPosition, hexBackground, HexRegion, unique_windy_edge
from ..terrain import  TerraDemo, Terrain, GeoBounds, ClimatePreset
from ..terrainpatterns import TerrainPatterns, SVGMask

# %% ../../nbs/water/basin.ipynb #c743004f
from .soil import SoilSystem, SoilType
from .river import River, RiverDemo
from ..weather import TerraDemo
from .watershed import Watershed


# %% ../../nbs/water/basin.ipynb #8c18e5b1
class DrainageBasins:

    def __init__(self,terrain: Terrain,debug=False):
        self.terrain = terrain
        self.sheds = Watershed.compute_all(terrain,debug=debug)

# %% ../../nbs/water/basin.ipynb #af7641b7
@patch
def select_shed(self: DrainageBasins, 
                                    min_flow: int = 10,
                                    max_rivers: int = 20,
                                    min_length: int = 5) -> List[Watershed]:
    """Select the most important rivers to display.
    
    Strategy:
    1. One main river per major watershed (largest basins)
    2. Rivers must have significant flow (min_flow)
    3. Rivers must be long enough to be visible (min_length)
    4. Prioritize by watershed size and flow
    
    Args:
        min_flow: Minimum accumulated flow to show
        max_rivers: Maximum number of rivers to return
        min_length: Minimum number of hexes in river path
    
    Returns:
        List of River objects suitable for display
    """
    candidates = []
    
    for watershed in self.sheds:
        river = watershed.tributary
        
        # Calculate river metrics
        flow_values = river._calculate_flow()
        max_flow = max(flow_values.values()) if flow_values else 0
        river_length = len(river.hexes)
        watershed_size = len(watershed.region.hexes)
        
        # Score = combination of flow, length, and watershed size
        score = max_flow * 0.5 + river_length * 0.3 + watershed_size * 0.2
        
        # Filter by minimum criteria
        if max_flow >= min_flow and river_length >= min_length:
            candidates.append((watershed, score, max_flow, river_length))
    
    # Sort by score descending
    candidates.sort(key=lambda x: x[1], reverse=True)
    
    # Return top N watershed
    return [watershed for watershed, _, _, _ in candidates[:max_rivers]]
    

# %% ../../nbs/water/basin.ipynb #c5185c5d
@patch
def get_major(self: DrainageBasins, top_n: int = 5) -> List[Watershed]:
    """Get the N largest rivers by flow."""
    return self.select_shed(
        min_flow=2,      # Lower threshold for small terrains
        max_rivers=top_n,
        min_length=3
    )

# %% ../../nbs/water/basin.ipynb #1619e4bc
@patch
def watershed_overlay(self:DrainageBasins):
    """Demo showing watersheds colored by drainage basin."""

    # Create overlay for watershed colors
    overlay = ""
    
    for i, watershed in enumerate(self.sheds):
        # Add this watershed's style to builder
        self.terrain.hexGrid.builder.add_style(watershed.style)
        
        # Draw all hexes in this watershed's region
        for hex_idx in watershed.region.hexes:
            hex_obj = self.terrain.hexGrid.hexes[hex_idx]
            overlay += f"\t{hex_obj.svg()}\n".replace(
                hex_obj.style.name, 
                watershed.style.name
            )
    
    # Add watershed overlay as new layer
    return overlay
    
@patch
def boundary_overlay(self:DrainageBasins,
                boundary_style = StyleCSS("watershed_boundary", 
                             fill="none", 
                             stroke="#000000", 
                             stroke_width=2,
                             opacity=0.8)):
    # Optionally draw watershed boundaries
    overlay = ""
    self.terrain.hexGrid.builder.add_style(boundary_style)
    
    for watershed in self.sheds:
        paths = watershed.region.trace_perimeter(style=boundary_style)
        for path in paths:
            overlay += path.svg()
    
    return overlay


# %% ../../nbs/water/basin.ipynb #a35a6653
@patch
def build_fans_and_deltas(self: DrainageBasins,
                          top_n: int = 8,
                          build_fans: bool = True,
                          build_deltas: bool = True,
                          debug: bool = False):
    """Build alluvial fans and deltas for major watersheds.
    
    Returns dict with 'fans' and 'deltas' keys containing HexRegion lists.
    """
    major_sheds = self.get_major(top_n)
    
    all_fans = []
    all_deltas = []
    
    for watershed in major_sheds:
        if build_fans:
            fans = watershed.build_alluvial_fan(debug=debug)
            all_fans.extend(fans)
        
        if build_deltas and watershed.is_ocean:
            delta = watershed.build_delta(debug=debug)
            if delta.hexes:
                all_deltas.append(delta)
    
    return {
        'fans': all_fans,
        'deltas': all_deltas
    }

# %% ../../nbs/water/basin.ipynb #2c9d1041
@patch
def gradient_overlay(self: DrainageBasins,
                     min_width: float = 0.5,
                     max_width: float = 4.0,
                     opacity: float = 0.6):
    """Create overlay showing flow direction with gradient-based line widths.
    
    Each line segment:
    - Connects a land hex to its downhill neighbor
    - Colored by watershed
    - Width scaled by elevation gradient (steeper = thicker)
    
    Args:
        min_width: Minimum line width (for flat areas)
        max_width: Maximum line width (for steep slopes)
        opacity: Line opacity (0-1)
    
    Returns:
        SVG string of line segments
    """
    terrain = self.terrain
    
    # First pass: calculate all gradients to find max for normalization
    gradients = []
    flow_data = []  # Store (hex_idx, neighbor_idx, gradient, watershed_idx)
    
    # Map each hex to its watershed
    hex_to_watershed = {}
    for i, watershed in enumerate(self.sheds):
        for hex_idx in watershed.region.hexes:
            hex_to_watershed[hex_idx] = i
    
    for hex_idx in hex_to_watershed.keys():
        # Find lowest neighbor (flow direction)
        lowest = terrain.lowest_neighbor(hex_idx)
        
        if lowest is None or terrain.elevations[lowest] <= 0:
            continue  # Skip if no downhill or flows to ocean
        
        # Calculate gradient
        elev_current = terrain.elevations[hex_idx]
        elev_next = terrain.elevations[lowest]
        elev_drop = elev_current - elev_next
        
        # Distance between hex centers
        hex_obj = terrain.hexGrid.hexes[hex_idx]
        neighbor_obj = terrain.hexGrid.hexes[lowest]
        distance = hex_obj.center.distance(neighbor_obj.center)
        
        gradient = elev_drop / distance if distance > 0 else 0
        gradients.append(gradient)
        
        watershed_idx = hex_to_watershed[hex_idx]
        flow_data.append((hex_idx, lowest, gradient, watershed_idx))
    
    # Find max gradient for normalization
    max_gradient = max(gradients) if gradients else 1.0
    
    # Second pass: generate SVG lines
    overlay = ""
    
    # Create styles for each watershed with opacity
    for i, watershed in enumerate(self.sheds):
        # Create a modified style with opacity for lines
        line_style = StyleCSS(
            f"{watershed.style.name}_flow",
            stroke=watershed.style.properties.get('fill', '#000000'),
            fill="none",
            opacity=opacity,
            stroke_linecap="round"
        )
        terrain.hexGrid.builder.add_style(line_style)
    
    # Generate line segments
    for hex_idx, neighbor_idx, gradient, watershed_idx in flow_data:
        # Normalize gradient and calculate width
        normalized = gradient / max_gradient if max_gradient > 0 else 0
        width = min_width + normalized * (max_width - min_width)
        
        # Get hex centers
        hex_obj = terrain.hexGrid.hexes[hex_idx]
        neighbor_obj = terrain.hexGrid.hexes[neighbor_idx]
        
        # Get watershed style
        watershed = self.sheds[watershed_idx]
        style_name = f"{watershed.style.name}_flow"
        
        # Create line segment
        overlay += (
            f'\t<line '
            f'x1="{hex_obj.center.x:.1f}" '
            f'y1="{hex_obj.center.y:.1f}" '
            f'x2="{neighbor_obj.center.x:.1f}" '
            f'y2="{neighbor_obj.center.y:.1f}" '
            f'class="{style_name}" '
            f'stroke-width="{width:.2f}" '
            f'/>\n'
        )
    
    return overlay


# %% ../../nbs/water/basin.ipynb #dd7c3ac7
@patch
def dotted_watershed_overlay(self: DrainageBasins, 
                              flow_levels: int = 5,
                              min_density: float = 0.25,  # NEW: minimum dot density
                              debug: bool = False) -> str:
    """Create dotted watershed overlay where dot density represents flow accumulation.
    
    Args:
        flow_levels: Number of dot density levels (default 5)
        min_density: Minimum density for low-flow areas (0.25 = 25%)
        debug: Print pattern generation info
    
    Returns:
        SVG string for the overlay
    """
    terrain = self.terrain
    
    # Ensure we have flow data
    if 'flow' not in terrain.fields:
        all_flows = {}
        for watershed in self.sheds:
            river_flow = watershed.tributary._calculate_flow()
            for hex_idx, flow_count in river_flow.items():
                all_flows[hex_idx] = all_flows.get(hex_idx, 0) + flow_count
        
        terrain.fields['flow'] = np.zeros(len(terrain.elevations))
        for hex_idx, flow in all_flows.items():
            terrain.fields['flow'][hex_idx] = flow
    
    flow_data = terrain.fields['flow']
    
    # Generate patterns for each watershed
    patternGen = TerrainPatterns(terrain)
    all_patterns = []
    watershed_to_patterns = {}
    
    for i, watershed in enumerate(self.sheds):
        color = watershed.style.properties.get('fill', '#cccccc')
        
        # Create flow_levels density patterns for this watershed color
        patterns = patternGen.ballDensity(
            levels=flow_levels + 3,
            fills=[color],
            prefix=f"watershed_{i}_flow"
        )[:flow_levels]
        
        if debug:
            print(f"Watershed {i}: generated {len(patterns)} patterns with color {color}")
        
        # Store pattern indices
        start_idx = len(all_patterns)
        watershed_to_patterns[i] = list(range(start_idx, start_idx + flow_levels))
        all_patterns.extend(patterns)
    
    # Build overlay
    grid = terrain.hexGrid
    overlay = ""
    used_patterns = set()
    
    # Map each hex to its watershed
    hex_to_watershed = {}
    for i, watershed in enumerate(self.sheds):
        for hex_idx in watershed.region.hexes:
            hex_to_watershed[hex_idx] = i
    
    # Find max flow for normalization
    watershed_hexes = set(hex_to_watershed.keys())
    max_flow = max((flow_data[h] for h in watershed_hexes if flow_data[h] > 0), default=1.0)
    
    if debug:
        print(f"Max flow in watersheds: {max_flow}")
        print(f"Min density: {min_density * 100}%")
    
    # Generate hex polygons
    for hex_idx in watershed_hexes:
        if hex_idx not in hex_to_watershed:
            continue
        
        watershed_idx = hex_to_watershed[hex_idx]
        flow = flow_data[hex_idx]
        
        # Normalize flow to [min_density, 1.0] range
        if flow > 0 and max_flow > 0:
            normalized_flow = (flow / max_flow)  # [0, 1]
            # Scale to [min_density, 1.0]
            scaled_flow = min_density + normalized_flow * (1.0 - min_density)
            flow_level = int(scaled_flow * (flow_levels - 1))
            flow_level = min(flow_level, flow_levels - 1)
        else:
            flow_level = 0  # Use minimum density pattern
        
        # Get pattern index
        pattern_indices = watershed_to_patterns[watershed_idx]
        pattern_idx = pattern_indices[flow_level]
        
        used_patterns.add(pattern_idx)
        
        # Generate polygon
        patName = all_patterns[pattern_idx].attributes['id']
        fill = f"url(#{patName})"
        
        hex_obj = grid.hexes[hex_idx]
        ret = "<polygon points=\""
        for point in hex_obj.vertices():
            ret += f"{point.x:.0f},{point.y:.0f} "
        ret += f"\" style=\"fill:{fill}\"/>"
        
        overlay += "\t" + ret + "\n"
    
    # Add used patterns to builder
    for pattern_idx in sorted(used_patterns):
        grid.builder.add_definition(all_patterns[pattern_idx])
    
    if debug:
        print(f"Used {len(used_patterns)} patterns out of {len(all_patterns)}")
    
    return overlay


# %% ../../nbs/water/basin.ipynb #2b3db31a
@patch
def draw_watersheds(self: DrainageBasins, top_n: int = 8, simplify_k: int = 3, max_width: float = None,lake_base_size: int = 3) -> str:

    watersheds = self.get_major(top_n)
    
    if max_width is None:
        max_width = self.terrain.hexGrid.radius * 2 / 3
    # Compute max flow across all selected rivers
    max_flow = 0
    for ws in watersheds:
        flows = ws.calculate_flow()
        if flows:
            max_flow = max(max_flow, max(flows.values()))
    
    # Draw each watershed, passing max_flow for absolute scaling
    svg = ""
    for shed in watersheds:
        #svg += shed.simplify(simplify_k).draw(max_flow=max_flow)
        svg += shed.draw(max_flow=max_flow,
            max_width=max_width,
            lake_base_size=lake_base_size
        )
    
    return svg

