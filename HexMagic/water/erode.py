# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/water/erode.ipynb.

# %% auto #0
__all__ = ['ErosionModel']

# %% ../../nbs/water/erode.ipynb #91bb6416
#standard
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple, deque
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

# unique
from treelib import Tree
import heapq


# %% ../../nbs/water/erode.ipynb #a00c60ae
from ..styles import StyleCSS, SVGBuilder,SVGLayer, SVGPatternLoader, preview, app, StyleDemo,NamedColor
from ..primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexWrapper, HexPosition, hexBackground,windy_edge, HexRegion, unique_windy_edge
from ..terrain import  TerraDemo, Terrain
from ..terrainpatterns import TerrainPatterns


# %% ../../nbs/water/erode.ipynb #dd61c75a
from ..voronoi import PlateKind
from .soil import SoilSystem, SoilType

from ..weather import TerraDemo

# %% ../../nbs/water/erode.ipynb #e60e9c22
@dataclass
class ErosionModel:
    """Simple erosion model with age parameter."""
    terrain: 'Terrain'
    soil_system: 'SoilSystem'
    age: float = 1.0  # 0.1 = young/new world, 1.0 = old world
    
    def erode(self, iterations: int = 1, base_rate: float = 5.0, deposition_threshold: float = 50.0):
        """Run erosion simulation.
        
        Args:
            iterations: Number of erosion passes (age scales this)
            base_rate: Base erosion amount per unit stream power
            deposition_threshold: Elevation below which deposition occurs
        """
        effective_iters = max(1, int(iterations * self.age))
        
        for _ in range(effective_iters):
            self._erode_pass(base_rate, deposition_threshold)
    
    
    def _update_soils(self, eroded: np.ndarray, deposited: np.ndarray):
        """Update soil types based on erosion/deposition."""
        soil_types = self.terrain.fields['soil_type']
        elevations = self.terrain.elevations
        
        for i in range(len(elevations)):
            if deposited[i] > 5:
                # Significant deposition → Alluvial
                soil_types[i] = 4
            elif eroded[i] < -20:
                # Heavy erosion → expose bedrock
                if elevations[i] > 500:
                    soil_types[i] = 0  # Granite
                else:
                    soil_types[i] = 1  # Basalt
            elif eroded[i] < -5:
                # Moderate erosion → sandstone/limestone
                soil_types[i] = 3 if soil_types[i] > 2 else 2
        
        # Rebuild regions
        for type_idx in range(len(self.soil_system.types)):
            hexes = set(np.where(soil_types == type_idx)[0])
            self.soil_system.regions[type_idx] = HexRegion(hexes=hexes, hexGrid=self.terrain.hexGrid)


# %% ../../nbs/water/erode.ipynb #82eba692
@patch
def _find_knickpoints(self: ErosionModel, river: River, gradient_threshold: float = 15.0) -> list[int]:
    """Find knickpoints (sudden gradient changes) in a river.
    
    Returns hex indices where gradient spikes (potential waterfalls).
    """
    gradient = river._calculate_gradient()
    knickpoints = []
    
    # Walk upstream looking for gradient jumps
    for node in river.tree.all_nodes():
        for i, hex_idx in enumerate(node.data):
            if gradient.get(hex_idx, 0) > gradient_threshold:
                knickpoints.append(hex_idx)
    
    return knickpoints

@patch
def _migrate_knickpoint(self: ErosionModel, hex_idx: int, river: River, migration_rate: float = 0.5):
    """Migrate a knickpoint upstream by eroding the lip.
    
    Args:
        hex_idx: Current knickpoint location
        river: The river containing this knickpoint
        migration_rate: How much to erode (scaled by age and soil)
    """
    terrain = self.terrain
    soil_types = terrain.fields.get('soil_type', np.zeros(len(terrain.elevations), dtype=int))
    types = self.soil_system.types
    
    # Get soil resistance at knickpoint
    resistance = types[soil_types[hex_idx]].erosion_resistance
    
    # Find upstream hex(es) - these form the "lip" of the waterfall
    upstream_hexes = []
    for node in river.tree.all_nodes():
        if hex_idx in node.data:
            idx = node.data.index(hex_idx)
            # Upstream is later in the list (remember: outlet is first)
            if idx < len(node.data) - 1:
                upstream_hexes.append(node.data[idx + 1])
            # Also check child nodes (tributaries joining here)
            for child in river.tree.children(node.identifier):
                upstream_hexes.append(child.data[0])
            break
    
    if not upstream_hexes:
        return
    
    # Calculate erosion at the lip
    current_elev = terrain.elevations[hex_idx]
    
    for upstream_idx in upstream_hexes:
        upstream_elev = terrain.elevations[upstream_idx]
        drop = upstream_elev - current_elev
        
        if drop > 5:  # Only erode if there's a real drop
            # Erosion inversely proportional to resistance
            erosion = migration_rate * self.age * drop / (resistance + 0.1)
            erosion = min(erosion, drop * 0.5)  # Don't over-erode
            
            # Erode the upstream lip
            terrain.elevations[upstream_idx] -= erosion
            
            # If we've eroded through soft rock to hard rock, slow down
            if erosion > 10 and soil_types[upstream_idx] in [3, 4]:  # Sandstone/Alluvial
                # Expose harder rock underneath
                soil_types[upstream_idx] = 2  # Limestone (harder)

@patch  
def _erode_pass(self: ErosionModel, base_rate: float, deposition_threshold: float):
    """Single erosion pass with knickpoint migration."""
    terrain = self.terrain
    soil_types = terrain.fields.get('soil_type', np.zeros(len(terrain.elevations), dtype=int))
    types = self.soil_system.types
    
    # Get rivers and compute power
    peaks = terrain.find_peaks(40, 1)
    rivers = [River.from_peak(terrain, p) for p in peaks]
    rivers = [r for r in rivers if r]
    rivers = River.combine_rivers(rivers)
    
    adjustments = np.zeros(len(terrain.elevations))
    deposited = np.zeros(len(terrain.elevations))
    
    for river in rivers:
        flow = river._calculate_flow()
        gradient = river._calculate_gradient()
        
        # === KNICKPOINT MIGRATION ===
        knickpoints = self._find_knickpoints(river, gradient_threshold=12.0)
        for kp in knickpoints:
            self._migrate_knickpoint(kp, river, migration_rate=0.8)
        
        # === FLUVIAL EROSION ===
        for hex_idx in river.hexes:
            power = flow[hex_idx] * gradient[hex_idx]
            
            soil_idx = soil_types[hex_idx]
            resistance = types[soil_idx].erosion_resistance
            
            erosion = base_rate * power * self.age / (resistance + 0.1)
            
            elev = terrain.elevations[hex_idx]
            
            if elev < deposition_threshold and gradient[hex_idx] < 5:
                deposited[hex_idx] += erosion * 0.3
            else:
                adjustments[hex_idx] -= erosion
                
                for neighbor in terrain.hexGrid.neighborsOf(hex_idx):
                    if neighbor >= 0 and terrain.elevations[neighbor] < elev:
                        adjustments[neighbor] -= erosion * 0.3 / (resistance + 0.1)
    
    # Apply changes
    terrain.elevations = np.clip(terrain.elevations + adjustments + deposited, 0, None)
    
    self._update_soils(adjustments, deposited)

