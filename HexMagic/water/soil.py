# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/water/soil.ipynb.

# %% auto #0
__all__ = ['SoilType', 'SoilSystem']

# %% ../../nbs/water/soil.ipynb #91bb6416
#standard
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple, deque
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

# unique
from treelib import Tree
import heapq


# %% ../../nbs/water/soil.ipynb #a00c60ae
from ..styles import StyleCSS, SVGBuilder,SVGLayer, SVGPatternLoader, preview, app, StyleDemo,NamedColor
from ..primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexWrapper, HexPosition, hexBackground,windy_edge, HexRegion, unique_windy_edge
from ..terrain import  TerraDemo, Terrain
from ..terrainpatterns import TerrainPatterns


# %% ../../nbs/water/soil.ipynb #dd61c75a
from ..voronoi import PlateKind
from ..weather import TerraDemo

# %% ../../nbs/water/soil.ipynb #d108f30a
@patch
def flow_directions(self: Terrain) -> np.ndarray:
    """Return array where each hex points to its downhill neighbor, or -1 if minimum."""
    n = len(self.elevations)
    directions = np.full(n, -1, dtype=int)
    
    for i in range(n):
        lowest = self.lowest_neighbor(i)
        if lowest is not None and self.elevations[lowest] < self.elevations[i]:
            directions[i] = lowest
    
    return directions

# %% ../../nbs/water/soil.ipynb #ab248538
@patch
def flow_diagram(self: Terrain) -> str:
    """Return array where each hex points to its downhill neighbor, or -1 if minimum."""
    n = len(self.elevations)
    overlay = ""
    style = StyleCSS("arrow", stroke="black",stroke_width=1)
    self.builder.add_style(style)

    directions = self.flow_directions()
    for i, x in enumerate(directions):
        if 0 <= x < n and self.elevations[i] > 0:
            overlay += self.hexGrid.arrow(i, x, style=style,fromMiddle=True,factor=0.1) + "\n"
    
    return overlay

# %% ../../nbs/water/soil.ipynb #5c1be915
@dataclass
class SoilType:
    """Represents a soil/bedrock type with erosion properties."""
    name: str
    bedrock: str  # Description of rock type
    erosion_resistance: float  # 0-1, higher = harder to erode
    permeability: float  # 0-1, higher = water flows through faster
    color: str  # Hex color for visualization
    
    @classmethod
    def standard_types(cls) -> List['SoilType']:
        """Five standard soil types from hard rock to sediment."""
        return [
            cls(
                name="Granite",
                bedrock="Plutonic igneous (continental crust)",
                erosion_resistance=0.9,
                permeability=0.2,
                color="#8B7355"  # Gray-brown
            ),
            cls(
                name="Basalt",
                bedrock="Volcanic igneous (oceanic crust)",
                erosion_resistance=0.85,
                permeability=0.3,
                color="#4A4A4A"  # Dark gray
            ),
            cls(
                name="Limestone",
                bedrock="Sedimentary carbonate (dissolves)",
                erosion_resistance=0.5,
                permeability=0.6,
                color="#D4C5B9"  # Light tan
            ),
            cls(
                name="Sandstone",
                bedrock="Sedimentary clastic (crumbles)",
                erosion_resistance=0.4,
                permeability=0.7,
                color="#C2B280"  # Sandy tan
            ),
            cls(
                name="Alluvial",
                bedrock="Deposited sediment (clay/silt)",
                erosion_resistance=0.1,
                permeability=0.4,
                color="#8B6914"  # Dark gold/brown
            ),
        ]

# %% ../../nbs/water/soil.ipynb #d3b0da5b
@patch
def to_nc(self: SoilType) -> NamedColor:
    return NamedColor(self.color,self.name)
   


# %% ../../nbs/water/soil.ipynb #a7ae2e7f
@dataclass
class SoilSystem:
    """Manages soil types and their distribution across terrain."""
    terrain: 'Terrain'
    types: List[SoilType]
    regions: List[HexRegion]  # One per type (index matches types)
    
    def __post_init__(self):
        """Ensure terrain has soil_type field."""
        if 'soil_type' not in self.terrain.fields:
            self.terrain.fields['soil_type'] = np.zeros(len(self.terrain.elevations), dtype=int)

    @classmethod
    def from_plates(cls, terrain: 'Terrain', plates: List['Plate'], 
                    elev_threshold: float = 50.0,
                    precip_threshold: float = 750.0,
                    debug: bool = False) -> 'SoilSystem':
        """Create soil system from plate tectonics and terrain properties.
        
        Args:
            terrain: Terrain with elevations and climate data
            plates: List of tectonic plates
            elev_threshold: Elevation below which alluvial can form (meters)
            precip_threshold: Precipitation above which limestone forms (mm/year)
            debug: Print diagnostic info
        
        Returns:
            SoilSystem with initial soil distribution
        """

        
        types = SoilType.standard_types()
        n_hexes = len(terrain.elevations)
        
        # Initialize soil_type array
        soil_type = np.zeros(n_hexes, dtype=int)
        
        # Map plates to hexes
        plate_map = {}  # hex_idx -> plate
        for plate in plates:
            for hex_idx in plate.hexes:
                plate_map[hex_idx] = plate
        
        # Ensure we have distance_to_coast
        if 'distance_to_coast' not in terrain.fields:
            terrain.compute_distance_from_coast()
        
        # Track counts for debug
        counts = {i: 0 for i in range(len(types))}
        
        for i in range(n_hexes):
            elev = terrain.elevations[i]
            
            # Ocean hexes get basalt (oceanic crust)
            if elev <= 0:
                soil_type[i] = 1  # Basalt
                counts[1] += 1
                continue
            
            # Get plate type
            plate = plate_map.get(i)
            is_oceanic = plate and plate.kind == PlateKind.oceanic
            
            # Coastal lowlands → Alluvial
            if elev < elev_threshold and terrain.fields['distance_to_coast'][i] <= 1:
                soil_type[i] = 4  # Alluvial
                counts[4] += 1
            
            # High elevation → Bedrock (Granite or Basalt from plate)
            elif elev > 1000:
                if is_oceanic:
                    soil_type[i] = 1  # Basalt
                    counts[1] += 1
                else:
                    soil_type[i] = 0  # Granite
                    counts[0] += 1
            
            # Mid elevation → Sedimentary (Limestone or Sandstone)
            else:
                # Use precipitation if available
                if 'precipitation' in terrain.fields:
                    precip = terrain.fields['precipitation'][i]
                    if precip > precip_threshold:
                        soil_type[i] = 2  # Limestone (wet)
                        counts[2] += 1
                    else:
                        soil_type[i] = 3  # Sandstone (dry)
                        counts[3] += 1
                else:
                    # Fallback: use plate type
                    if is_oceanic:
                        soil_type[i] = 2  # Limestone
                        counts[2] += 1
                    else:
                        soil_type[i] = 3  # Sandstone
                        counts[3] += 1
        
        # Store in terrain
        terrain.fields['soil_type'] = soil_type
        
        # Create regions for each type
        regions = []
        for type_idx in range(len(types)):
            hexes = set(np.where(soil_type == type_idx)[0])
            regions.append(HexRegion(hexes=hexes, hexGrid=terrain.hexGrid))
        
        if debug:
            print("\n=== SOIL SYSTEM CREATED ===")
            print(f"Total hexes: {n_hexes}")
            for i, soil_type_obj in enumerate(types):
                pct = 100 * counts[i] / n_hexes
                print(f"{soil_type_obj.name:12s}: {counts[i]:5d} hexes ({pct:5.1f}%)")
        
        return cls(terrain=terrain, types=types, regions=regions)

# %% ../../nbs/water/soil.ipynb #cd5d2f80
@patch
def soilOverlay(self:SoilSystem,f=None,smooth=False)->str:
    """ build an overlay simalar to HexGrid.styleLayer but uses plates."""
    
    aRender = self.terrain.hexGrid.builder
    sGrid = self.terrain.hexGrid
    terrain = self.terrain
    
    patGen = TerrainPatterns(self.terrain)
    cols = [x.to_nc() for x in SoilType.standard_types()]

    terrain.colorMap()
    
    # Find ocean hexes (level 0)
    ocean_hexes = terrain.find_region_at_level(0)
    ocean_region = HexRegion(hexes=ocean_hexes, hexGrid=sGrid)

    wave = patGen.wavePattern("ocean_waves_pat", 
                              amplitude=4, 
                              wavelength=16, 
                              color="#1565C0",      # stroke: medium blue
                              fill="#E3F2FD")       # fill: light blue
    oceanStyle = StyleCSS("ocean", fill=f"url(#ocean_waves_pat)")
    aRender.add_definition(wave)
    aRender.add_style(oceanStyle)


    patterns, soilStyles = patGen.namedHatchPattern(cols,stroke_width=4,spacing=8)
    
    # Add patterns to builder
    for p in patterns:
        aRender.add_definition(p)

    for s in soilStyles:
        aRender.add_style(s)

    for i, region in enumerate(self.regions):
        style = soilStyles[i]
        for h in region:
            sGrid.hexes[h].style = style

    for i in ocean_region:
        sGrid.hexes[i].style = oceanStyle
     
    ret = sGrid.styleLayerOrdered(
        styles=soilStyles,
        f=f)

    return ret
