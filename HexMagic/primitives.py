# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_primitives.ipynb.

# %% auto 0
__all__ = ['PrimitiveDemo', 'MapCord', 'MapSize', 'MapRect', 'MakeCord', 'MakeSize', 'MapPath', 'HexPosition', 'Hex', 'hexSVG',
           'hexBackground', 'HexGrid', 'HexWrapper', 'HexRegion', 'LinearGradient']

# %% ../nbs/02_primitives.ipynb 3
import numpy as np
import math


from collections import namedtuple
from dataclasses import dataclass
from fastcore.basics import patch
from bezier_interpolation import cubic_interpolation
from typing import List

from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

# %% ../nbs/02_primitives.ipynb 4
import sys
import os
import math
import random
sys.path.append(".")
sys.path.append("..")


from .styles import StyleCSS, SVGLayer, SVGBuilder, SVGPatternLoader, preview, indent,SVGDef, Generatable

# %% ../nbs/02_primitives.ipynb 6
class PrimitiveDemo:
    def __init__(self):
        self.help = ""
        

# %% ../nbs/02_primitives.ipynb 9
@dataclass(frozen=True)
class MapCord:
    x: float
    y: float

    def __str__(self):
        return f"({self.x},{self.y})"

    def __repr__(self):
        return f"({self.x},{self.y})"



    def midPoint(self,other):
        return MapCord((self.x + other.x)/2,(self.y + other.y)/2)

    def angle(self,other):
        return math.atan2(other.y - self.y, other.x - self.x)



    def toPoint(self,other):
        return MapCord(other.x - self.x ,other.y - self.y)

    def to_csv(self):
        return f"{self.x}^{self.y}"

 
    def from_csv( s:str):
        vals = s.split('^')
        return MapCord(x=float(vals[0]), y=float(vals[1]))

    def distance(self,other):
        vector =  self.toPoint(other)
        return math.sqrt(vector.x * vector.x  + vector.y * vector.y)

    def midOff(self,other,distance):
        """Calculate a point perpendicular to the line segment between two points.
    
    This function finds the midpoint between self and other, then moves 
    perpendicular to the line by the specified distance. Useful for creating
    offset curves and adding variation to straight lines (e.g., river meandering).
    
    Args:
        other (MapCord): The other endpoint of the line segment
        distance (float): How far to offset perpendicular to the line (can be negative)
        
    Returns:
        MapCord: A point perpendicular to the midpoint at the given distance,
                or MapCord(-1, -1) if self and other are identical
    
    Example:
        p1 = MapCord(0, 0)
        p2 = MapCord(10, 0)
        offset = p1.midOff(p2, 5)  # Returns point above/below midpoint
    """
        length = self.distance(other)
        if length == 0:
            return MapCord(-1,-1)

        delta = self.toPoint(other)
        mid = self.midPoint(other)
        
            # Perpendicular unit vector
        Ux = -delta.y / length
        Uy = delta.x / length
        return MapCord (mid.x + Ux * distance, mid.y + Uy * distance)

    


@dataclass(frozen=True)
class MapSize:
    width: float
    height: float
    def background(self,style):
        return f"<rect width=\"{self.width}\" height=\"{self.height }\" class =\"" + style.name+ "\"  />"

    def to_csv(self):
        return f"{self.width}^{self.height}"

 
    def from_csv( s:str):
        vals = s.split('^')
        return MapSize(width=float(vals[0]), height=float(vals[1]))
        

@dataclass(frozen=True)
class MapRect:
    origin: MapCord
    dimensons: MapSize


    def minX(self):
        return self.origin.x

    def minY(self):
        return self.origin.y

    def maxX(self):
        return self.origin.x + self.dimensons.width

    def maxY(self):
        return self.origin.y + self.dimensons.height

    def to_csv(self):
        return f"{self.origin.to_csv()}&{self.dimensons.to_csv()}"

 
    def from_csv( s:str):
        vals = s.split('&')
        return  MapRect(origin=MapCord.from_csv(vals[0]),dimensons=MapSize.from_csv(vals[1]))


def MakeCord(x):
    return MapCord(x[0],x[1])
    
def MakeSize(x):
    return MapSize(x[0],x[1])

# %% ../nbs/02_primitives.ipynb 12
class MapPath:
    def __init__(self,points,style = StyleCSS("blank")):

        self.points = [x if isinstance(x, MapCord) else MakeCord(x) for x in points]
        self.style = style
    

    def drawPloy(self , adds = ""):
        path_data = "\n<path d=\""
        for i, point in enumerate(self.points):
            if i == 0:
                path_data += f"M {point.x:.1f} {point.y:.1f}"
            else:
                path_data += (f" L {point.x:.1f} {point.y:.1f}")
        path_data += "\" class =\"" + self.style.name + f"\"  {adds} />\n"
        return path_data
    
    def drawSpline(self,adds = ""):
        path_spline = "\n<path d=\""
        xN = np.array([])
        yN = np.array([])
        
        for i, point in enumerate(self.points):
            xN = np.append(xN, point.x)
            yN = np.append(yN, point.y)
    
            if i == 0:
                path_spline += f"M {point.x:.1f} {point.y:.1f}"
    
        c_data = {"x": xN, "y": yN}
        c_data = list(zip(c_data["x"], c_data["y"]))
        c_interpolated_data = cubic_interpolation(c_data)

        line = ""

        for i, point in enumerate(c_interpolated_data):
            x, y = point
            if i > 0:
                if i % 3 == 1:
                    line += f" C"
                line += f" {x:.1f} {y:.1f}"
            if len(line)>50:
                path_spline += line + "\n\t"
                line = ""

        path_spline += line
        
        if len(adds) > 2:
            path_spline += f"\"  {adds} />\n"

        else:
            path_spline += "\" class =\"" + self.style.name+ f"\" />\n"
        return indent(path_spline)

    def svg(self,adds = ""):
        return self.drawSpline(adds)

    def from_boundary( points: list[tuple[float, float]], style=None) -> 'MapPath':
        """Factory method to create a closed boundary path from coordinate tuples.
        
        Args:
            points: List of (x, y) tuples
            style: Optional StyleCSS, defaults to blank
            
        Returns:
            MapPath with points converted to MapCord
        """
        if style is None:
            style = StyleCSS("blank")
        path = MapPath(points, style)
        return path.closed()  # Use existing closed() method

    # Also add to_svg_path for easy SVG generation 
    def to_svg_path(self, close: bool = True) -> str:
        """Generate just the path 'd' attribute string."""
        if not self.points:
            return ""
        
        path_data = f"M {self.points[0].x:.1f},{self.points[0].y:.1f}"
        for point in self.points[1:]:
            path_data += f" L {point.x:.1f},{point.y:.1f}"
        
        if close:
            path_data += " Z"
        
        return path_data



# %% ../nbs/02_primitives.ipynb 13
@patch
def length(self: MapPath) -> float:
    """Calculate total path length"""
    total = 0
    for i in range(len(self.points) - 1):
        total += self.points[i].distance(self.points[i + 1])
    return total

@patch
def reverse(self: MapPath) -> MapPath:
    """Return reversed path"""
    return MapPath(list(reversed(self.points)), self.style)

@patch
def subsample(self: MapPath, num_points: int) -> MapPath:
    """Resample path to have specific number of points"""
    if num_points < 2 or len(self.points) < 2:
        return self
    
    total_length = self.length()
    segment_length = total_length / (num_points - 1)
    
    new_points = [self.points[0]]
    current_dist = 0
    target_dist = segment_length
    
    for i in range(len(self.points) - 1):
        p1 = self.points[i]
        p2 = self.points[i + 1]
        seg_length = p1.distance(p2)
        
        while target_dist <= current_dist + seg_length:
            t = (target_dist - current_dist) / seg_length
            new_points.append(p1.lerp(p2, t))
            target_dist += segment_length
            
        current_dist += seg_length
    
    new_points.append(self.points[-1])
    return MapPath(new_points[:num_points], self.style)

@patch
def smooth(self: MapPath, iterations: int = 1) -> MapPath:
    """Smooth path using average of neighbors"""
    if len(self.points) < 3:
        return self
    
    points = list(self.points)
    for _ in range(iterations):
        new_points = [points[0]]
        for i in range(1, len(points) - 1):
            avg_x = (points[i-1].x + points[i].x + points[i+1].x) / 3
            avg_y = (points[i-1].y + points[i].y + points[i+1].y) / 3
            new_points.append(MapCord(avg_x, avg_y))
        new_points.append(points[-1])
        points = new_points
    
    return MapPath(points, self.style)

@patch
def add_noise(self: MapPath, amount: float, seed: int = None) -> MapPath:
    """Add random noise to path for organic appearance"""
    if seed is not None:
        random.seed(seed)
    
    new_points = []
    for point in self.points:
        offset_x = (random.random() - 0.5) * amount * 2
        offset_y = (random.random() - 0.5) * amount * 2
        new_points.append(MapCord(point.x + offset_x, point.y + offset_y))
    
    return MapPath(new_points, self.style)

@patch
def closed(self: MapPath) -> MapPath:
    """Return closed version of path (adds first point to end if not already closed)"""
    if self.points[0].distance(self.points[-1]) < 0.01:
        return self
    return MapPath(self.points + [self.points[0]], self.style)

@patch
def make_windy(self: MapPath, iterations: int = 1, offset_factor: float = 0.15, 
               seed: int = None, vary_direction: bool = True) -> MapPath:
    """Make path more windy by recursively adding perpendicular offsets at midpoints.
    
    This method works by:
    1. For each pair of consecutive points, find the midpoint
    2. Calculate a perpendicular offset at that midpoint
    3. Insert the offset point into the path
    4. Repeat for specified number of iterations
    
    Args:
        iterations: Number of subdivision iterations (more = more curves)
        offset_factor: How far to offset as fraction of segment length (0.0-0.5)
                      Default 0.15 gives gentle curves, 0.3+ gives dramatic curves
        seed: Random seed for reproducible results. If None, uses alternating offsets
        vary_direction: If True and seed is None, alternates offset direction for
                       natural meandering. If False, offsets are consistent.
    
    Returns:
        New MapPath with windy characteristics
    
    Example:
        # Gentle meandering river
        river = MapPath([(0, 0), (100, 0), (200, 50)], river_style)
        windy_river = river.make_windy(iterations=2, offset_factor=0.2)
        
        # Dramatic serpentine path
        snake = path.make_windy(iterations=3, offset_factor=0.35, seed=42)
    """
    if len(self.points) < 2:
        return self
    
    if seed is not None:
        random.seed(seed)
    
    points = list(self.points)
    
    for iteration in range(iterations):
        new_points = [points[0]]  # Keep first point
        
        for i in range(len(points) - 1):
            p1 = points[i]
            p2 = points[i + 1]
            
            # Calculate offset distance based on segment length
            segment_length = p1.distance(p2)
            offset_distance = segment_length * offset_factor
            
            # Determine offset direction
            if seed is not None:
                # Random offset direction
                offset_distance *= random.choice([-1, 1])
            elif vary_direction:
                # Alternate direction for natural meandering
                # Use both iteration and segment index for variation
                direction = 1 if ((i + iteration) % 2 == 0) else -1
                offset_distance *= direction
            # else: consistent direction (always positive)
            
            # Use the existing midOff method which calculates perpendicular offset
            mid_point = p1.midOff(p2, offset_distance)
            
            # Handle edge case where points are identical
            if mid_point.x == -1 and mid_point.y == -1:
                mid_point = p1.midPoint(p2)
            
            new_points.append(mid_point)
            new_points.append(p2)
        
        points = new_points
    
    return MapPath(points, self.style)

@patch
def make_windy_variable(self: MapPath, iterations: int = 1, 
                         offset_min: float = 0.05, offset_max: float = 0.25,
                         seed: int = None) -> MapPath:
    """Make path windy with variable offset amounts for more organic appearance.
    
    Similar to make_windy but each subdivision uses a random offset factor
    within the specified range, creating more natural variation.
    
    Args:
        iterations: Number of subdivision iterations
        offset_min: Minimum offset as fraction of segment length
        offset_max: Maximum offset as fraction of segment length
        seed: Random seed for reproducible results
    
    Returns:
        New MapPath with organic windy characteristics
    """
    if len(self.points) < 2:
        return self
    
    if seed is not None:
        random.seed(seed)
    
    points = list(self.points)
    
    for iteration in range(iterations):
        new_points = [points[0]]
        
        for i in range(len(points) - 1):
            p1 = points[i]
            p2 = points[i + 1]
            
            segment_length = p1.distance(p2)
            
            # Random offset factor for this segment
            offset_factor = random.uniform(offset_min, offset_max)
            offset_distance = segment_length * offset_factor * random.choice([-1, 1])
            
            mid_point = p1.midOff(p2, offset_distance)
            
            if mid_point.x == -1 and mid_point.y == -1:
                mid_point = p1.midPoint(p2)
            
            new_points.append(mid_point)
            new_points.append(p2)
        
        points = new_points
    
    return MapPath(points, self.style)

# %% ../nbs/02_primitives.ipynb 14
@patch
def drawClosed(self: MapPath, adds: str = "") -> str:
    """Draw closed polygon"""
    path_data = "\n<path d=\""
    for i, point in enumerate(self.points):
        if i == 0:
            path_data += f"M {point.x:.1f} {point.y:.1f}"
        else:
            path_data += f" L {point.x:.1f} {point.y:.1f}"
    path_data += " Z"  # Close path
    path_data += f"\" class=\"{self.style.name}\" {adds} />\n"
    return path_data

@patch
def bounds(self: MapPath) -> MapRect:
    """Get bounding rectangle of path"""
    if not self.points:
        return MapRect(MapCord(0, 0), MapSize(0, 0))
    
    min_x = min(p.x for p in self.points)
    max_x = max(p.x for p in self.points)
    min_y = min(p.y for p in self.points)
    max_y = max(p.y for p in self.points)
    
    return MapRect(
        MapCord(min_x, min_y),
        MapSize(max_x - min_x, max_y - min_y)
    )

# %% ../nbs/02_primitives.ipynb 15
@patch
def with_arrowhead(self: MapPath, arrow_size: float = 10, arrow_angle: float = 25, shouldFill = True) -> str:
    """Draw path with an arrowhead at the end.
    
    Args:
        arrow_size: Length of the arrowhead lines
        arrow_angle: Angle of arrowhead in degrees (from path direction)
    
    Returns:
        SVG path string including the arrowhead
    """
    if len(self.points) < 2:
        return self.svg()
    
    # Get the last two points to determine arrow direction
    p1 = self.points[-2]
    p2 = self.points[-1]
    
    # Calculate angle of the line
    angle = p1.angle(p2)
    
    # Convert arrow angle to radians
    arrow_rad = math.radians(arrow_angle)
    
    # Calculate the two arrowhead points
    left_angle = angle + math.pi - arrow_rad
    right_angle = angle + math.pi + arrow_rad
    
    left_point = MapCord(
        p2.x + arrow_size * math.cos(left_angle),
        p2.y + arrow_size * math.sin(left_angle)
    )
    
    right_point = MapCord(
        p2.x + arrow_size * math.cos(right_angle),
        p2.y + arrow_size * math.sin(right_angle)
    )
    
    # Draw main path
    result = self.svg()
    if shouldFill:
        stroke = self.style.properties["stroke"]
        result += f'\n<polygon points="{left_point.x:.1f},{left_point.y:.1f} {p2.x:.1f},{p2.y:.1f} {right_point.x:.1f},{right_point.y:.1f}" class="{self.style.name}"  style="fill: {stroke};"/>'

        

    else:
        
        # Add arrowhead lines
        result += f'\n<polygon points="{left_point.x:.1f},{left_point.y:.1f} {p2.x:.1f},{p2.y:.1f} {right_point.x:.1f},{right_point.y:.1f}" class="{self.style.name}" />'

    
    return result

# %% ../nbs/02_primitives.ipynb 20
@dataclass
class HexPosition:
    q: int = 0  # cube coordinate
    r: int = 0  # cube coordinate
    s: int = 0  # cube coordinate (always q + r + s = 0)
    label: str = ""

    @classmethod 
    def direction(cls,lbl):
        theDirs = {"E":(1, 0, -1),"NE":(1, -1, 0),"NW":(0, -1, 1),
        "W":(-1, 0, 1),"SW":(-1, 1, 0), "SE":(0, 1, -1)}
        (q, r, s ) = theDirs[lbl]

        return cls(q, r, s, label=lbl) 

    @classmethod
    def origin(cls)->'HexPosition':
        return HexPosition(0,0,0,"origin")
   
    @classmethod
    def directions(cls):

        
        labels = ["SW","W","NW", "NE", "E", "SE"]
        return [cls.direction(lbl) for lbl in labels]

    @staticmethod
    def _cube_round(q: float, r: float, s: float) -> 'HexPosition':
        """Round fractional cube coordinates to nearest hex"""
        rq = round(q)
        rr = round(r)
        rs = round(s)
        
        q_diff = abs(rq - q)
        r_diff = abs(rr - r)
        s_diff = abs(rs - s)
        
        if q_diff > r_diff and q_diff > s_diff:
            rq = -rr - rs
        elif r_diff > s_diff:
            rr = -rq - rs
        else:
            rs = -rq - rr
        
        return HexPosition(rq, rr, rs)

    
    def __add__(self, other: 'HexPosition') -> 'HexPosition':
        return HexPosition(self.q + other.q, self.r + other.r, self.s + other.s)

    
    def rotate_left(self) -> 'HexPosition':
        """Rotate 60 degrees counter-clockwise around origin"""
        return HexPosition(-self.s, -self.q, -self.r)


    def rotate_right(self) -> 'HexPosition':
        """Rotate 60 degrees clockwise around origin"""
        return HexPosition(-self.r, -self.s, -self.q)


    def neighbor(self, direction: int) -> 'HexPosition':
        """Get neighbor in direction (0-5, starting East and going counter-clockwise)"""
        directions = HexPosition.directions()
        return self + directions[direction % 6]

    
    
    def ring(self, radius: int) -> list['HexPosition']:
        """Generate all HexPositions in a ring at given radius from center."""
        if radius == 0:
            return [self]
        
        results = []
        
        # Start at "radius" steps in direction 4 (SW)
        directions = HexPosition.directions()
        current = self
        east = HexPosition.direction("E")
        for _ in range(radius):
            current = current + east  # Move east to starting corner
        
        i = 0
        # Walk around the 6 edges
        for direction_idx in range(6):
            direction = directions[direction_idx]
            for step in range(radius):
                results.append(current.copy(f"{radius}.{i}"))
                current = current + direction
                i += 1
        
        return results

    def copy(self,label:None):
        if label is None:
            label = self.label
        return HexPosition(self.q,self.r,self.s,label)

    @property
    def cube_coords(self):
        return (self.q, self.r, self.s)
    
    def encode(self) -> str:
        """Encode as string like '2^3' (ring^position)"""
        return f"{self.q}^{self.r}^{self.s}"

   
    
    def pixel(self, hex_radius: float, center: MapCord) -> tuple[float, float]:
        """Convert HexPosition cube coordinates to pixel position for pointy-top hex."""
        x = hex_radius * (math.sqrt(3) * self.q + math.sqrt(3)/2 * self.r)
        y = hex_radius * (3/2 * self.r)
        return MapCord(center.x + x, center.y + y)
    
    @staticmethod
    def decode(s: str) -> 'HexPosition':
        """Decode from string like '2^3'"""
        vals = s.split('^')
        return HexPosition(q=int(vals[0]), r=int(vals[1]),s=int(vals[2]))

# %% ../nbs/02_primitives.ipynb 22
@patch
def distance(self: HexPosition, other: HexPosition) -> int:
        """Cube coordinate distance"""
        return (abs(self.q - other.q) + abs(self.r - other.r) + abs(self.s - other.s)) // 2

@patch
def closest_in_ring(self: HexPosition, root: 'HexPosition', radius: int) -> 'HexPosition':
    """Find the hex in the given ring (centered at root) closest to self.
    If there's a tie, returns the one that appears first in clockwise order."""
    ring_hexes = root.ring(radius)
    
    if not ring_hexes:
        return root
    
    # Find minimum distance
    min_dist = min(self.distance(h) for h in ring_hexes)
    
    # Return first hex with that distance (earliest in clockwise order)
    for hex_pos in ring_hexes:
        if self.distance(hex_pos) == min_dist:
            return hex_pos
    
    return ring_hexes[0]  # Fallback

# %% ../nbs/02_primitives.ipynb 23
@patch
def radial_path_to(self: HexPosition, center: HexPosition) -> list[HexPosition]:
    """Return path that goes through one hex per ring, moving toward center.
    Each step picks the closest hex in the next inner ring."""
    
    start_ring = self.distance(center)
    if start_ring == 0:
        return [self]
    
    path = [self]
    current = self
    
    # Move inward one ring at a time
    for ring_num in range(start_ring - 1, -1, -1):
        # Find closest hex in this ring to our current position
        next_hex = current.closest_in_ring(center, ring_num)
        path.append(next_hex)
        current = next_hex
    
    return path

@patch
def path_through_waypoints(self: HexPosition, waypoints: list[HexPosition], destination: HexPosition) -> list[HexPosition]:
    """Create a path from self through all waypoints toward destination.
    Each segment moves through rings relative to destination.
    NOTE: waypoints should be in progressively tighter rings toward destination."""
    if not waypoints:
        return self.radial_path_to(destination)
    
    full_path = []
    current = self
    
    # Go through each waypoint
    for waypoint in waypoints:
        segment = current.radial_path_to(waypoint)
        # Add segment, but skip first point if it's a duplicate
        if full_path and segment and full_path[-1].cube_coords == segment[0].cube_coords:
            full_path.extend(segment[1:])
        else:
            full_path.extend(segment)
        current = waypoint
    
    # Final segment from last waypoint to destination
    final_segment = current.radial_path_to(destination)
    if full_path and final_segment and full_path[-1].cube_coords == final_segment[0].cube_coords:
        full_path.extend(final_segment[1:])
    else:
        full_path.extend(final_segment)
    
    return full_path

# %% ../nbs/02_primitives.ipynb 24
@patch
def rotate_left(self: HexPosition, i: int = 1) -> HexPosition:
    """Rotate 60 degrees counter-clockwise around origin, i times"""
    result = self
    for _ in range(i % 6):  # Only need 6 rotations to return to start
        result = HexPosition(-result.s, -result.q, -result.r)
    return result

@patch
def rotate_right(self: HexPosition, i: int = 1) -> HexPosition:
    """Rotate 60 degrees clockwise around origin, i times"""
    result = self
    for _ in range(i % 6):
        result = HexPosition(-result.r, -result.s, -result.q)
    return result

# %% ../nbs/02_primitives.ipynb 25
@patch
def line_to(self: HexPosition, other: HexPosition) -> list[HexPosition]:
    """Get line of hexes from self to other using linear interpolation"""
    n = self.distance(other)
    if n == 0:
        return [self]
    
    results = []
    for i in range(n + 1):
        t = i / n if n > 0 else 0
        # Lerp in cube coordinates
        q = self.q + (other.q - self.q) * t
        r = self.r + (other.r - self.r) * t
        s = self.s + (other.s - self.s) * t
        
        # Round to nearest hex
        results.append(HexPosition._cube_round(q, r, s))
    
    return results


@patch
def spiral(self: HexPosition, radius: int) -> list[HexPosition]:
    """Get all hexes in spiral pattern from center out to radius"""
    results = [self]
    for r in range(1, radius + 1):
        results.extend(self.ring(r))
    return results

@patch
def __repr__(self: HexPosition) -> str:
    """Better string representation"""
    if self.label:
        return f"HexPosition({self.q}, {self.r}, {self.s}, '{self.label}')"
    return f"HexPosition({self.q}, {self.r}, {self.s})"

# %% ../nbs/02_primitives.ipynb 27
@patch
def move_in(self: HexPosition, center: HexPosition) -> HexPosition:
    """Move one step toward center using line interpolation."""
    if self.distance(center) == 0:
        return self
    
    path = self.line_to(center)
    # path[0] is self, path[1] is the next step toward center
    return path[1] if len(path) > 1 else self


@patch
def move_out(self: HexPosition, center: HexPosition) -> HexPosition:
    """Move one step away from center (opposite direction of move_in)."""
    # Calculate the vector from center to self
    direction_q = self.q - center.q
    direction_r = self.r - center.r
    direction_s = self.s - center.s
    
    # Extend in that direction
    next_pos = HexPosition(
        self.q + direction_q,
        self.r + direction_r,
        self.s + direction_s
    )


# %% ../nbs/02_primitives.ipynb 34
class Hex:
    radius: float
    center: MapCord
    style: StyleCSS

    def __init__(self,
        radius: float, #how far away are the vertexes
        center: MapCord, #where it is located
        style: StyleCSS = None, #how will it look
        label: str = "",
        labelStyle = ""
        ):
        self.radius = radius
        self.center = MapCord(round(center.x,2),round(center.y,2))
        self.style = style
        self.label = label
        self.labelStyle = labelStyle
        
        width = self.radius * math.cos(0) * 2
        self.bounds = MapSize(width,self.radius * 2 )

        #cache the vertices
        vertices = []
                
        for i in range(6):
            angle = (i * 60 - 30) * math.pi / 180  # Start at top vertex
            x = round(self.center.x + self.radius * math.cos(angle),2)
            y = round(self.center.y + self.radius* math.sin(angle),2)
            
            vertices.append(MapCord(x, y))
        self.v = vertices
      
    
    def vertices(self) -> List[MapCord]:
        """Get the vertices of a hexagon centered at (center_x, center_y)."""
        return self.v
    
    def contains(self, point: MapCord) -> bool:
        """Check if a point is inside a hexagon."""
        distance = math.sqrt((point.x - self.center.x)**2 + (point.y - self.center.y)**2)
        return distance <= self.radius * 0.9
    
    def svg(self,attrs=None) -> str:
        ret = "<polygon points=\""
        for point in self.vertices():
            ret += f"{point.x:.0f},{point.y:.0f} "
        ret += f"\" class=\"{self.style.name}\""
        if attrs is not None:
            for key, value in attrs.items():
                ret += f" {key}=\'{value}\'"

        ret += "/>"
        return ret

    def angle(self, other: 'Hex') -> float:
        """Calculate angle from this hex to another hex"""
        return math.atan2(other.center.y - self.center.y, other.center.x - self.center.x)

    def right(self):
        center = MapCord(self.center.x + self.bounds.width, self.center.y)
        return Hex(self.radius,center,self.style)

# %% ../nbs/02_primitives.ipynb 36
@patch
def edges(self: Hex) -> set[tuple[int, int, int, int]]:
    """Return the edges of the hexagon as a set of normalized tuples (x1, y1, x2, y2).
    Each edge is normalized so that x1 < x2, or if x1 == x2 then y1 <= y2.
    Coordinates are converted to ints for set operations."""
    edges = set()
    vertices = self.vertices()
    
    for i in range(6):
        # Get current vertex and next vertex (wrapping around)
        v1 = vertices[i]
        v2 = vertices[(i + 1) % 6]
        
        # Convert to ints
        x1, y1 = int(v1.x), int(v1.y)
        x2, y2 = int(v2.x), int(v2.y)
        
        # Normalize the edge
        if x1 < x2:
            edge = (x1, y1, x2, y2)
        elif x1 > x2:
            edge = (x2, y2, x1, y1)
        else:  # x1 == x2
            if y1 <= y2:
                edge = (x1, y1, x2, y2)
            else:
                edge = (x2, y2, x1, y1)
        
        edges.add(edge)
    
    return edges


# %% ../nbs/02_primitives.ipynb 37
@patch
def verticalStretch(self: Hex, size: MapSize, attrs=None) -> str:
    
    ydelta = (size.height - 2 * self.radius)/2
    stretchV = []
    for vertex in self.v:
        addMe = vertex
        if vertex.y > self.center.y:
            addMe = MapCord(vertex.x, vertex.y + ydelta)
        else:
            addMe = MapCord(vertex.x, vertex.y - ydelta)
        
        
        stretchV.append(addMe)
        

    ret = "<polygon points=\""
    for point in stretchV:
        ret += f"{point.x:.0f},{point.y:.0f} "
    ret += f"\" class=\"{self.style.name}\""
    if attrs is not None:
        for key, value in attrs.items():
            ret += f" {key}=\'{value}\'"

    ret += "/>"
    return ret

# %% ../nbs/02_primitives.ipynb 38
def hexSVG(size:MapSize,levels = 2, pad=5, fill="#f4edb2ff",eles=StyleCSS.elevations()):
    myStyles = []
    radius = size.width/2
    center = MapCord(radius,size.height/2)
    
    canvas = ""
    hexRadius = radius
    polySize = MapSize(size.width,size.height)
    
    for i in range(levels):
        aStyle = eles[i]
        myStyles.append(aStyle)
        aHex = Hex(radius=hexRadius-4,center=center,style=aStyle)
        debug = aHex.verticalStretch(polySize)
        #print(f"round {i},{aHex.center} radius{aHex.radius},siz:{polySize}",debug)
        canvas += debug
        polySize = MapSize(polySize.width-pad*2,polySize.height-pad*2)
        hexRadius -= pad
        canvas += "\n"

    aStyle = StyleCSS("Snow",fill=fill)
    
    myStyles.append(aStyle)
    aHex = Hex(radius=hexRadius-4,center=center,style=aStyle)
    canvas += aHex.verticalStretch(polySize)
    
    sheet  = Style("\n ".join([x.__str__() for x in myStyles]) )
    #hSVG =  embedSVG(sheet + canvas,size=size)
    retRender = SVGBuilder()
    retRender.width = size.width
    retRender.height = size.height
    for x in myStyles:
        retRender.add_style(x)

    retRender.updateLayers([canvas])
    return Div(NotStr(retRender.xml()),style="""
                width: 100%; 
                height: 100%; 
                position: absolute; 
                filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.3));
                transition: all 0.2s ease;
             display: flex;
            justify-content: center;
                """)
    



# %% ../nbs/02_primitives.ipynb 41
def hexBackground( content=None,levels = 2, pad=5,fill="#f4edb2ff",size=MapSize(300,300)):
     return Div(
        hexSVG(size,levels,pad,fill),
   Div(content, style="position: relative; z-index: 1;"),
        style=f"""
            position: relative; 
            width: {size.width}px; 
            height: {size.height}px;
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        """
     )


# %% ../nbs/02_primitives.ipynb 42
@patch
def demoHexBackground(self:PrimitiveDemo):
    a = hexBackground(P("hi"),size=MapSize(300,700))
    return a


# %% ../nbs/02_primitives.ipynb 45
@patch
def hexIcon(self: SVGBuilder, size: int) -> str:
    """Generate hex-shaped icon cropped from center of SVG."""
    cx, cy = self.width / 2, self.height / 2
    
    # Find largest hex that fits in original image
    # For pointy-top: width = r*√3, height = r*2
    # So: r = min(width/√3, height/2)
    max_radius = min(self.width / math.sqrt(3), self.height / 2)
    
    # Hex bounding box in original coordinates
    hex_width = max_radius * math.sqrt(3)
    hex_height = max_radius * 2
    vb_x = cx - hex_width / 2
    vb_y = cy - hex_height / 2
    
    # Clip path hex - coordinates in original space
    aHex = Hex(radius=max_radius, center=MapCord(cx, cy), style=StyleCSS("hex"))
    clipDef = SVGDef("clipPath", "hex-clip", aHex.verticalStretch(size=MapSize(hex_width, hex_height)))  # just the polygon points
    self.add_definition(clipDef)
    
    # Output maintains hex aspect ratio
    out_width = size * math.sqrt(3) / 2  # ~0.866 * size
    out_height = size
    
    viewBox = f"{vb_x} {vb_y} {hex_width} {hex_height}"
    
    return f'''<?xml version='1.0' encoding='utf-8'?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="{out_width:.1f}" 
     height="{out_height}"
     viewBox="{viewBox}">
{self._header()}
<g clip-path="url(#hex-clip)">
{self.body}
</g>
</svg>'''

# %% ../nbs/02_primitives.ipynb 48
class HexGrid:
    """Perfect hexagonal grid using geohexgrid library."""

    def pointy_top_hex_to_cartesian(self, row, col, style) -> Hex:
        """
        Calculates the centroid (x, y) for a pointy-top hex grid.
        
        Args:
            row (int): The row index of the hexagon.
            col (int): The column index of the hexagon.
            radius (float): The radius of the hexagon (center to vertex).
        
        Returns:
            tuple: The (x, y) coordinates of the centroid.
        """
        width = math.sqrt(3) * self.radius
        height = 2 * self.radius
        
        x = width * (col + 0.5 * (row % 2))  
        y = height * 0.75 * row
        
        # Apply offset
        x += self.offset.x
        y += self.offset.y
        
        return Hex(self.radius, MapCord(x, y), style)

    def adjustRadius(self, radius):
        self.radius = radius
        self.hexes = []
        for row in range(self.nRows):
            for col in range(self.nCols):
                aHex = self.pointy_top_hex_to_cartesian(row, col, self.style)
                self.hexes.append(aHex)

        exportSize = MapSize(max([hex.center.x for hex in self.hexes]),
        max([hex.center.y for hex in self.hexes]))
        self.builder.width = exportSize.width
        self.builder.height = exportSize.height

    def __init__(self, 
        bounds: MapRect,  # how big are we
        style: StyleCSS,  # the default style for a hex
        radius: float = 25.0,  # the radius of each of the hexes
        offset: MapCord = None  # offset for positioning the grid
    ):
        self.radius = radius
        self.offset = offset if offset is not None else MapCord(0, 0)

        self.builder = SVGBuilder()
        self.builder.add_style(style)
        for x in StyleCSS.elevations():
            self.builder.add_style(x)
        self.style = style

        self.nRows = int(bounds.dimensons.height / radius)
        self.nCols = int(bounds.dimensons.width / radius)
        self.adjustRadius(radius)
        
        
    @property
    def bounds(self):
        return MapRect(
            self.hexes[0].center,
            MapSize(width=self.nCols * self.radius, height=self.nRows * self.radius)
        )

    @classmethod
    def create_centered(cls, n: int, radius: float, style: StyleCSS):
        width = math.sqrt(3) * radius
        height = 2 * radius
        
        total_width = width * n + 2 * radius
        total_height = height * 0.75 * (n - 1) + height + 2 * radius
        
        bounds = MapRect(MapCord(0, 0), MapSize(total_width, total_height))
        
        # Offset by radius to prevent clipping
        offset = MapCord(radius, radius)
        
        grid = cls(bounds, style, radius, offset)
        grid.nRows = n
        grid.nCols = n
        grid.adjustRadius(radius)
        
        return grid





    def text(self, cb=lambda s, i: i):
        i = 0
        for row in range(self.nRows):
            line = "|"
            for col in range(self.nCols):
                line += f" {cb(self, i):5}"
                i += 1
            print(line + " |")

    def rowPartity(self, index):
        "This returns whether a row is even or odd"
        return int(index / self.nCols) % 2


# %% ../nbs/02_primitives.ipynb 50
@patch
def index_to_row_col(self: HexGrid, index: int) -> tuple[int, int]:
    """Convert flat grid index to (row, col)."""
    row = index // self.nCols
    col = index % self.nCols
    return row, col

@patch
def row_col_to_index(self: HexGrid, row: int, col: int) -> int:
    """Convert (row, col) to flat grid index. Returns -1 if out of bounds."""
    if row < 0 or row >= self.nRows or col < 0 or col >= self.nCols:
        return -1
    return row * self.nCols + col

@patch
def index_to_hexposition(self: HexGrid, index: int, origin_index: int = None) -> HexPosition:
    """Convert grid index to HexPosition relative to origin_index."""

    if origin_index is None:
        origin_index = int(len(self.hexes)/2)
        
    # Convert both indices to row/col
    row, col = self.index_to_row_col(index)
    origin_row, origin_col = self.index_to_row_col(origin_index)
    
    # Convert to cube coordinates (odd-r offset)
    q = col - (row - (row & 1)) // 2
    r = row
    s = -q - r
    
    origin_q = origin_col - (origin_row - (origin_row & 1)) // 2
    origin_r = origin_row
    origin_s = -origin_q - origin_r
    
    # Return relative position
    return HexPosition(q - origin_q, r - origin_r, s - origin_s)

@patch
def hexposition_to_index(self: HexGrid, hexpos: HexPosition, origin_index:int = None) -> int:
    if origin_index is None:
        origin_index = int(len(self.hexes)/2)
    """Convert HexPosition (relative to origin) back to grid index.
    Returns -1 if out of bounds."""
    # Get origin's cube coordinates
    origin_row, origin_col = self.index_to_row_col(origin_index)
    origin_q = origin_col - (origin_row - (origin_row & 1)) // 2
    origin_r = origin_row
    origin_s = -origin_q - origin_r
    
    # Add relative position to origin
    abs_q = hexpos.q + origin_q
    abs_r = hexpos.r + origin_r
    abs_s = hexpos.s + origin_s
    
    # Convert cube back to odd-r offset
    row = abs_r
    col = abs_q + (abs_r - (abs_r & 1)) // 2
    
    # Convert to index and check bounds
    return self.row_col_to_index(row, col)

# %% ../nbs/02_primitives.ipynb 51
@patch
def neighborsOf(self: HexGrid, index: int,ring=1) -> list[int]:
    """Get all valid neighbor indices using HexPosition."""
    ring_hexpositions = HexPosition(0, 0, 0).ring(ring)
    neighbor_indices = [self.hexposition_to_index(hp, index) for hp in ring_hexpositions]
    return [i for i in neighbor_indices if i >= 0]  # Filter out-of-bounds

# %% ../nbs/02_primitives.ipynb 52
@patch
def arrow(self: HexGrid, start:int, end:int, style = StyleCSS("arrow", stroke="black",stroke_width=1)) -> str:
    self.builder.add_style(style)
    
    # Get centers
    start_center = self.hexes[start].center
    end_center = self.hexes[end].center
    
    # Calculate point at 25% along the way
    start_x = start_center.x + 0.25 * (end_center.x - start_center.x)
    start_y = start_center.y + 0.25 * (end_center.y - start_center.y)
    start_point = MapCord(start_x, start_y)
    
    # Calculate point at 75% along the way
    end_x = start_center.x + 0.75 * (end_center.x - start_center.x)
    end_y = start_center.y + 0.75 * (end_center.y - start_center.y)
    end_point = MapCord(end_x, end_y)
    
    path = MapPath([start_point, end_point], style)
    return path.with_arrowhead()

# %% ../nbs/02_primitives.ipynb 55
class HexWrapper:
    """This class stores svg configuration. """
    def __init__(self,
    header:str = "", # goes in front of the body 
    footer: str = "", # goes in the back
    callBack = lambda grid,index: None #how individual cells are called back
    ):
        self.header = ""
        self.footer = ""
        self.callBack = callBack

    def route(path:str= "/hex_clicked",target:str="#map"):
        return lambda grid,index :  {
        "hx-post": f"{path}", #The post gives the route back to the url
        "hx-vals": f'{{"hex_id":{index}}}', # the parameter needs to be called the same in the route
        "hx-target": f"{target}" # the element we need to update
    }

# %% ../nbs/02_primitives.ipynb 58
@dataclass
class HexRegion:
    """A set of adjacent hexes with computed perimeter boundaries."""
    hexes: set[int]  # Set of hex indices
    hex_grid: 'HexGrid'  # Reference to get hex objects
    
    def __post_init__(self):
        self._boundaries = None  # Cached list of MapPath
    
    def _vertex_key(self, v) -> tuple[int, int]:
        """Convert vertex to integer key for reliable hashing."""
        # Multiply by scale factor before rounding to preserve precision
        return int(v.x), int(v.y)
    
    def _key_to_point(self, key) -> MapCord:
        """Convert integer key back to float coordinates."""
        return MapCord(key[0] , key[1])
    
    def centroid_hex(self) -> int:
        """Return the hex index closest to the geometric center."""
        if not self.hexes:
            return None
        
        # Calculate centroid of all hex centers
        cx, cy = 0, 0
        for idx in self.hexes:
            h = self.hex_grid.hexes[idx]
            cx += h.center.x
            cy += h.center.y
        cx /= len(self.hexes)
        cy /= len(self.hexes)
        
        # Find hex closest to centroid
        closest = None
        min_dist = float('inf')
        for idx in self.hexes:
            h = self.hex_grid.hexes[idx]
            dist = (h.center.x - cx)**2 + (h.center.y - cy)**2
            if dist < min_dist:
                min_dist = dist
                closest = idx
        return closest
    
    def perimeter(self) -> [MapCord]:
        """Find all vertices on the perimeter using vertex counting."""
        vertex_counts = {}
        
        for idx in self.hexes:
            hex_obj = self.hex_grid.hexes[idx]
            for v in hex_obj.vertices():
                v_key = self._vertex_key(v)
                vertex_counts[v_key] = vertex_counts.get(v_key, 0) + 1
        
        # Perimeter vertices are touched by 1 or 2 hexes (not 3)
        return [self._key_to_point(k) for k, count in vertex_counts.items() if count < 3]

    @classmethod
    def fromPath(cls, grid: HexGrid, path: list[int]):
        """Create a HexRegion along a list of hex indices."""
        if not path:
            return cls(hexes=set(), hex_grid=grid)
        
        adds = set()
        
        # Process each segment of the path
        for i in range(len(path) - 1):
            start_idx = path[i]
            end_idx = path[i + 1]
            
            # Convert to HexPositions relative to start
            start_pos = grid.index_to_hexposition(start_idx, start_idx)  # (0,0,0)
            end_pos = grid.index_to_hexposition(end_idx, start_idx)
            
            # Get radial path from start to end
            hexes = start_pos.radial_path_to(end_pos)
            
            # Convert back to indices and add
            for hexpos in hexes:
                idx = grid.hexposition_to_index(hexpos, start_idx)
                if idx >= 0:  # Valid index
                    adds.add(idx)
        
        # Don't forget the last hex
        adds.add(path[-1])
        
        return cls(hexes=adds, hex_grid=grid)


# %% ../nbs/02_primitives.ipynb 59
@patch
def outside(self:HexRegion,ring=1):
    m = set()
    grid = self.hex_grid
    total = grid.nCols * grid.nRows
    for index in self.hexes:
        ring_hexpositions = HexPosition(0, 0, 0).ring(ring)
        neighbor_indices = [grid.hexposition_to_index(hp, index) for hp in ring_hexpositions]
        for neighbor in neighbor_indices:
            if neighbor >= 0 and neighbor < total and neighbor not in self.hexes:
                m.add(neighbor)
    return HexRegion(m,grid) # Filter out-of-bounds

@patch 
def apply(self:HexRegion,direction:HexPosition):
    m = set()
    grid = self.hex_grid
    total = grid.nCols * grid.nRows
    for index in self.hexes:
        #hp = HexPosition(0, 0, 0).ra(ring) + direction
        neighbor = grid.hexposition_to_index(direction, index) 
        if neighbor >= 0 and neighbor < total :
            m.add(neighbor)
    return HexRegion(m,grid)

@patch 
def shift(self:HexRegion,direction:HexPosition):
    m = set()
    grid = self.hex_grid
    total = grid.nCols * grid.nRows
    for index in self.hexes:
        #hp = HexPosition(0, 0, 0).ra(ring) + direction
        neighbor = grid.hexposition_to_index(direction, index) 
        if neighbor >= 0 and neighbor < total and neighbor not in self.hexes:
            m.add(neighbor)
    return HexRegion(m,grid)

# %% ../nbs/02_primitives.ipynb 60
@patch
def inside(self:HexRegion,ring=1):
    out = self.outside().outside()
    m = self.hexes - out.hexes
    return HexRegion(m,self.hex_grid) # Filter out-of-bounds

# %% ../nbs/02_primitives.ipynb 61
@patch
def perimeter(self: HexRegion) -> list[MapCord]:
    """Find all vertices on the perimeter using vertex counting."""
    # Track both region-hex count and total-hex count per vertex
    region_counts = {}
    total_counts = {}
    
    # Count vertices from region hexes
    for idx in self.hexes:
        hex_obj = self.hex_grid.hexes[idx]
        for v in hex_obj.vertices():
            v_key = self._vertex_key(v)
            region_counts[v_key] = region_counts.get(v_key, 0) + 1
    
    # Count vertices from ALL grid hexes to know total possible
    for idx, hex_obj in enumerate(self.hex_grid.hexes):
        for v in hex_obj.vertices():
            v_key = self._vertex_key(v)
            total_counts[v_key] = total_counts.get(v_key, 0) + 1
    
    # Perimeter = vertices where region count < total count
    # (i.e., at least one neighboring hex is NOT in the region)
    perimeter_vertices = []
    for v_key, region_count in region_counts.items():
        total_count = total_counts.get(v_key, 0)
        if region_count < total_count:
            perimeter_vertices.append(self._key_to_point(v_key))
    
    return perimeter_vertices


# %% ../nbs/02_primitives.ipynb 66
@patch
def trace_perimeter(self: HexRegion, debug=False, 
                         style=StyleCSS("perimeter_path", fill="none", 
                                       stroke="#ba3ca3ff", stroke_width=3)):
    """Fast perimeter tracing by pre-computing coastal edges from region neighbors."""
    grid = self.hex_grid
    
    # Step 1: Find all coastal edges in O(region × 6)
    # For each region hex, any neighbor NOT in region creates a coastal edge
    coastal_edges = set()  # Store as frozenset of vertex keys
    vertex_adj = {}        # vertex_key -> set of adjacent vertex_keys on boundary
    
    for idx in self.hexes:
        hex_obj = grid.hexes[idx]
        vertices = hex_obj.vertices()
        
        # Check all 6 neighbors
        for hp in HexPosition(0, 0, 0).ring(1):
            neighbor_idx = grid.hexposition_to_index(hp, idx)
            
            # Coastal edge if neighbor is out of bounds OR not in region
            if neighbor_idx < 0 or neighbor_idx not in self.hexes:
                # Find which edge this is (which 2 vertices are shared)
                # The edge corresponds to a direction - map direction to vertex indices
                direction_to_edge = {
                    (1, 0, -1): (0, 1),   # E  -> vertices 0,1
                    (0, 1, -1): (1, 2),   # SE -> vertices 1,2
                    (-1, 1, 0): (2, 3),   # SW -> vertices 2,3
                    (-1, 0, 1): (3, 4),   # W  -> vertices 3,4
                    (0, -1, 1): (4, 5),   # NW -> vertices 4,5
                    (1, -1, 0): (5, 0),   # NE -> vertices 5,0
                }
                
                v_indices = direction_to_edge.get((hp.q, hp.r, hp.s))
                if v_indices:
                    v1 = vertices[v_indices[0]]
                    v2 = vertices[v_indices[1]]
                    
                    k1 = self._vertex_key(v1)
                    k2 = self._vertex_key(v2)
                    
                    # Add to adjacency graph (bidirectional)
                    vertex_adj.setdefault(k1, set()).add(k2)
                    vertex_adj.setdefault(k2, set()).add(k1)
    
    if debug:
        print(f"Found {len(vertex_adj)} boundary vertices, "
              f"{sum(len(v) for v in vertex_adj.values())//2} coastal edges")
    
    # Step 2: Trace paths using adjacency graph - O(perimeter)
    visited_edges = set()
    paths = []
    
    remaining = set(vertex_adj.keys())
    
    while remaining:
        start = next(iter(remaining))
        path = [start]
        remaining.discard(start)
        
        # Follow the chain
        while True:
            current = path[-1]
            neighbors = vertex_adj.get(current, set())
            
            # Find unvisited neighbor
            next_vertex = None
            for n in neighbors:
                edge = frozenset([current, n])
                if edge not in visited_edges:
                    next_vertex = n
                    visited_edges.add(edge)
                    break
            
            if next_vertex is None:
                break
            
            path.append(next_vertex)
            remaining.discard(next_vertex)
        
        # Convert keys back to MapCords
        if len(path) > 2:
            coords = [self._key_to_point(k) for k in path]
            paths.append(MapPath(coords, style=style))
            if debug:
                print(f"Traced path with {len(path)} vertices")
    
    return paths, []  # No gaps with this approach


# %% ../nbs/02_primitives.ipynb 67
@patch
def __lt__(self: MapCord, other: MapCord) -> bool:
    """Less than comparison: first by x, then by y."""
    if self.x != other.x:
        return self.x < other.x
    return self.y < other.y


# %% ../nbs/02_primitives.ipynb 70
@patch
def update(self:HexGrid,wrapper:HexWrapper = HexWrapper(),layer_name="hexes"):

        testBody = ""
        hexWrap = wrapper.callBack

        exportSize = MapSize(max([hex.center.x for hex in self.hexes]),
        max([hex.center.y for hex in self.hexes]))
        self.builder.width = exportSize.width
        self.builder.height = exportSize.height

        for i, hex in enumerate(self.hexes):
            testBody += "\t" +  hex.svg(hexWrap(self,i)) + "\n"
            if len(hex.label) > 0:
                testBody += f"\t\t<text x=\"{hex.center.x}\" y=\"{hex.center.y}\" text-anchor=\"middle\" dominant-baseline=\"middle\""
                if len(hex.labelStyle) > 1:
                    testBody += f" class=\"{hex.labelStyle}\""
                
                testBody += f">{hex.label}</text>\n"
        
        self.builder.adjust(layer_name,testBody)


# %% ../nbs/02_primitives.ipynb 71
@patch
def demoDrawGrid(self:PrimitiveDemo):
    mySize = MapSize(120,120)
    myBounds = MapRect(MapCord(0,0), mySize)
    baseStyle = StyleCSS.elevations()[3]
    aGrid = HexGrid(bounds=myBounds,style=baseStyle)
    
    hexText = StyleCSS("hex-text",fill="red",font_size="14px",font_weight="600",font_family="sans-serif",text_anchor="middle",dominant_baseline="middle",cursor="pointer")

    aGrid.builder.add_style(hexText)
    
    for i, hex in enumerate(aGrid.hexes):
        aGrid.hexes[i].label = f"{i}"
        aGrid.hexes[i].labelStyle = "hex-text"
    
    origin = 5
    ring_hexpositions = HexPosition(0, 0, 0).ring(2)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[0]

    ring_hexpositions = HexPosition(0, 0, 0).ring(1)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[1]
    
    aGrid.update()
    return aGrid.builder.show()


 




# %% ../nbs/02_primitives.ipynb 75
class LinearGradient(Generatable):

    def __init__(self,grid:HexGrid,startHex:Int,endHex:Int,startColor:str,endColor:str,):
        self.startHex = startHex
        self.endHex = endHex
        self.startColor = startColor
        self.endColor = endColor
        self.grid = grid
        self.name =  f"grad_{startHex}_{endHex}"

    
    def poly(self):
        startH = self.grid.hexes[self.startHex]
        endH = self.grid.hexes[self.endHex]
        testBody = ""

        edges = list(startH.edges().intersection(endH.edges()))
        if len(edges) > 0:
            edge = edges[0]

            testBody += "\t" +  "<polygon points=\""
            testBody += f"{startH.center.x:.0f},{startH.center.y:.0f} "
            testBody += f"{edge[0]},{edge[1]} "
            testBody += f"{endH.center.x:.0f},{endH.center.y:.0f} "
            testBody += f"{edge[2]},{edge[3]} "
            testBody += f"\" fill=\"url(#{self.name})\" />\n"

        return testBody
        

    def generate(self) -> str:
        startH = self.grid.hexes[self.startHex]
        endH = self.grid.hexes[self.endHex]
        
        # Calculate vector from start to end
        dx = endH.center.x - startH.center.x
        dy = endH.center.y - startH.center.y
        
        # Use actual coordinates for the gradient
        svg = f'<linearGradient id="{self.name}" '
        svg += f'x1="{startH.center.x}" y1="{startH.center.y}" '
        svg += f'x2="{endH.center.x}" y2="{endH.center.y}" '
        svg += 'gradientUnits="userSpaceOnUse">\n'
        svg += f'  <stop offset="0%" stop-color="{self.startColor}" />\n'
        svg += f'  <stop offset="100%" stop-color="{self.endColor}" />\n'
        svg += '</linearGradient>\n'
        return svg

# %% ../nbs/02_primitives.ipynb 76
@patch
def radial_gradient(self: HexGrid, lookup: dict= {5:"#007fff",6:"#07ff66ff",10:"#ff005dff]"} ):
    """Use overlapping radial gradients for smoother blending."""
    testBody = ""
    
    for i, color in lookup.items():
        hex = self.hexes[i]
        grad_id = f"radial_{i}"
        
        # Create radial gradient fading to transparent
        grad = f'''<radialGradient id="{grad_id}" cx="{hex.center.x}" cy="{hex.center.y}" 
                    r="{self.radius * 1.5}" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="{color}" stop-opacity="1"/>
            <stop offset="70%" stop-color="{color}" stop-opacity="0.5"/>
            <stop offset="100%" stop-color="{color}" stop-opacity="0"/>
        </radialGradient>'''
        self.builder.add_definition(SVGDef("", grad_id, grad, raw=True))
        
        # Draw a circle with this gradient
        testBody += f'<circle cx="{hex.center.x}" cy="{hex.center.y}" r="{self.radius * 1.5}" fill="url(#{grad_id})"/>\n'
    
    return testBody

# %% ../nbs/02_primitives.ipynb 77
@patch
def gradient(self:HexGrid,lookup = {5:"#007fff",6:"#07ff66ff",10:"#ff005dff]"} ):
    testBody = ""
   
    exportSize = MapSize(max([hex.center.x for hex in self.hexes]),
    max([hex.center.y for hex in self.hexes]))
    self.builder.width = exportSize.width
    self.builder.height = exportSize.height
    

    for i ,v in lookup.items():
        hex = self.hexes[i]

        neighs = [j for j in self.neighborsOf(i) if j > i]
        for j in neighs:
            if j in lookup:
                lg = LinearGradient(self,i,j,lookup[i],lookup[j])
                self.builder.add_definition(lg)
                testBody += lg.poly()

    return testBody

# %% ../nbs/02_primitives.ipynb 78
@patch
def demoGradienGrid(self:PrimitiveDemo):
    mySize = MapSize(120,120)
    myBounds = MapRect(MapCord(0,0), mySize)
    baseStyle = StyleCSS.elevations()[3]
    aGrid = HexGrid(bounds=myBounds,style=baseStyle)
    
    hexText = StyleCSS("hex-text",fill="red",font_size="14px",font_weight="600",font_family="sans-serif",text_anchor="middle",dominant_baseline="middle",cursor="pointer")

    aGrid.builder.add_style(hexText)
    
    for i, hex in enumerate(aGrid.hexes):
        aGrid.hexes[i].label = f"{i}"
        aGrid.hexes[i].labelStyle = "hex-text"
    
    origin = 5
    ring_hexpositions = HexPosition(0, 0, 0).ring(2)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[0]

    ring_hexpositions = HexPosition(0, 0, 0).ring(1)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[1]
    
    g = aGrid.radial_gradient()
    aGrid.builder.adjust("gradient",g)
    return aGrid.builder.show()
    
