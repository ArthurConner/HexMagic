# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_primitives.ipynb.

# %% auto 0
__all__ = ['PrimitiveDemo', 'MapCord', 'MapSize', 'MapRect', 'MakeCord', 'MakeSize', 'MapPath', 'HexPosition', 'GosperCurve',
           'Hex', 'hexSVG', 'hexBackground', 'HexGrid', 'HexWrapper', 'HexRegion', 'LinearGradient']

# %% ../nbs/02_primitives.ipynb 6
import numpy as np
import math


from collections import namedtuple
from dataclasses import dataclass, field
from fastcore.basics import patch
from bezier_interpolation import cubic_interpolation
from typing import List

from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

# %% ../nbs/02_primitives.ipynb 7
import sys
import os
import math
import random
import traceback
from functools import lru_cache # for ring positions

from .styles import StyleCSS, SVGLayer, SVGBuilder, SVGPatternLoader, preview, indent,SVGDef, Generatable

# %% ../nbs/02_primitives.ipynb 9
class PrimitiveDemo:
    def __init__(self):
        self.help = ""
        

# %% ../nbs/02_primitives.ipynb 12
@dataclass(frozen=True)
class MapCord:
    x: float
    y: float

    def __str__(self):
        return f"({self.x},{self.y})"

    def __repr__(self):
        return f"({self.x},{self.y})"



    def midPoint(self,other):
        return MapCord((self.x + other.x)/2,(self.y + other.y)/2)

    def angle(self,other):
        return math.atan2(other.y - self.y, other.x - self.x)



    def toPoint(self,other):
        return MapCord(other.x - self.x ,other.y - self.y)

    def to_csv(self):
        return f"{self.x}^{self.y}"

 
    def from_csv( s:str):
        vals = s.split('^')
        return MapCord(x=float(vals[0]), y=float(vals[1]))

    def distance(self,other):
        vector =  self.toPoint(other)
        return math.sqrt(vector.x * vector.x  + vector.y * vector.y)

    def midOff(self,other,distance):
        """Calculate a point perpendicular to the line segment between two points.
    
    This function finds the midpoint between self and other, then moves 
    perpendicular to the line by the specified distance. Useful for creating
    offset curves and adding variation to straight lines (e.g., river meandering).
    
    Args:
        other (MapCord): The other endpoint of the line segment
        distance (float): How far to offset perpendicular to the line (can be negative)
        
    Returns:
        MapCord: A point perpendicular to the midpoint at the given distance,
                or MapCord(-1, -1) if self and other are identical
    
    Example:
        p1 = MapCord(0, 0)
        p2 = MapCord(10, 0)
        offset = p1.midOff(p2, 5)  # Returns point above/below midpoint
    """
        length = self.distance(other)
        if length == 0:
            return MapCord(-1,-1)

        delta = self.toPoint(other)
        mid = self.midPoint(other)
        
            # Perpendicular unit vector
        Ux = -delta.y / length
        Uy = delta.x / length
        return MapCord (mid.x + Ux * distance, mid.y + Uy * distance)

    


@dataclass(frozen=True)
class MapSize:
    width: float
    height: float
    def background(self,style):
        return f"<rect width=\"{self.width}\" height=\"{self.height }\" class =\"" + style.name+ "\"  />"

    def to_csv(self):
        return f"{self.width}^{self.height}"

 
    def from_csv( s:str):
        vals = s.split('^')
        return MapSize(width=float(vals[0]), height=float(vals[1]))
        

@dataclass(frozen=True)
class MapRect:
    origin: MapCord
    dimensons: MapSize


    def minX(self):
        return self.origin.x

    def minY(self):
        return self.origin.y

    def maxX(self):
        return self.origin.x + self.dimensons.width

    def maxY(self):
        return self.origin.y + self.dimensons.height

    def to_csv(self):
        return f"{self.origin.to_csv()}&{self.dimensons.to_csv()}"

 
    def from_csv( s:str):
        vals = s.split('&')
        return  MapRect(origin=MapCord.from_csv(vals[0]),dimensons=MapSize.from_csv(vals[1]))


def MakeCord(x):
    return MapCord(x[0],x[1])
    
def MakeSize(x):
    return MapSize(x[0],x[1])

# %% ../nbs/02_primitives.ipynb 15
class MapPath:
    def __init__(self,points,style = StyleCSS("blank")):

        self.points = [x if isinstance(x, MapCord) else MakeCord(x) for x in points]
        self.style = style
    

    def drawPloy(self , adds = ""):
        path_data = "\n<path d=\""
        for i, point in enumerate(self.points):
            if i == 0:
                path_data += f"M {point.x:.1f} {point.y:.1f}"
            else:
                path_data += (f" L {point.x:.1f} {point.y:.1f}")
        path_data += "\" class =\"" + self.style.name + f"\"  {adds} />\n"
        return path_data
    
    def drawSpline(self,adds = ""):
        path_spline = "\n<path d=\""
        xN = np.array([])
        yN = np.array([])
        
        for i, point in enumerate(self.points):
            xN = np.append(xN, point.x)
            yN = np.append(yN, point.y)
    
            if i == 0:
                path_spline += f"M {point.x:.1f} {point.y:.1f}"
    
        c_data = {"x": xN, "y": yN}
        c_data = list(zip(c_data["x"], c_data["y"]))
        c_interpolated_data = cubic_interpolation(c_data)

        line = ""

        for i, point in enumerate(c_interpolated_data):
            x, y = point
            if i > 0:
                if i % 3 == 1:
                    line += f" C"
                line += f" {x:.1f} {y:.1f}"
            if len(line)>50:
                path_spline += line + "\n\t"
                line = ""

        path_spline += line
        
        if len(adds) > 2:
            path_spline += f"\"  {adds} />\n"

        else:
            path_spline += "\" class =\"" + self.style.name+ f"\" />\n"
        return indent(path_spline)

    def svg(self,adds = ""):
        return self.drawSpline(adds)

    def from_boundary( points: list[tuple[float, float]], style=None) -> 'MapPath':
        """Factory method to create a closed boundary path from coordinate tuples.
        
        Args:
            points: List of (x, y) tuples
            style: Optional StyleCSS, defaults to blank
            
        Returns:
            MapPath with points converted to MapCord
        """
        if style is None:
            style = StyleCSS("blank")
        path = MapPath(points, style)
        return path.closed()  # Use existing closed() method

    # Also add to_svg_path for easy SVG generation 
    def to_svg_path(self, close: bool = True) -> str:
        """Generate just the path 'd' attribute string."""
        if not self.points:
            return ""
        
        path_data = f"M {self.points[0].x:.1f},{self.points[0].y:.1f}"
        for point in self.points[1:]:
            path_data += f" L {point.x:.1f},{point.y:.1f}"
        
        if close:
            path_data += " Z"
        
        return path_data



# %% ../nbs/02_primitives.ipynb 16
@patch
def length(self: MapPath) -> float:
    """Calculate total path length"""
    total = 0
    for i in range(len(self.points) - 1):
        total += self.points[i].distance(self.points[i + 1])
    return total

@patch
def reverse(self: MapPath) -> MapPath:
    """Return reversed path"""
    return MapPath(list(reversed(self.points)), self.style)

@patch
def subsample(self: MapPath, num_points: int) -> MapPath:
    """Resample path to have specific number of points"""
    if num_points < 2 or len(self.points) < 2:
        return self
    
    total_length = self.length()
    segment_length = total_length / (num_points - 1)
    
    new_points = [self.points[0]]
    current_dist = 0
    target_dist = segment_length
    
    for i in range(len(self.points) - 1):
        p1 = self.points[i]
        p2 = self.points[i + 1]
        seg_length = p1.distance(p2)
        
        while target_dist <= current_dist + seg_length:
            t = (target_dist - current_dist) / seg_length
            new_points.append(p1.lerp(p2, t))
            target_dist += segment_length
            
        current_dist += seg_length
    
    new_points.append(self.points[-1])
    return MapPath(new_points[:num_points], self.style)

@patch
def smooth(self: MapPath, iterations: int = 1) -> MapPath:
    """Smooth path using average of neighbors"""
    if len(self.points) < 3:
        return self
    
    points = list(self.points)
    for _ in range(iterations):
        new_points = [points[0]]
        for i in range(1, len(points) - 1):
            avg_x = (points[i-1].x + points[i].x + points[i+1].x) / 3
            avg_y = (points[i-1].y + points[i].y + points[i+1].y) / 3
            new_points.append(MapCord(avg_x, avg_y))
        new_points.append(points[-1])
        points = new_points
    
    return MapPath(points, self.style)

@patch
def add_noise(self: MapPath, amount: float, seed: int = None) -> MapPath:
    """Add random noise to path for organic appearance"""
    if seed is not None:
        random.seed(seed)
    
    new_points = []
    for point in self.points:
        offset_x = (random.random() - 0.5) * amount * 2
        offset_y = (random.random() - 0.5) * amount * 2
        new_points.append(MapCord(point.x + offset_x, point.y + offset_y))
    
    return MapPath(new_points, self.style)

@patch
def closed(self: MapPath) -> MapPath:
    """Return closed version of path (adds first point to end if not already closed)"""
    if self.points[0].distance(self.points[-1]) < 0.01:
        return self
    return MapPath(self.points + [self.points[0]], self.style)

@patch
def make_windy(self: MapPath, iterations: int = 1, offset_factor: float = 0.15, 
               seed: int = None, vary_direction: bool = True) -> MapPath:
    """Make path more windy by recursively adding perpendicular offsets at midpoints.
    
    This method works by:
    1. For each pair of consecutive points, find the midpoint
    2. Calculate a perpendicular offset at that midpoint
    3. Insert the offset point into the path
    4. Repeat for specified number of iterations
    
    Args:
        iterations: Number of subdivision iterations (more = more curves)
        offset_factor: How far to offset as fraction of segment length (0.0-0.5)
                      Default 0.15 gives gentle curves, 0.3+ gives dramatic curves
        seed: Random seed for reproducible results. If None, uses alternating offsets
        vary_direction: If True and seed is None, alternates offset direction for
                       natural meandering. If False, offsets are consistent.
    
    Returns:
        New MapPath with windy characteristics
    
    Example:
        # Gentle meandering river
        river = MapPath([(0, 0), (100, 0), (200, 50)], river_style)
        windy_river = river.make_windy(iterations=2, offset_factor=0.2)
        
        # Dramatic serpentine path
        snake = path.make_windy(iterations=3, offset_factor=0.35, seed=42)
    """
    if len(self.points) < 2:
        return self
    
    if seed is not None:
        random.seed(seed)
    
    points = list(self.points)
    
    for iteration in range(iterations):
        new_points = [points[0]]  # Keep first point
        
        for i in range(len(points) - 1):
            p1 = points[i]
            p2 = points[i + 1]
            
            # Calculate offset distance based on segment length
            segment_length = p1.distance(p2)
            offset_distance = segment_length * offset_factor
            
            # Determine offset direction
            if seed is not None:
                # Random offset direction
                offset_distance *= random.choice([-1, 1])
            elif vary_direction:
                # Alternate direction for natural meandering
                # Use both iteration and segment index for variation
                direction = 1 if ((i + iteration) % 2 == 0) else -1
                offset_distance *= direction
            # else: consistent direction (always positive)
            
            # Use the existing midOff method which calculates perpendicular offset
            mid_point = p1.midOff(p2, offset_distance)
            
            # Handle edge case where points are identical
            if mid_point.x == -1 and mid_point.y == -1:
                mid_point = p1.midPoint(p2)
            
            new_points.append(mid_point)
            new_points.append(p2)
        
        points = new_points
    
    return MapPath(points, self.style)

@patch
def make_windy_variable(self: MapPath, iterations: int = 1, 
                         offset_min: float = 0.05, offset_max: float = 0.25,
                         seed: int = None) -> MapPath:
    """Make path windy with variable offset amounts for more organic appearance.
    
    Similar to make_windy but each subdivision uses a random offset factor
    within the specified range, creating more natural variation.
    
    Args:
        iterations: Number of subdivision iterations
        offset_min: Minimum offset as fraction of segment length
        offset_max: Maximum offset as fraction of segment length
        seed: Random seed for reproducible results
    
    Returns:
        New MapPath with organic windy characteristics
    """
    if len(self.points) < 2:
        return self
    
    if seed is not None:
        random.seed(seed)
    
    points = list(self.points)
    
    for iteration in range(iterations):
        new_points = [points[0]]
        
        for i in range(len(points) - 1):
            p1 = points[i]
            p2 = points[i + 1]
            
            segment_length = p1.distance(p2)
            
            # Random offset factor for this segment
            offset_factor = random.uniform(offset_min, offset_max)
            offset_distance = segment_length * offset_factor * random.choice([-1, 1])
            
            mid_point = p1.midOff(p2, offset_distance)
            
            if mid_point.x == -1 and mid_point.y == -1:
                mid_point = p1.midPoint(p2)
            
            new_points.append(mid_point)
            new_points.append(p2)
        
        points = new_points
    
    return MapPath(points, self.style)

# %% ../nbs/02_primitives.ipynb 17
@patch
def drawClosed(self: MapPath, adds: str = "") -> str:
    """Draw closed polygon"""
    path_data = "\n<path d=\""
    for i, point in enumerate(self.points):
        if i == 0:
            path_data += f"M {point.x:.1f} {point.y:.1f}"
        else:
            path_data += f" L {point.x:.1f} {point.y:.1f}"
    path_data += " Z"  # Close path
    path_data += f"\" class=\"{self.style.name}\" {adds} />\n"
    return path_data

@patch
def bounds(self: MapPath) -> MapRect:
    """Get bounding rectangle of path"""
    if not self.points:
        return MapRect(MapCord(0, 0), MapSize(0, 0))
    
    min_x = min(p.x for p in self.points)
    max_x = max(p.x for p in self.points)
    min_y = min(p.y for p in self.points)
    max_y = max(p.y for p in self.points)
    
    return MapRect(
        MapCord(min_x, min_y),
        MapSize(max_x - min_x, max_y - min_y)
    )

# %% ../nbs/02_primitives.ipynb 18
@patch
def with_arrowhead(self: MapPath, arrow_size: float = 10, arrow_angle: float = 25, shouldFill = True) -> str:
    """Draw path with an arrowhead at the end.
    
    Args:
        arrow_size: Length of the arrowhead lines
        arrow_angle: Angle of arrowhead in degrees (from path direction)
    
    Returns:
        SVG path string including the arrowhead
    """
    if len(self.points) < 2:
        return self.svg()
    
    # Get the last two points to determine arrow direction
    p1 = self.points[-2]
    p2 = self.points[-1]
    
    # Calculate angle of the line
    angle = p1.angle(p2)
    
    # Convert arrow angle to radians
    arrow_rad = math.radians(arrow_angle)
    
    # Calculate the two arrowhead points
    left_angle = angle + math.pi - arrow_rad
    right_angle = angle + math.pi + arrow_rad
    
    left_point = MapCord(
        p2.x + arrow_size * math.cos(left_angle),
        p2.y + arrow_size * math.sin(left_angle)
    )
    
    right_point = MapCord(
        p2.x + arrow_size * math.cos(right_angle),
        p2.y + arrow_size * math.sin(right_angle)
    )
    
    # Draw main path
    result = self.svg()
    if shouldFill:
        stroke = self.style.properties["stroke"]
        result += f'\n<polygon points="{left_point.x:.1f},{left_point.y:.1f} {p2.x:.1f},{p2.y:.1f} {right_point.x:.1f},{right_point.y:.1f}" class="{self.style.name}"  style="fill: {stroke};"/>'

        

    else:
        
        # Add arrowhead lines
        result += f'\n<polygon points="{left_point.x:.1f},{left_point.y:.1f} {p2.x:.1f},{p2.y:.1f} {right_point.x:.1f},{right_point.y:.1f}" class="{self.style.name}" />'

    
    return result

# %% ../nbs/02_primitives.ipynb 21
@dataclass
class HexPosition:
    _coords: np.ndarray = field(default_factory=lambda: np.array([0, 0, 0]))
    label: str = ""

    _theDirs = {(1, 0, -1):"E",
        (1, -1, 0):"NE",
        (0, -1, 1):"NW",
        (-1, 0, 1):"W",
        (-1, 1, 0):"SW", 
        (0, 1, -1):"SE",
        (0, 0, 0):"X"
        }

        # Add reverse mapping
    _labelToDirs = {v: k for k, v in _theDirs.items()}

   
    


    _rings = []
    _neigbors = []


    
    def __init__(self, q: int = 0, r: int = 0, s: int = 0, label: str = ""):
        self._coords = np.array([q, r, s])
        self.label = label
    
    @property
    def q(self) -> int: return int(self._coords[0])
    
    @property
    def r(self) -> int: return int(self._coords[1])
    
    @property
    def s(self) -> int: return int(self._coords[2])

    @classmethod 
    def direction(cls, lbl):
        coords = HexPosition._labelToDirs.get(lbl, (0, 0, 0))
        return cls(*coords, label=lbl)

     
    def desc(self):
        return HexPosition._theDirs.get((self.q,self.r,self.s),  self.label)

    @classmethod
    def origin(cls)->'HexPosition':
        return HexPosition(0,0,0,"origin")
   
    @classmethod
    def directions(cls):

        return HexPosition._orderDirs 

 
 

    def copy(self,label:None):
        if label is None:
            label = self.label
        return HexPosition(self.q,self.r,self.s,label)

    @property
    def cube_coords(self):
        return (self.q, self.r, self.s)
    
    def encode(self) -> str:
        """Encode as string like '2^3' (ring^position)"""
        return f"{self.q}^{self.r}^{self.s}"

   
    
    def pixel(self, hex_radius: float, center: MapCord) -> tuple[float, float]:
        """Convert HexPosition cube coordinates to pixel position for pointy-top hex."""
        x = hex_radius * (math.sqrt(3) * self.q + math.sqrt(3)/2 * self.r)
        y = hex_radius * (3/2 * self.r)
        return MapCord(center.x + x, center.y + y)
    
    @staticmethod
    def decode(s: str) -> 'HexPosition':
        """Decode from string like '2^3'"""
        vals = s.split('^')
        return HexPosition(q=int(vals[0]), r=int(vals[1]),s=int(vals[2]))

    @staticmethod
    def _cube_round(q: float, r: float, s: float) -> 'HexPosition':
        """Round fractional cube coords to nearest valid hex."""
        rq, rr, rs = round(q), round(r), round(s)
        dq, dr, ds = abs(rq - q), abs(rr - r), abs(rs - s)
        
        # Adjust the largest diff to maintain q + r + s = 0
        if dq > dr and dq > ds:
            rq = -rr - rs
        elif dr > ds:
            rr = -rq - rs
        else:
            rs = -rq - rr
        
        return HexPosition(int(rq), int(rr), int(rs))

HexPosition._orderDirs = [HexPosition.direction(lbl) for lbl in ["SW","W","NW", "NE", "E", "SE"]]

   

# %% ../nbs/02_primitives.ipynb 22
@patch
def distance(self: HexPosition, other: HexPosition) -> int:
    """Cube coordinate distance using numpy"""
    return int(np.abs(self._coords - other._coords).sum() // 2)

@patch
def __add__(self: HexPosition, other: 'HexPosition') -> 'HexPosition':
    return HexPosition(*(self._coords + other._coords))

@patch
def __sub__(self: HexPosition, other: 'HexPosition') -> 'HexPosition':
    return HexPosition(*(self._coords - other._coords))

@patch
def __rmul__(self: HexPosition, scalar: int) -> 'HexPosition':
    return HexPosition(*(self._coords * scalar))

@patch
def __neg__(self: HexPosition) -> 'HexPosition':
    return HexPosition(*(-self._coords))

@patch
def __abs__(self: HexPosition) -> int:
    """Distance from origin: abs(pos)"""
    return self.distance(HexPosition.origin())

@patch
def __eq__(self: HexPosition, other) -> bool:
    """Equality: pos1 == pos2"""
    if not isinstance(other, HexPosition):
        return False
    return self.q == other.q and self.r == other.r and self.s == other.s


@patch
def __hash__(self: HexPosition) -> int:
    """Hash for use in sets/dicts"""
    return hash((self.q, self.r,self.s))



# %% ../nbs/02_primitives.ipynb 23
@patch
def line_to(self: HexPosition, other: HexPosition) -> list[HexPosition]:
    """Get line of hexes from self to other using linear interpolation"""
    n = self.distance(other)
    if n == 0:
        return [self]

    results = []
    for i in range(n + 1):
        t = i / n
        # Lerp in cube coordinates using numpy
        coords = self._coords + (other._coords - self._coords) * t
        results.append(HexPosition._cube_round(*coords))

    return results


# %% ../nbs/02_primitives.ipynb 27
@patch
def __repr__(self: HexPosition) -> str:
    """Better string representation"""
    if self.label:
        return f"HexPosition({self.q}, {self.r}, {self.s}, '{self.label}')"
    return f"HexPosition({self.q}, {self.r}, {self.s})"

# %% ../nbs/02_primitives.ipynb 28
@patch
def spiral(self: HexPosition, radius: int,clockwise=True) -> list[HexPosition]:
    """Get all hexes in a true spiral pattern from center out to radius.
    
    Returns hexes in order where each hex is adjacent to the previous one,
    creating a continuous spiral path rather than concentric rings.
    """
    if radius == 0:
        return [self]
    
    results = [self]  # Start at center
    current = self
    
    # Start moving east
    last_direction = HexPosition.direction("E")
    
    for ring in range(1, radius + 1):
        # Move out one step to start the new ring
        current = current + last_direction
        results.append(current)
        
        # Walk around this ring - 6 sides, 'ring' steps per side
        for side in range(6):
            # Rotate counter-clockwise to next direction
            if clockwise:
                last_direction = last_direction.rotate_right()
            else:
                last_direction = last_direction.rotate_left()
            
            # Walk 'ring' steps in this direction
            # (but skip the first step on first side since we already moved out)
            steps = ring if side > 0 else ring - 1
            for step in range(steps):
                current = current + last_direction
                results.append(current)
    
    return results


# %% ../nbs/02_primitives.ipynb 29
@patch
def closest_in_ring(self: HexPosition, root: 'HexPosition', radius: int) -> 'HexPosition':
    """Find the hex in the given ring (centered at root) closest to self.
    If there's a tie, returns the one that appears first in clockwise order."""
    ring_hexes = root.ring(radius)
    
    if not ring_hexes:
        return root
    
    # Find minimum distance
    min_dist = min(self.distance(h) for h in ring_hexes)
    
    # Return first hex with that distance (earliest in clockwise order)
    for hex_pos in ring_hexes:
        if self.distance(hex_pos) == min_dist:
            return hex_pos
    
    return ring_hexes[0]  # Fallback

# %% ../nbs/02_primitives.ipynb 30
@patch
def path_through_waypoints(self: HexPosition, waypoints: list[HexPosition], 
                           destination: HexPosition) -> list[HexPosition]:
    """Create a path from self through all waypoints to destination.
    
    Args:
        waypoints: List of intermediate points to visit
        destination: Final destination
        use_lines: If True, use straight lines. If False, use radial paths (default)
    """
    if not waypoints:
        return self.line_to(destination) 
    
    full_path = []
    current = self
    path_method = (lambda a, b: a.line_to(b)) 
    
    # Go through each waypoint
    for waypoint in waypoints:
        segment = path_method(current, waypoint)
        # Avoid duplicates at segment boundaries
        if full_path and segment and full_path[-1].cube_coords == segment[0].cube_coords:
            full_path.extend(segment[1:])
        else:
            full_path.extend(segment)
        current = waypoint
    
    # Final segment to destination
    final_segment = path_method(current, destination)
    if full_path and final_segment and full_path[-1].cube_coords == final_segment[0].cube_coords:
        full_path.extend(final_segment[1:])
    else:
        full_path.extend(final_segment)
    
    return full_path


# %% ../nbs/02_primitives.ipynb 31
@patch
def rotate_left(self: HexPosition) -> 'HexPosition':
    """Rotate 60° counter-clockwise: (q,r,s) -> (-s,-q,-r)"""
    return HexPosition(*(-np.roll(self._coords, 1)))

@patch
def rotate_right(self: HexPosition) -> 'HexPosition':
    """Rotate 60° clockwise: (q,r,s) -> (-r,-s,-q)"""
    return HexPosition(*(-np.roll(self._coords, -1)))

@patch
def rotate(self: HexPosition, steps: int = 1) -> HexPosition:
    """Rotate around origin. Positive = counter-clockwise, negative = clockwise."""
    steps = steps % 6
    coords = self._coords
    # Apply sign pattern: even rotations keep sign, odd rotations negate
    sign = 1 if steps % 2 == 0 else -1
    rolled = np.roll(coords, steps)
    return HexPosition(*(sign * rolled), label=self.label)


# %% ../nbs/02_primitives.ipynb 32
@patch
def _ring(self: HexPosition, radius: int, clockwise: bool = True) -> list['HexPosition']:
    """Generate all HexPositions in a ring at given radius from center."""
    if radius == 0:
        return [self]
    
    results = []
    current = self + radius * HexPosition.direction("E")
    
    # SW for counter-clockwise, SE for clockwise
    direction = HexPosition.direction("E").rotate(2 if not clockwise else -2)
    rotation = 1 if not clockwise else -1
    
    for side in range(6):
        for _ in range(radius):
            results.append(current)
            current = current + direction
        direction = direction.rotate(rotation)
    
    return results


@patch
def _neighbor(self: HexPosition, direction: int) -> 'HexPosition':
    """Get neighbor in direction (0-5, starting East and going counter-clockwise)"""
    directions = HexPosition.directions()
    return self + directions[direction % 6]

# %% ../nbs/02_primitives.ipynb 33
HexPosition._rings = [HexPosition.origin()._ring(i) for i in range(10)]
HexPosition._neighbors = [HexPosition.origin()._neighbor(i) for i in range(6)]


# %% ../nbs/02_primitives.ipynb 34
@patch
def ring(self: HexPosition, radius: int, clockwise: bool = True) -> list['HexPosition']:
    """Generate all HexPositions in a ring at given radius from center.
    
    Uses cached rings for radius < 10 when clockwise and centered at origin.
    """
    # Fast path: use cached rings if at origin, clockwise, and radius < 10
    if radius < 10 and clockwise and self.q == 0 and self.r == 0 and self.s == 0:
        return HexPosition._rings[radius]
    
    # Fast path: use cached rings and offset if radius < 10 and clockwise
    if radius < 10 and clockwise:
        return [self + pos for pos in HexPosition._rings[radius]]
    
    # Slow path: compute on demand
    return self._ring(radius, clockwise)


@patch
def neighbor(self: HexPosition, direction: int) -> 'HexPosition':
    """Get neighbor in direction (0-5, starting East going counter-clockwise).
    
    Uses cached neighbor offsets for better performance.
    """
    # Use cached neighbors
    return self + HexPosition._neighbors[direction % 6]


# %% ../nbs/02_primitives.ipynb 37
@patch
def move_in(self: HexPosition, center: HexPosition) -> HexPosition:
    """Move one step toward center."""
    if self == center:
        return self
    return self.line_to(center)[1]

@patch
def move_out(self: HexPosition, center: HexPosition) -> HexPosition:
    """Move one step away from center."""
    if self == center:
        return self
    return 2 * self - self.move_in(center)


# %% ../nbs/02_primitives.ipynb 42
for x in ["E","NE","NW", "W","SW", "SE"]:
    setattr(HexPosition, x, HexPosition.direction(x))


# %% ../nbs/02_primitives.ipynb 44
class GosperCurve:
    """Generate Gosper curves using L-system rules and cube coordinates."""
    
    def __init__(self, order: int = 3):
        self.order = order
        
    @staticmethod
    def _expand_lsystem(axiom: str, rules: dict, iterations: int) -> str:
        """Expand an L-system string."""
        current = axiom
        for _ in range(iterations):
            current = ''.join(rules.get(c, c) for c in current)
        return current
    
    @classmethod
    def generate_path(cls, order: int, start: HexPosition = None) -> list[HexPosition]:
        """
        Generate a Gosper curve path using L-system.
        
        The Gosper curve L-system:
        - Axiom: A
        - Rules: A -> A-B--B+A++AA+B-
                 B -> +A-BB--B-A++A+B
        - +: turn left 60° (counter-clockwise)
        - -: turn right 60° (clockwise)
        """
        start = start or HexPosition.origin()
        
        expanded = cls._expand_lsystem(
            axiom="A",
            rules={'A': "A-B--B+A++AA+B-", 'B': "+A-BB--B-A++A+B"},
            iterations=order
        )
        
        path = [start]
        current_pos = start
        current_dir = HexPosition.direction("E")
        
        for symbol in expanded:
            if symbol in ('A', 'B'):
                current_pos = current_pos + current_dir
                path.append(current_pos)
            elif symbol == '+':
                current_dir = current_dir.rotate(1)
            elif symbol == '-':
                current_dir = current_dir.rotate(-1)
        
        return path
    
    @classmethod
    def generate_terdragon(cls, order: int, start: HexPosition = None) -> list[HexPosition]:
        """
        Generate a Terdragon curve (triangular variant).
        
        L-system:
        - Axiom: F
        - Rules: F -> F+F-F
        - +: turn left 120° (2 hex steps)
        - -: turn right 120°
        """
        start = start or HexPosition.origin()
        
        expanded = cls._expand_lsystem(
            axiom="F",
            rules={'F': "F+F-F"},
            iterations=order
        )
        
        path = [start]
        current_pos = start
        current_dir = HexPosition.direction("E")
        
        for symbol in expanded:
            if symbol == 'F':
                current_pos = current_pos + current_dir
                path.append(current_pos)
            elif symbol == '+':
                current_dir = current_dir.rotate(2)
            elif symbol == '-':
                current_dir = current_dir.rotate(-2)
        
        return path
    
    @classmethod
    def generate_peano_hex(cls, order: int, start: HexPosition = None) -> list[HexPosition]:
        """
        Generate a hexagonal Peano curve (space-filling).
        
        L-system:
        - Axiom: XF
        - Rules: X -> XF+YF+XF-F-YF-F-XF+YF-X
                 Y -> YF-XF-YF+F+XF+F+YF-XF+Y
        """
        start = start or HexPosition.origin()
        
        expanded = cls._expand_lsystem(
            axiom="XF",
            rules={
                'X': "XF+YF+XF-F-YF-F-XF+YF-X",
                'Y': "YF-XF-YF+F+XF+F+YF-XF+Y"
            },
            iterations=order
        )
        
        path = [start]
        current_pos = start
        current_dir = HexPosition.direction("E")
        
        for symbol in expanded:
            if symbol == 'F':
                current_pos = current_pos + current_dir
                path.append(current_pos)
            elif symbol == '+':
                current_dir = current_dir.rotate(1)
            elif symbol == '-':
                current_dir = current_dir.rotate(-1)
        
        return path
    
    @staticmethod
    def calculate_bounds(hex_path: list[HexPosition]) -> tuple[int, int, int, int]:
        """Calculate bounding box: (min_q, max_q, min_r, max_r)"""
        if not hex_path:
            return (0, 0, 0, 0)
        
        qs = [h.q for h in hex_path]
        rs = [h.r for h in hex_path]
        return (min(qs), max(qs), min(rs), max(rs))
    
    @staticmethod
    def center_path(hex_path: list[HexPosition]) -> list[HexPosition]:
        """Center a path around the origin."""
        if not hex_path:
            return []
        
        min_q, max_q, min_r, max_r = GosperCurve.calculate_bounds(hex_path)
        center_q = (min_q + max_q) // 2
        center_r = (min_r + max_r) // 2
        offset = HexPosition(center_q, center_r, -center_q - center_r)
        
        return [pos - offset for pos in hex_path]
    
    @staticmethod
    def path_to_mappath(hex_path: list[HexPosition], 
                        hex_radius: float = 20.0,
                        center: MapCord = None,
                        style: StyleCSS = None) -> MapPath:
        """Convert a HexPosition path to a MapPath for rendering."""
        center = center or MapCord(400, 400)
        style = style or StyleCSS("gosper", stroke="#2196F3", stroke_width=2, fill="none")
        
        pixel_points = [hexpos.pixel(hex_radius, center) for hexpos in hex_path]
        return MapPath(pixel_points, style)

# %% ../nbs/02_primitives.ipynb 46
class Hex:

     # Class-level constants for the 6 vertices (pointy-top orientation)
    _ANGLES = [(i * 60 - 30) * math.pi / 180 for i in range(6)]
    _COS = [math.cos(a) for a in _ANGLES]
    _SIN = [math.sin(a) for a in _ANGLES]

    radius: float
    center: MapCord
    style: StyleCSS

    _edgeLookup = [
                    (0, 1),   # E  -> vertices 0,1
                    (1, 2),   # SE -> vertices 1,2
                   (2, 3),   # SW -> vertices 2,3
                     (3, 4),   # W  -> vertices 3,4
                     (4, 5),   # NW -> vertices 4,5
                     (5, 0),   # NE -> vertices 5,0
    ]

    @classmethod
    def direction_to_edge(cls,x):
        
        return Hex._edgeLookup[x]
    

    _direction_to_vertices = [
            (2, 3),  # SW
            (3, 4),  # W
            (4, 5),  # NW
            (5, 0),  # NE
            (0, 1),  # E
            (1, 2),  # SE
        ]

    def edgeFrom(self, direction_idx: int) -> tuple[int, int, int, int]:
        """Get the normalized edge tuple for a given direction index (matching HexPosition.directions())."""
        # Map from HexPosition.directions() order to vertex pairs
        # directions(): SW=0, W=1, NW=2, NE=3, E=4, SE=5
        
        
        i1, i2 = Hex._direction_to_vertices[direction_idx]
        v1 = self.v[i1]
        v2 = self.v[i2]
        
        x1, y1 = v1.x, v1.y
        x2, y2 = v2.x, v2.y
        
        if x1 < x2 or (x1 == x2 and y1 <= y2):
            return (x1, y1, x2, y2)
        else:
            return (x2, y2, x1, y1)



    def __init__(self,
        radius: float, #how far away are the vertexes
        center: MapCord, #where it is located
        style: StyleCSS = None, #how will it look
        label: str = "",
        labelStyle = "",
        v = None
        ):
        self.radius = radius
        self.center = MapCord(round(center.x,2),round(center.y,2))
        self.style = style
        self.label = label
        self.labelStyle = labelStyle
        
        width = self.radius  * 2
        self.bounds = MapSize(width,self.radius * 2 )

        #cache the vertices
        # Cache vertices using precomputed trig
        if v is None:
            self.v = [
                MapCord(
                    int(self.center.x + self.radius * Hex._COS[i]),
                    int(self.center.y + self.radius * Hex._SIN[i])
                )
                for i in range(6)
            ]
        else:
            self.v = v
      
    
    def vertices(self) -> List[MapCord]:
        """Get the vertices of a hexagon centered at (center_x, center_y)."""
        return self.v
    
    def contains(self, point: MapCord) -> bool:
        """Check if a point is inside a hexagon."""
        distance = math.sqrt((point.x - self.center.x)**2 + (point.y - self.center.y)**2)
        return distance <= self.radius * 0.9
    
    def svg(self,attrs=None) -> str:
        ret = "<polygon points=\""
        for point in self.vertices():
            ret += f"{point.x:.0f},{point.y:.0f} "
        ret += f"\" class=\"{self.style.name}\""
        if attrs is not None:
            for key, value in attrs.items():
                ret += f" {key}=\'{value}\'"

        ret += "/>"
        return ret

    def angle(self, other: 'Hex') -> float:
        """Calculate angle from this hex to another hex"""
        return math.atan2(other.center.y - self.center.y, other.center.x - self.center.x)

    def right(self):
        center = MapCord(self.center.x + self.bounds.width, self.center.y)
        return Hex(self.radius,center,self.style)

# %% ../nbs/02_primitives.ipynb 47
@patch
def edges(self: Hex) -> set[tuple[int, int, int, int]]:
    """Return the edges of the hexagon as a set of normalized tuples (x1, y1, x2, y2).
    Each edge is normalized so that x1 < x2, or if x1 == x2 then y1 <= y2.
    Coordinates are converted to ints for set operations."""
    edges = set()
    vertices = self.vertices()
    
    for pos in range(6):
        edge = self.edgeFrom(pos)
        edges.add(edge)
    
    return edges


# %% ../nbs/02_primitives.ipynb 50
@patch
def verticalStretch(self: Hex, size: MapSize, attrs=None) -> str:
    
    ydelta = (size.height - 2 * self.radius)/2
    stretchV = []
    for vertex in self.v:
        addMe = vertex
        if vertex.y > self.center.y:
            addMe = MapCord(vertex.x, vertex.y + ydelta)
        else:
            addMe = MapCord(vertex.x, vertex.y - ydelta)
        
        
        stretchV.append(addMe)
        

    ret = "<polygon points=\""
    for point in stretchV:
        ret += f"{point.x:.0f},{point.y:.0f} "
    ret += f"\" class=\"{self.style.name}\""
    if attrs is not None:
        for key, value in attrs.items():
            ret += f" {key}=\'{value}\'"

    ret += "/>"
    return ret

# %% ../nbs/02_primitives.ipynb 51
def hexSVG(size:MapSize,levels = 2, pad=5, fill="#f4edb2ff",eles=StyleCSS.elevations()):
    myStyles = []
    radius = size.width/2
    center = MapCord(radius,size.height/2)
    
    canvas = ""
    hexRadius = radius
    polySize = MapSize(size.width,size.height)
    
    for i in range(levels):
        aStyle = eles[i]
        myStyles.append(aStyle)
        aHex = Hex(radius=hexRadius-4,center=center,style=aStyle)
        debug = aHex.verticalStretch(polySize)
        #print(f"round {i},{aHex.center} radius{aHex.radius},siz:{polySize}",debug)
        canvas += debug
        polySize = MapSize(polySize.width-pad*2,polySize.height-pad*2)
        hexRadius -= pad
        canvas += "\n"

    aStyle = StyleCSS("Snow",fill=fill)
    
    myStyles.append(aStyle)
    aHex = Hex(radius=hexRadius-4,center=center,style=aStyle)
    canvas += aHex.verticalStretch(polySize)
    
    sheet  = Style("\n ".join([x.__str__() for x in myStyles]) )
    #hSVG =  embedSVG(sheet + canvas,size=size)
    retRender = SVGBuilder()
    retRender.width = size.width
    retRender.height = size.height
    for x in myStyles:
        retRender.add_style(x)

    retRender.updateLayers([canvas])
    return Div(NotStr(retRender.xml()),style="""
                width: 100%; 
                height: 100%; 
                position: absolute; 
                filter: drop-shadow(4px 4px 6px rgba(0,0,0,0.3));
                transition: all 0.2s ease;
             display: flex;
            justify-content: center;
                """)
    



# %% ../nbs/02_primitives.ipynb 54
def hexBackground( content=None,levels = 2, pad=5,fill="#f4edb2ff",size=MapSize(300,300)):
     return Div(
        hexSVG(size,levels,pad,fill),
   Div(content, style="position: relative; z-index: 1;"),
        style=f"""
            position: relative; 
            width: {size.width}px; 
            height: {size.height}px;
            transition: all 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        """
     )


# %% ../nbs/02_primitives.ipynb 55
@patch
def demoHexBackground(self:PrimitiveDemo):
    a = hexBackground(P("hi"),size=MapSize(300,700))
    return a


# %% ../nbs/02_primitives.ipynb 58
@patch
def hexIcon(self: SVGBuilder, size: int) -> str:
    """Generate hex-shaped icon cropped from center of SVG."""
    cx, cy = self.width / 2, self.height / 2
    
    # Find largest hex that fits in original image
    # For pointy-top: width = r*√3, height = r*2
    # So: r = min(width/√3, height/2)
    max_radius = min(self.width / math.sqrt(3), self.height / 2)
    
    # Hex bounding box in original coordinates
    hex_width = max_radius * math.sqrt(3)
    hex_height = max_radius * 2
    vb_x = cx - hex_width / 2
    vb_y = cy - hex_height / 2
    
    # Clip path hex - coordinates in original space
    aHex = Hex(radius=max_radius, center=MapCord(cx, cy), style=StyleCSS("hex"))
    clipDef = SVGDef("clipPath", "hex-clip", aHex.verticalStretch(size=MapSize(hex_width, hex_height)))  # just the polygon points
    self.add_definition(clipDef)
    
    # Output maintains hex aspect ratio
    out_width = size * math.sqrt(3) / 2  # ~0.866 * size
    out_height = size
    
    viewBox = f"{vb_x} {vb_y} {hex_width} {hex_height}"
    
    return f'''<?xml version='1.0' encoding='utf-8'?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="{out_width:.1f}" 
     height="{out_height}"
     viewBox="{viewBox}">
{self._header()}
<g clip-path="url(#hex-clip)">
{self.body}
</g>
</svg>'''

# %% ../nbs/02_primitives.ipynb 61
class HexGrid:
    """Hexagonal grid with cube coordinate support."""

    _SQRT3 = math.sqrt(3) 

    def __init__(self, 
                 nRows: int,
                 nCols: int, 
                 radius: float,
                 style: StyleCSS,
                 offset: MapCord = None):
        self.nRows = nRows
        self.nCols = nCols
        self.radius = radius
        self.style = style
        self.offset = offset or MapCord(0, 0)
        
        self.builder = SVGBuilder()
        self.builder.add_style(style)
        for x in StyleCSS.elevations():
            self.builder.add_style(x)
        
        self._build_hexes()
    
    def _build_hexes(self):
        """Build hex array using vectorized numpy operations."""
        # Create row and col indices
        rows = np.arange(self.nRows)
        cols = np.arange(self.nCols)
        row_grid, col_grid = np.meshgrid(rows, cols, indexing='ij')
        
        # Flatten to 1D arrays
        row_flat = row_grid.flatten()
        col_flat = col_grid.flatten()
        
        # Calculate all centers at once
        width = HexGrid._SQRT3 * self.radius
        height = 2 * self.radius
        
        x_centers = width * (col_flat + 0.5 * (row_flat % 2)) + self.offset.x + self.radius
        y_centers = height * 0.75 * row_flat + self.offset.y + self.radius
        
        # Calculate all vertices at once using broadcasting
        # Shape: (n_hexes, 6) for each coordinate
        angles = np.array(Hex._ANGLES)  # (6,)
        cos_vals = np.array(Hex._COS)   # (6,)
        sin_vals = np.array(Hex._SIN)   # (6,)
        
        # Broadcast to (n_hexes, 6)
        x_vertices = x_centers[:, np.newaxis] + self.radius * cos_vals[np.newaxis, :]
        y_vertices = y_centers[:, np.newaxis] + self.radius * sin_vals[np.newaxis, :]
        
        # Round to integers
        x_vertices = np.round(x_vertices).astype(int)
        y_vertices = np.round(y_vertices).astype(int)
        
        # Create Hex objects with pre-computed vertices
        self.hexes = []
        for i in range(len(row_flat)):
            center = MapCord(round(x_centers[i], 2), round(y_centers[i], 2))
            vertices = [MapCord(x_vertices[i, j], y_vertices[i, j]) for j in range(6)]
            self.hexes.append(Hex(self.radius, center, self.style, v=vertices))
        
        self._update_builder_size()
    
    def _hex_at(self, row: int, col: int, style: StyleCSS) -> Hex:
        """Calculate hex at grid position."""
        width = HexGrid._SQRT3 * self.radius
        height = 2 * self.radius
        
        # Add radius to offset so first hex center is actually inside the bounds
        x = width * (col + 0.5 * (row % 2)) + self.offset.x + self.radius
        y = height * 0.75 * row + self.offset.y + self.radius
        
        return Hex(self.radius, MapCord(x, y), style)

    @classmethod
    def from_bounds(cls, bounds: MapRect, radius: float=25, style: StyleCSS=StyleCSS("Hex")) -> 'HexGrid':
        """Create grid to fill a bounding rectangle."""

        nRows = int(bounds.dimensons.height / radius)
        nCols = int(bounds.dimensons.width / radius)
        offset = MapCord(bounds.origin.x - radius, bounds.origin.y - radius)
        
        return cls(nRows, nCols, radius, style, offset)

    
    def _update_builder_size(self):
        """Update SVG builder dimensions."""
        if self.hexes:
            self.builder.width = max(h.center.x for h in self.hexes) + self.radius
            self.builder.height = max(h.center.y for h in self.hexes) + self.radius
    
    def _middle_hex_natural_position(self) -> MapCord:
        """Where the middle hex center would be with zero offset."""
        middle_row = self.nRows // 2
        middle_col = self.nCols // 2
        
        width = HexGrid._SQRT3 * self.radius
        height = 2 * self.radius
        
        x = width * (middle_col + 0.5 * (middle_row % 2))
        y = height * 0.75 * middle_row
        
        return MapCord(x, y)
    
    def adjustRadius(self, new_radius: float):
        """Adjust radius while keeping middle hex at same pixel position."""
        if not self.hexes:
            self.radius = new_radius
            return
        
        # Get current middle hex pixel position
        middle_idx = self.middle
        old_middle_pos = self.hexes[middle_idx].center
        
        # Update radius
        self.radius = new_radius
        
        # Calculate where middle would be with zero offset
        natural_middle = self._middle_hex_natural_position()
        
        # Offset to keep middle at same pixel position
        self.offset = MapCord(
            old_middle_pos.x - natural_middle.x + self.offset.x,
            old_middle_pos.y - natural_middle.y + self.offset.y
        )
        
        # Rebuild hexes with new radius and offset
        self._build_hexes()
    

    
    @classmethod
    def centered(cls, rings: int, radius: float, style: StyleCSS, 
                 center: MapCord = None) -> 'HexGrid':
        """Create grid with specified rings around a center point."""
        n = 2 * rings + 1
        
        # Create grid first with no offset
        grid = cls(nRows=n, nCols=n, radius=radius, style=style, offset=MapCord(0, 0))
        
        if center is not None:
            # Calculate offset to place middle hex at center
            natural_middle = grid._middle_hex_natural_position()
            grid.offset = MapCord(
                center.x - natural_middle.x,
                center.y - natural_middle.y
            )
            grid._build_hexes()
        
        return grid
    
    @property
    def middle(self) -> int:
        """Middle hex index."""
        return (self.nRows // 2) * self.nCols + (self.nCols // 2)
    
    @property
    def bounds(self) -> MapRect:
        """Bounding rectangle of grid."""
        if not self.hexes:
            return MapRect(MapCord(0, 0), MapSize(0, 0))
        return MapRect(
            self.hexes[0].center,
            MapSize(self.nCols * self.radius * HexGrid._SQRT3, 
                    self.nRows * self.radius * 1.5)
        )


    def text(self, cb=lambda s, i: i):
        i = 0
        for row in range(self.nRows):
            line = "|"
            for col in range(self.nCols):
                line += f" {cb(self, i):5}"
                i += 1
            print(line + " |")

    def rowPartity(self, index):
        "This returns whether a row is even or odd"
        return int(index / self.nCols) % 2

    @property
    def midpoint(self):
        return int(len(self.hexes)/2)


# %% ../nbs/02_primitives.ipynb 65
@patch
def index_to_row_col(self: HexGrid, index: int) -> tuple[int, int]:
    """Convert flat grid index to (row, col)."""
    row = index // self.nCols
    col = index % self.nCols
    return row, col

@patch
def row_col_to_index(self: HexGrid, row: int, col: int) -> int:
    """Convert (row, col) to flat grid index. Returns -1 if out of bounds."""
    if row < 0 or row >= self.nRows or col < 0 or col >= self.nCols:
        return -1
    return row * self.nCols + col

@patch
def index_to_hexposition(self: HexGrid, index: int, origin_index: int = None) -> HexPosition:
    """Convert grid index to HexPosition relative to origin_index."""

    if origin_index is None:
        origin_index = int(len(self.hexes)/2)
        
    # Convert both indices to row/col
    row, col = self.index_to_row_col(index)
    origin_row, origin_col = self.index_to_row_col(origin_index)
    
    # Convert to cube coordinates (odd-r offset)
    q = col - (row - (row & 1)) // 2
    r = row
    s = -q - r
    
    origin_q = origin_col - (origin_row - (origin_row & 1)) // 2
    origin_r = origin_row
    origin_s = -origin_q - origin_r
    
    # Return relative position
    return HexPosition(q - origin_q, r - origin_r, s - origin_s)

@patch
def hexposition_to_index(self: HexGrid, hexpos: HexPosition, origin_index:int = None) -> int:
    if origin_index is None:
        origin_index = int(len(self.hexes)/2)
    """Convert HexPosition (relative to origin) back to grid index.
    Returns -1 if out of bounds."""
    # Get origin's cube coordinates
    origin_row, origin_col = self.index_to_row_col(origin_index)
    origin_q = origin_col - (origin_row - (origin_row & 1)) // 2
    origin_r = origin_row
    origin_s = -origin_q - origin_r
    
    # Add relative position to origin
    abs_q = hexpos.q + origin_q
    abs_r = hexpos.r + origin_r
    abs_s = hexpos.s + origin_s
    
    # Convert cube back to odd-r offset
    row = abs_r
    col = abs_q + (abs_r - (abs_r & 1)) // 2
    
    # Convert to index and check bounds
    return self.row_col_to_index(row, col)

# %% ../nbs/02_primitives.ipynb 66
@patch
def neighborsOf(self: HexGrid, index: int,ring=1) -> list[int]:
    """Get all valid neighbor indices using HexPosition."""
    ring_hexpositions = HexPosition.origin().ring(ring)
    neighbor_indices = [self.hexposition_to_index(hp, index) for hp in ring_hexpositions]
    return [i for i in neighbor_indices if i >= 0]  # Filter out-of-bounds

# %% ../nbs/02_primitives.ipynb 68
@patch
def arrow(self: HexGrid, start:int, end:int, style = StyleCSS("arrow", stroke="black",stroke_width=1)) -> str:
    self.builder.add_style(style)
    
    

        # Get the hex positions. This defaults to postion 0
    start_pos = self.index_to_hexposition(start)
    end_pos = self.index_to_hexposition(end)
    
    # Draw a line between them using cube coordinate interpolation
    path_positions = [self.hexposition_to_index(x) for x in start_pos.line_to(end_pos)]
    start_center = self.hexes[path_positions[0]].center
    end_center = self.hexes[path_positions[1]].center

    
    # Calculate point at 25% along the way
    start_x = start_center.x + 0.25 * (end_center.x - start_center.x)
    start_y = start_center.y + 0.25 * (end_center.y - start_center.y)
    points = [MapCord(start_x, start_y)]
    for x in path_positions[1:-1]:
        points.append(self.hexes[x].center)
    
    # Calculate point at 75% along the way
    start_center = self.hexes[path_positions[-2]].center
    end_center = self.hexes[path_positions[-1]].center
    end_x = start_center.x + 0.75 * (end_center.x - start_center.x)
    end_y = start_center.y + 0.75 * (end_center.y - start_center.y)
    points.append(MapCord(end_x, end_y))
    
    path = MapPath(points, style)
    return path.with_arrowhead()

# %% ../nbs/02_primitives.ipynb 71
class HexWrapper:
    """This class stores svg configuration. """
    def __init__(self,
    header:str = "", # goes in front of the body 
    footer: str = "", # goes in the back
    callBack = lambda grid,index: None #how individual cells are called back
    ):
        self.header = ""
        self.footer = ""
        self.callBack = callBack

    def route(path:str= "/hex_clicked",target:str="#map"):
        return lambda grid,index :  {
        "hx-post": f"{path}", #The post gives the route back to the url
        "hx-vals": f'{{"hex_id":{index}}}', # the parameter needs to be called the same in the route
        "hx-target": f"{target}" # the element we need to update
    }

# %% ../nbs/02_primitives.ipynb 72
@patch
def direction_index(self: HexPosition) -> int | None:
    """Return direction index (0-5) if this is a unit direction, else None."""
    directions = HexPosition.directions()
    for idx, d in enumerate(directions):
        if d == self:
            return idx
    return None

@patch
def commonEdge(self: HexGrid, i: int, j: int) -> tuple[int, int, int, int] | None:
    """Get the shared edge between two hex indices, or None if not adjacent."""
    pos = self.index_to_hexposition(j, i)
    dir_idx = pos.direction_index()
    if dir_idx is None:
        return None
    return self.hexes[i].edgeFrom(dir_idx)


# %% ../nbs/02_primitives.ipynb 76
@dataclass
class HexRegion:
    """A set of adjacent hexes with computed perimeter boundaries."""
    hexes: set[int]  # Set of hex indices
    hex_grid: 'HexGrid'  # Reference to get hex objects
    
    def __post_init__(self):
        self._boundaries = None  # Cached list of MapPath
    
    def _vertex_key(self, v) -> tuple[int, int]:
        """Convert vertex to integer key for reliable hashing."""
        # Multiply by scale factor before rounding to preserve precision
        return int(v.x), int(v.y)
    
    def _key_to_point(self, key) -> MapCord:
        """Convert integer key back to float coordinates."""
        return MapCord(key[0] , key[1])
    
    def centroid_hex(self) -> int:
        """Return the hex index closest to the geometric center."""
        if not self.hexes:
            return None
        
        # Calculate centroid of all hex centers
        cx, cy = 0, 0
        for idx in self.hexes:
            h = self.hex_grid.hexes[idx]
            cx += h.center.x
            cy += h.center.y
        cx /= len(self.hexes)
        cy /= len(self.hexes)
        
        # Find hex closest to centroid
        closest = None
        min_dist = float('inf')
        for idx in self.hexes:
            h = self.hex_grid.hexes[idx]
            dist = (h.center.x - cx)**2 + (h.center.y - cy)**2
            if dist < min_dist:
                min_dist = dist
                closest = idx
        return closest
    
    def perimeter(self) -> [MapCord]:
        """Find all vertices on the perimeter using vertex counting."""
        vertex_counts = {}
        
        for idx in self.hexes:
            hex_obj = self.hex_grid.hexes[idx]
            for v in hex_obj.vertices():
                v_key = self._vertex_key(v)
                vertex_counts[v_key] = vertex_counts.get(v_key, 0) + 1
        
        # Perimeter vertices are touched by 1 or 2 hexes (not 3)
        return [self._key_to_point(k) for k, count in vertex_counts.items() if count < 3]

    @classmethod
    def fromPath(cls, grid: HexGrid, path: list[int]):
        """Create a HexRegion along a list of hex indices."""
        if not path:
            return cls(hexes=set(), hex_grid=grid)
        
        adds = set()
        
        # Process each segment of the path
        for i in range(len(path) - 1):
            start_idx = path[i]
            end_idx = path[i + 1]
            
            # Convert to HexPositions relative to start
            start_pos = grid.index_to_hexposition(start_idx, start_idx)  # (0,0,0)
            end_pos = grid.index_to_hexposition(end_idx, start_idx)
            
            # Get radial path from start to end
            hexes = start_pos.line_to(end_pos)
            
            # Convert back to indices and add
            for hexpos in hexes:
                idx = grid.hexposition_to_index(hexpos, start_idx)
                if idx >= 0:  # Valid index
                    adds.add(idx)
        
        # Don't forget the last hex
        adds.add(path[-1])
        
        return cls(hexes=adds, hex_grid=grid)


# %% ../nbs/02_primitives.ipynb 77
@patch
def __or__(self: HexRegion, other: 'HexRegion') -> 'HexRegion':
    """Union: region1 | region2"""
    return HexRegion(self.hexes | other.hexes, self.hex_grid)

@patch
def __and__(self: HexRegion, other: 'HexRegion') -> 'HexRegion':
    """Intersection: region1 & region2"""
    return HexRegion(self.hexes & other.hexes, self.hex_grid)

@patch
def __sub__(self: HexRegion, other: 'HexRegion') -> 'HexRegion':
    """Difference: region1 - region2"""
    return HexRegion(self.hexes - other.hexes, self.hex_grid)

@patch
def __xor__(self: HexRegion, other: 'HexRegion') -> 'HexRegion':
    """Symmetric difference: region1 ^ region2"""
    return HexRegion(self.hexes ^ other.hexes, self.hex_grid)

@patch
def __contains__(self: HexRegion, idx: int) -> bool:
    """Membership: idx in region"""
    return idx in self.hexes

@patch
def __len__(self: HexRegion) -> int:
    """Size: len(region)"""
    return len(self.hexes)

@patch
def __iter__(self: HexRegion):
    """Iterate over hex indices"""
    return iter(self.hexes)


# %% ../nbs/02_primitives.ipynb 78
@patch
def outside(self:HexRegion,ring=1):
    m = set()
    grid = self.hex_grid
    total = grid.nCols * grid.nRows
    for index in self.hexes:
        ring_hexpositions = HexPosition(0, 0, 0).ring(ring)
        neighbor_indices = [grid.hexposition_to_index(hp, index) for hp in ring_hexpositions]
        for neighbor in neighbor_indices:
            if neighbor >= 0 and neighbor < total and neighbor not in self.hexes:
                m.add(neighbor)
    return HexRegion(m,grid) # Filter out-of-bounds

@patch 
def apply(self:HexRegion,direction:HexPosition):
    m = set()
    grid = self.hex_grid
    total = grid.nCols * grid.nRows
    for index in self.hexes:
        #hp = HexPosition(0, 0, 0).ra(ring) + direction
        neighbor = grid.hexposition_to_index(direction, index) 
        if neighbor >= 0 and neighbor < total :
            m.add(neighbor)
    return HexRegion(m,grid)

@patch 
def shift(self:HexRegion,direction:HexPosition):
    m = set()
    grid = self.hex_grid
    total = grid.nCols * grid.nRows
    for index in self.hexes:
        #hp = HexPosition(0, 0, 0).ra(ring) + direction
        neighbor = grid.hexposition_to_index(direction, index) 
        if neighbor >= 0 and neighbor < total and neighbor not in self.hexes:
            m.add(neighbor)
    return HexRegion(m,grid)

# %% ../nbs/02_primitives.ipynb 79
@patch
def inside(self:HexRegion,ring=1):
    out = self.outside().outside()
    m = self.hexes - out.hexes
    return HexRegion(m,self.hex_grid) # Filter out-of-bounds

# %% ../nbs/02_primitives.ipynb 80
@patch
def perimeter(self: HexRegion) -> list[MapCord]:
    """Find all vertices on the perimeter using vertex counting."""
    # Track both region-hex count and total-hex count per vertex
    region_counts = {}
    total_counts = {}
    
    # Count vertices from region hexes
    for idx in self.hexes:
        hex_obj = self.hex_grid.hexes[idx]
        for v in hex_obj.vertices():
            v_key = self._vertex_key(v)
            region_counts[v_key] = region_counts.get(v_key, 0) + 1
    
    # Count vertices from ALL grid hexes to know total possible
    for idx, hex_obj in enumerate(self.hex_grid.hexes):
        for v in hex_obj.vertices():
            v_key = self._vertex_key(v)
            total_counts[v_key] = total_counts.get(v_key, 0) + 1
    
    # Perimeter = vertices where region count < total count
    # (i.e., at least one neighboring hex is NOT in the region)
    perimeter_vertices = []
    for v_key, region_count in region_counts.items():
        total_count = total_counts.get(v_key, 0)
        if region_count < total_count:
            perimeter_vertices.append(self._key_to_point(v_key))
    
    return perimeter_vertices


# %% ../nbs/02_primitives.ipynb 81
@patch
def demoRegionFromPath(self: PrimitiveDemo):
    # Create a simple grid
    mySize = MapSize(200, 200)
    myBounds = MapRect(MapCord(0, 0), mySize)
    baseStyle = StyleCSS.elevations()[3]
    aGrid = HexGrid.from_bounds(bounds=myBounds, style=baseStyle, radius=20)
    
    print(f"Grid has {aGrid.nRows} rows, {aGrid.nCols} cols = {len(aGrid.hexes)} hexes")
    
    # Define a path through the grid
    # Let's try a simple diagonal path
    path = [0, 5, 10, 15]  # Should go diagonally down-right
    
    print(f"\nPath indices: {path}")
    print("Path hex positions:")
    for idx in path:
        row, col = aGrid.index_to_row_col(idx)
        print(f"  Index {idx}: row={row}, col={col}, center={aGrid.hexes[idx].center}")
    
    # Try to create the region
    try:
        region = HexRegion.fromPath(aGrid, path)
        print(f"\nRegion created with {len(region.hexes)} hexes")
        print(f"Region hexes: {sorted(region.hexes)}")
        
        # Check perimeter
        perimeter = region.perimeter()
        print(f"Perimeter has {len(perimeter)} vertices")
        
        return region
    except Exception as e:
        print(f"\nError creating region: {e}")
        
        traceback.print_exc()
        return None




# %% ../nbs/02_primitives.ipynb 86
@patch
def trace_perimeter(self: HexRegion, debug=False, 
                   style=StyleCSS("perimeter_path", fill="none", 
                                 stroke="#ba3ca3ff", stroke_width=3)):
    """Trace perimeter using commonEdge to find boundary edges."""
    grid = self.hex_grid
    vertex_adj = {}  # vertex_key -> set of adjacent vertices on boundary
    
    # Step 1: Find all perimeter edges
    for idx in self.hexes:
        # Get all neighbors (ring 1 around this hex)
        neighbors = grid.neighborsOf(idx, ring=1)
        
        # Also check for out-of-bounds neighbors by trying all 6 directions
        for hp in HexPosition(0, 0, 0).ring(1):
            neighbor_idx = grid.hexposition_to_index(hp, idx)
            
            # If neighbor is outside region, this edge is on the perimeter
            if neighbor_idx < 0 or neighbor_idx not in self.hexes:
                # Get the common edge (if neighbor exists in grid)
                if neighbor_idx >= 0:
                    edge = grid.commonEdge(idx, neighbor_idx)
                    if edge:  # edge is (x1, y1, x2, y2)
                        k1 = (edge[0], edge[1])
                        k2 = (edge[2], edge[3])
                        
                        vertex_adj.setdefault(k1, set()).add(k2)
                        vertex_adj.setdefault(k2, set()).add(k1)
    
    if debug:
        print(f"Found {len(vertex_adj)} boundary vertices, "
              f"{sum(len(v) for v in vertex_adj.values())//2} coastal edges")
    
    # Step 2: Trace paths by following the adjacency graph
    visited_edges = set()
    paths = []
    remaining = set(vertex_adj.keys())
    
    while remaining:
        # Start a new path
        start = next(iter(remaining))
        path = [start]
        remaining.discard(start)
        
        # Follow the chain
        while True:
            current = path[-1]
            neighbors = vertex_adj.get(current, set())
            
            # Find an unvisited neighbor
            next_vertex = None
            for n in neighbors:
                edge = frozenset([current, n])
                if edge not in visited_edges:
                    next_vertex = n
                    visited_edges.add(edge)
                    break
            
            if next_vertex is None:
                break
            
            path.append(next_vertex)
            remaining.discard(next_vertex)
        
        # Convert vertex keys back to MapCords and create path
        if len(path) > 2:
            coords = [self._key_to_point(k) for k in path]
            paths.append(MapPath(coords, style=style))
            if debug:
                print(f"Traced path with {len(path)} vertices")
    
    return paths  # Return paths and empty gaps list


# %% ../nbs/02_primitives.ipynb 88
@patch
def __lt__(self: MapCord, other: MapCord) -> bool:
    """Less than comparison: first by x, then by y."""
    if self.x != other.x:
        return self.x < other.x
    return self.y < other.y


# %% ../nbs/02_primitives.ipynb 91
@patch
def update(self:HexGrid,wrapper:HexWrapper = HexWrapper(),layer_name="hexes"):

        testBody = ""
        hexWrap = wrapper.callBack

        exportSize = MapSize(max([hex.center.x for hex in self.hexes]),
        max([hex.center.y for hex in self.hexes]))
        self.builder.width = exportSize.width
        self.builder.height = exportSize.height

        for i, hex in enumerate(self.hexes):
            testBody += "\t" +  hex.svg(hexWrap(self,i)) + "\n"
            if len(hex.label) > 0:
                testBody += f"\t\t<text x=\"{hex.center.x}\" y=\"{hex.center.y}\" text-anchor=\"middle\" dominant-baseline=\"middle\""
                if len(hex.labelStyle) > 1:
                    testBody += f" class=\"{hex.labelStyle}\""
                
                testBody += f">{hex.label}</text>\n"
        
        self.builder.adjust(layer_name,testBody)


# %% ../nbs/02_primitives.ipynb 92
@patch
def demoDrawGrid(self:PrimitiveDemo):
    mySize = MapSize(120,120)
    myBounds = MapRect(MapCord(0,0), mySize)
    baseStyle = StyleCSS.elevations()[3]
    aGrid = HexGrid.from_bounds(bounds=myBounds,style=baseStyle)
    
    hexText = StyleCSS("hex-text",fill="red",font_size="14px",font_weight="600",font_family="sans-serif",text_anchor="middle",dominant_baseline="middle",cursor="pointer")

    aGrid.builder.add_style(hexText)
    
    for i, hex in enumerate(aGrid.hexes):
        aGrid.hexes[i].label = f"{i}"
        aGrid.hexes[i].labelStyle = "hex-text"
    
    origin = 5
    ring_hexpositions = HexPosition(0, 0, 0).ring(2)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[0]

    ring_hexpositions = HexPosition(0, 0, 0).ring(1)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[1]
    
    aGrid.update()
    return aGrid.builder.show()


 




# %% ../nbs/02_primitives.ipynb 100
class LinearGradient(Generatable):

    def __init__(self,grid:HexGrid,startHex:Int,endHex:Int,startColor:str,endColor:str,):
        self.startHex = startHex
        self.endHex = endHex
        self.startColor = startColor
        self.endColor = endColor
        self.grid = grid
        self.name =  f"grad_{startHex}_{endHex}"

    
    def poly(self):
        startH = self.grid.hexes[self.startHex]
        endH = self.grid.hexes[self.endHex]
        testBody = ""

        edges = list(startH.edges().intersection(endH.edges()))
        if len(edges) > 0:
            edge = edges[0]

            testBody += "\t" +  "<polygon points=\""
            testBody += f"{startH.center.x:.0f},{startH.center.y:.0f} "
            testBody += f"{edge[0]},{edge[1]} "
            testBody += f"{endH.center.x:.0f},{endH.center.y:.0f} "
            testBody += f"{edge[2]},{edge[3]} "
            testBody += f"\" fill=\"url(#{self.name})\" />\n"

        return testBody
        

    def generate(self) -> str:
        startH = self.grid.hexes[self.startHex]
        endH = self.grid.hexes[self.endHex]
        
        # Calculate vector from start to end
        dx = endH.center.x - startH.center.x
        dy = endH.center.y - startH.center.y
        
        # Use actual coordinates for the gradient
        svg = f'<linearGradient id="{self.name}" '
        svg += f'x1="{startH.center.x}" y1="{startH.center.y}" '
        svg += f'x2="{endH.center.x}" y2="{endH.center.y}" '
        svg += 'gradientUnits="userSpaceOnUse">\n'
        svg += f'  <stop offset="0%" stop-color="{self.startColor}" />\n'
        svg += f'  <stop offset="100%" stop-color="{self.endColor}" />\n'
        svg += '</linearGradient>\n'
        return svg

# %% ../nbs/02_primitives.ipynb 101
@patch
def radial_gradient(self: HexGrid, lookup: dict= {5:"#007fff",6:"#07ff66ff",10:"#ff005dff]"} ):
    """Use overlapping radial gradients for smoother blending."""
    testBody = ""
    
    for i, color in lookup.items():
        hex = self.hexes[i]
        grad_id = f"radial_{i}"
        
        # Create radial gradient fading to transparent
        grad = f'''<radialGradient id="{grad_id}" cx="{hex.center.x}" cy="{hex.center.y}" 
                    r="{self.radius * 1.5}" gradientUnits="userSpaceOnUse">
            <stop offset="0%" stop-color="{color}" stop-opacity="1"/>
            <stop offset="70%" stop-color="{color}" stop-opacity="0.5"/>
            <stop offset="100%" stop-color="{color}" stop-opacity="0"/>
        </radialGradient>'''
        self.builder.add_definition(SVGDef("", grad_id, grad, raw=True))
        
        # Draw a circle with this gradient
        testBody += f'<circle cx="{hex.center.x}" cy="{hex.center.y}" r="{self.radius * 1.5}" fill="url(#{grad_id})"/>\n'
    
    return testBody

# %% ../nbs/02_primitives.ipynb 102
@patch
def gradient(self:HexGrid,lookup = {5:"#007fff",6:"#07ff66ff",10:"#ff005dff]"} ):
    testBody = ""
   
    exportSize = MapSize(max([hex.center.x for hex in self.hexes]),
    max([hex.center.y for hex in self.hexes]))
    self.builder.width = exportSize.width
    self.builder.height = exportSize.height
    

    for i ,v in lookup.items():
        hex = self.hexes[i]

        neighs = [j for j in self.neighborsOf(i) if j > i]
        for j in neighs:
            if j in lookup:
                lg = LinearGradient(self,i,j,lookup[i],lookup[j])
                self.builder.add_definition(lg)
                testBody += lg.poly()

    return testBody

# %% ../nbs/02_primitives.ipynb 103
@patch
def demoGradienGrid(self:PrimitiveDemo):
    mySize = MapSize(120,120)
    myBounds = MapRect(MapCord(0,0), mySize)
    baseStyle = StyleCSS.elevations()[3]
    aGrid = HexGrid.from_bounds(bounds=myBounds,style=baseStyle)
    
    hexText = StyleCSS("hex-text",fill="red",font_size="14px",font_weight="600",font_family="sans-serif",text_anchor="middle",dominant_baseline="middle",cursor="pointer")

    aGrid.builder.add_style(hexText)
    
    for i, hex in enumerate(aGrid.hexes):
        aGrid.hexes[i].label = f"{i}"
        aGrid.hexes[i].labelStyle = "hex-text"
    
    origin = 5
    ring_hexpositions = HexPosition(0, 0, 0).ring(2)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[0]

    ring_hexpositions = HexPosition(0, 0, 0).ring(1)
    ring_indices = [aGrid.hexposition_to_index(hp, origin) for hp in ring_hexpositions]
    ring_indices = [i for i in ring_indices if i >= 0]  # Filter out-of-bounds
    for i in ring_indices:
        aGrid.hexes[i].style = StyleCSS.elevations()[1]
    
    g = aGrid.radial_gradient()
    aGrid.builder.adjust("gradient",g)
    return aGrid.builder.show()
    
