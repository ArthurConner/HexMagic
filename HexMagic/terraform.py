# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09_terraform.ipynb.

# %% auto 0
__all__ = ['SeismicEvent', 'ClimateRenderConfig', 'MapRenderConfig', 'VolcanoSettings', 'LegendLabel', 'Terraform']

# %% ../nbs/09_terraform.ipynb 2
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple
from dataclasses import dataclass,  field, asdict
import json
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

#custom
import inspect
import copy

# %% ../nbs/09_terraform.ipynb 3
from .primitives import MapPath, MapSize, MapRect, MapCord 
from .primitives import HexGrid, HexPosition ,  HexRegion , HexWrapper, unique_windy_edge
from .terrain import Terrain , TerraDemo
from .terrainpatterns import TerrainPatterns
from .climate import TerrainFactory, ClimatePreset
from .hydrology import DrainageBasins
from .styles import  StyleCSS 

# %% ../nbs/09_terraform.ipynb 6
@dataclass
class SeismicEvent:
    kind: str  # e.g., "volcano", "erosion", "glacier", "meteor"
    name: str
    order_id: int
    properties: dict  # string key-value pairs
    adjustment: np.ndarray
    caller: str
    
    def encode(self) -> str:
        """Encode the seismic event to a string format."""
        ret = f"kind:{self.kind}\n"
        ret += f"name:{self.name}\n"
        ret += f"caller:{self.caller}\n"
        ret += f"order_id:{self.order_id}\n"
        
        # Encode properties as tab-separated key=value pairs
        prop_str = '\t'.join([f"{k}={v}" for k, v in self.properties.items()])
        ret += f"properties:{prop_str}\n"
        
        ret += "+adjustment:\n"
        # Encode the numpy array as tab-separated values
        ret += '\t'.join([f"{int(x)}" for x in self.adjustment]) + "\n"
        ret += "-adjustment:\n"
        
        return ret
    
    @staticmethod
    def decode(s: str) -> 'SeismicEvent':
        """Decode a string to create a SeismicEvent."""
        lines = s.strip().split('\n')
        
        kind = None
        name = None
        caller = None
        order_id = None
        properties = {}
        adjustment = None
        in_adjustment = False
        
        for line in lines:
            if in_adjustment:
                if line.startswith('-adjustment:'):
                    in_adjustment = False
                else:
                    # Parse the adjustment array
                    adjustment = np.array([float(x) for x in line.split('\t')])
            elif ':' in line:
                key, val = line.split(':', 1)
                key = key.strip()
                val = val.strip()
                
                if key == 'caller':
                    caller = val
                if key == 'kind':
                    kind = val
                elif key == 'name':
                    name = val
                elif key == 'order_id':
                    order_id = int(val)
                elif key == 'properties':
                    # Parse key=value pairs
                    if val:
                        pairs = val.split('\t')
                        for pair in pairs:
                            if '=' in pair:
                                k, v = pair.split('=', 1)
                                properties[k.strip()] = v.strip()
                elif key == '+adjustment':
                    in_adjustment = True
        
        return SeismicEvent(
            kind=kind,
            name=name,
            order_id=order_id,
            properties=properties,
            adjustment=adjustment,
            caller = caller
        )

# %% ../nbs/09_terraform.ipynb 7
@dataclass
class ClimateRenderConfig:
    mode: str = "climate_zones"
    
    # Rivers
    show_rivers: bool = False
    river_max_count: int = 6
    river_branches: int = 2  # simplify() parameter
    river_color: str = "#1565c0"
    river_opacity: float = 0.7
    river_min_width: float = 1.0
    river_max_width: float = 8.0
    
    # Overlays
    show_elevation_borders: bool = True
    #show_coastline: bool = False
    show_legend: bool = True
    
    debug: bool = False

# %% ../nbs/09_terraform.ipynb 8
@dataclass
class MapRenderConfig:
    show_hexes: bool = True
    show_coastline: bool = False
    animate: bool = False
    show_biomes: bool = False
    title: str = ""
    subtitle: str = ""
    description:str = ""
    icon:str = ""
    background_color: str = "#81b1e1ff"
    climate: ClimateRenderConfig = None
    scale:int = 10 # out of 10
    compass:str = None

# %% ../nbs/09_terraform.ipynb 9
@dataclass
class VolcanoSettings:
    height: int = 300
    rings: int = 2
    variability= 80
    initial_threshold=0.4

# %% ../nbs/09_terraform.ipynb 10
#This currently is under development

@dataclass
class LegendLabel:
    """used for labeling the legend"""
    icon: StyleCSS = None
    label: str = ""
    tip: str = ""
    group:int = 0

# %% ../nbs/09_terraform.ipynb 12
class Terraform:
    def __init__(self, terrain: Terrain,config:MapRenderConfig=None):
        self.terrain = terrain
        self.events: List[SeismicEvent] = []
        # rivers placeholder for later
        self.plates: List[Plate] = []
        if config is None:
            rCofig = ClimateRenderConfig()
            self.config = MapRenderConfig(climate=rCofig)
        else:
            self.config = config
        

    @property
    def grid(self):
        return self.terrain.hexGrid

    @property
    def builder(self):
        return self.grid.builder



    @staticmethod
    def decode(s: str) -> 'Terraform':
        """Decode a string to create a Terraform."""
        lines = s.split('\n')
        
        terrain_lines = []
        event_lines = []
        config_lines = []
        current_section = None
        current_event = []
        plates = []
        
        i = 0
        while i < len(lines):
            line = lines[i]
            
            if line.startswith('+terrain:'):
                current_section = 'terrain'
            elif line.startswith('-terrain:'):
                current_section = None
            elif line.startswith('+configuration:'):
                current_section = 'configuration'
            elif line.startswith('-configuration:'):
                current_section = None
            elif line.startswith('+plate:'):
                current_section = 'plate'
            elif line.startswith('-plate:'):
                current_section = None
            elif line.startswith('+event:'):
                current_section = 'event'
                current_event = []
            elif line.startswith('-event:'):
                if current_event:
                    event_lines.append('\n'.join(current_event))
                current_event = []
                current_section = None
            elif current_section == 'terrain':
                terrain_lines.append(line)
            elif current_section == 'configuration':
                config_lines.append(line)
            elif current_section == 'event':
                current_event.append(line)
            elif current_section == 'plate':
                plates.append(line)
            
            i += 1
        
        # Decode terrain
        terrain_str = '\n'.join(terrain_lines)
        terrain = Terrain.decode(terrain_str)
        
        # Decode configuration
        config = None
        if config_lines:
            config_dict = json.loads('\n'.join(config_lines))
            # Handle nested ClimateRenderConfig
            climate_dict = config_dict.pop('climate', None)
            climate_config = ClimateRenderConfig(**climate_dict) if climate_dict else None
            config = MapRenderConfig(**config_dict, climate=climate_config)
        
        # Create Terraform
        terraform = Terraform(terrain, config=config)
        
        # Decode events
        for event_str in event_lines:
            event = SeismicEvent.decode(event_str)
            terraform.events.append(event)
        
        terraform.plates = [Plate.decode(x, terrain.hexGrid) for x in plates]
        return terraform

        
        
        # Create Terraform
        terraform = Terraform(terrain)

        
        # Decode events
        for event_str in event_lines:
            event = SeismicEvent.decode(event_str)
            terraform.events.append(event)
        
        terraform.plates = [Plate.decode(x,terrain.hexGrid) for x in plates]
        return terraform

# %% ../nbs/09_terraform.ipynb 13
@patch
def encode(self: Terraform) -> str:
    """Encode the Terraform to a string format."""
    ret = "=== TERRAFORM ===\n"
    ret += "+terrain:\n"
    ret += self.terrain.encode()
    ret += "-terrain:\n"
    
    # Configuration section
    ret += "+configuration:\n"
    config_dict = asdict(self.config)
    ret += json.dumps(config_dict, indent=2) + "\n"
    ret += "-configuration:\n"
    
    ret += f"event_count:{len(self.events)}\n"

    if len(self.plates) > 0:
        ret += "+plate:\n"
        for plate in self.plates:
            ret += plate.encode()
        ret += "-plate:\n"
    
    for event in self.events:
        ret += "+event:\n"
        ret += event.encode()
        ret += "-event:\n"
    
    return ret

# %% ../nbs/09_terraform.ipynb 18
@patch
def add_event(self:Terraform, kind: str,  adjustment: np.ndarray,name: str=None, properties: dict={}):
    order_id = len(self.events)  # or use actual timestamp
    if name is None:
        name = f"event_{len(self.events)}"
    caller_name = ", ".join([x.function for x in inspect.stack()][1:3])
    event = SeismicEvent(kind, name, order_id, properties, adjustment,caller_name)
    self.events.append(event)

# %% ../nbs/09_terraform.ipynb 20
@patch
def starterWorld(demo:TerraDemo,createNew = False, debug = False):
    """Create a tropical island with three volcanoes and downsampled rivers."""
    
    # 1. Create blank ocean world with tropical preset
    bounds = MapRect(MapCord(0, 0), MapSize(800, 800))
    if createNew:
        terrain , plates = TerrainFactory.create_ocean_world(
            bounds=bounds,
            preset='tropical',
            radius=15,
            lon_span=5.0,
            num_plates=16,
            ocean_fraction=0.6,
            debug = debug
        )
    else:
        terrain = TerraDemo().bayAreaMap()

    terra = Terraform(terrain)

    mountains = terrain.find_peaks(7,0,exclusion_radius=9)
    for i , epicenter in enumerate(mountains):
        terra.add_event("volcano",
        adjustment = terrain.volcano(center=epicenter, adjusted=200+ ((i+1)*30), num_rings=6),
        name = f"starter_{epicenter}"
        )

    if debug:
        print("\n=== COMPUTING CLIMATE ===")
    terrain.climate.configure(terrain,debug=debug)
    return  terra
    
    



# %% ../nbs/09_terraform.ipynb 22
@patch
def terrainFromEvents(self:Terraform,index=None,prior=None,debug=True):
    if index is None:
        index = len(self.events) -1

    if index < 0 or index >= len(self.events):
        if debug:
            print(f"no events for index {index}")
        return self.terrain.clone()

    if prior is None:
        prior = self.terrain.clone()

        for i in range(index):
            event = self.events[i]
            if debug:
                print(f"appling {i} {event.name} {np.count_nonzero(event.adjustment)}")
            
            prior.elevations += event.adjustment
    else:
        event = self.events[index]
        if debug:
                print(f"now on {index} {event.name}")
        prior.elevations += event.adjustment
    prior.hexGrid.layers = []

    return prior


# %% ../nbs/09_terraform.ipynb 30
@patch
def generate_legend(self: Terraform, labels:[LegendLabel], config: ClimateRenderConfig):
    return ""

# %% ../nbs/09_terraform.ipynb 31
@patch
def generate_climate_legend(self: Terrain , config: ClimateRenderConfig)->[LegendLabel]:
    return []

# %% ../nbs/09_terraform.ipynb 32
@patch
def render_climate_zones(self: Terrain, config: ClimateRenderConfig) -> tuple[str, [LegendLabel]]:
    """
    Render climate zones with precipitation density overlay.
    
    Returns:
        (layer_svg, legend_svg) - two separate SVG strings
    """
    if 'climate' not in self.fields or 'precipitation' not in self.fields:
        # Compute if needed
        if hasattr(self, 'climate') and self.climate is not None:
            self.climate.configure(self, force_recompute=False)
        else:
            raise ValueError("Need climate data - use TerrainFactory.create_ocean_world()")
    
    # Generate the main layer
    layer_svg = self.dottedClimate()
    
    
    # Add elevation borders if requested
    if config.show_elevation_borders:
        layer_svg += self.elevation_borders()
    
    # Add coastline if requested
    #if config.show_coastline:
    #    layer_svg += self.coastline_svg()
    
    # Generate legend
    legend = []
    if config.show_legend:
        legend.extend( self.generate_climate_legend(config))
    
    return layer_svg, legend

# %% ../nbs/09_terraform.ipynb 34
@patch
def render_hydration(self: Terrain, config: ClimateRenderConfig) -> tuple[str, list[LegendLabel]]:
    """
    Render hydration layer with watershed boundaries, flow gradient, and elevation borders.
    
    Returns:
        (layer_svg, legend_labels)
    """
    basin = DrainageBasins(self, debug=config.debug)
    
    layer_svg = ""
    
    # Flow gradient (direction with gradient-based widths)
    #layer_svg += basin.gradient_overlay()

    layer_svg += basin.dotted_watershed_overlay()
    
    # Watershed boundaries
    #layer_svg += basin.boundary_overlay()
    
    # Elevation borders
    if config.show_elevation_borders:
        layer_svg += self.elevation_borders()
    
    # Legend
    legend = []
    #if config.show_legend:
    #    legend = self.generate_hydration_legend(config)
    
    return layer_svg, legend

# %% ../nbs/09_terraform.ipynb 36
@patch
def render_weather(self: Terrain, config: ClimateRenderConfig) -> tuple[str, list[LegendLabel]]:
    """
    Render hydration layer with watershed boundaries, flow gradient, and elevation borders.
    
    Returns:
        (layer_svg, legend_labels)
    """
    
    layer_svg = ""
    
    # Flow gradient (direction with gradient-based widths)
    #layer_svg += basin.gradient_overlay()

    layer_svg += self.render_icon_temperature()
    
    
    # Legend
    legend = []
    #if config.show_legend:
    #    legend = self.generate_hydration_legend(config)
    
    return layer_svg, legend

# %% ../nbs/09_terraform.ipynb 38
@patch
def render_climate(self: Terraform,terrain, event_index: int) -> tuple[str, str]:
    """Render climate-based visualization including rivers."""
    config = self.config.climate
    
    
    legend = []
    ret = ""
    

    
    # Climate zones layer
    if config.mode == "climate_zones":
        climate_layer, legend = terrain.render_climate_zones(config=config)
        ret += climate_layer

    if config.mode == "hydro":
        hydro_layer, legend = terrain.render_hydration(config=config)
        ret += hydro_layer

    if config.mode == "weather":
        weather_layer, legend = terrain.render_weather(config=config)
        ret += weather_layer
    


    # Rivers via watershed system
    if config.show_rivers:
        basin = DrainageBasins(terrain, debug=config.debug)
        rivers = basin.get_major(config.river_max_count)
        
        river_svg = ""
        for river in rivers:
            river_svg += river.simplify(config.river_branches).draw(
                color=config.river_color,
                opacity=config.river_opacity,
                min_width=config.river_min_width,
                max_width=config.river_max_width
            )
        ret += river_svg
    
    # Legend
    legend_svg = self.generate_legend(legend, config)
    
    return ret, legend_svg

# %% ../nbs/09_terraform.ipynb 39
@patch
def render_layer(self: Terraform, event_index: int, prior = None,  debug=False) -> (str, Terrain):
    """Render complete layer content based on terrain state and config.
    
    Args:
        event_index: Which event we're rendering (-1 for base, 0+ for events)
        config: Rendering configuration
    
    Returns:
        Complete layer content as string
    """
    config = self.config
    layer_content = ""

    currentTerrain = self.terrainFromEvents(index=event_index,prior=prior)
    currentTerrain.colorMap()
    currentTerrain.hexGrid.update()

        # Ensure climate data is computed
    if not hasattr(currentTerrain, 'climate') or currentTerrain.climate is None:
        raise ValueError("Terrain must have climate configured")
    
    currentTerrain.climate.configure(currentTerrain,force_recompute=True)
    if debug:
        print(" --- render_layer ---")
        print(config)
    
    smaller = currentTerrain # we will revisit scaling down
    if config.scale < 10:
        smaller = smaller.downsample_climate(config.scale/10)
        smaller.hexGrid._build_hexes()
    
    if debug:
        print(" --- render_layer ---")
        print(config)
    
    
    # Add hexes if requested
    if config.show_hexes:

        if debug:
            print("Showing hexes")
        smaller.colorMap()
        layer_content += smaller.hexGrid.styledHexes()

    
    # Add coastline if requested
    if config.show_coastline:
        if debug:
            print("Showing show_coastline")
        # Find all land hexes (elevation > 0)
        land_hexes = set()
        for i, elevation in enumerate(smaller.elevations):
            if elevation > 0:
                land_hexes.add(i)
        
        if land_hexes:
            region = HexRegion(hexes=land_hexes, hex_grid=smaller.hexGrid,debug=True)
            coastline_style = StyleCSS(
                "coastline", 
                fill="none", 
                stroke="#2c5f2d", 
                stroke_width=3
            )
            paths = region.trace_perimeter(style=coastline_style)
            
            self.builder.add_style(coastline_style)
            for path in paths:
                if path.points[0].distance(path.points[-1]) < 40:
                    cl = path.closed()
                else:
                    cl = path
                curved = cl.make_windy(iterations=1, offset_factor=0.1, seed=42)
                smooth = curved.smooth(iterations=1)
                layer_content += "\t" + smooth.svg() + "\n"
    
    # Add rivers if requested (placeholder for now)
    if config.climate is not None:
        
        layer, legend = self.render_climate(smaller, event_index)
        if debug:
            print(f"Showing climats size {len(layer)}")
        layer_content += layer
    
    return layer_content, smaller

# %% ../nbs/09_terraform.ipynb 44
@patch
def animatedEvents(self:Terraform)->Terrain:
    workTerr = self.terrain.clone()
    overlays = []
    displayTerr = workTerr
    for i in range(len(self.events)):
        mapLayer, sTerra = self.render_layer(i,prior =workTerr)
        overlays.append(mapLayer)
        displayTerr = sTerra

    layer_names = []
    displayTerr.layers= []

    for i , overlay in enumerate(overlays):
        name = f"Event_layer_{i}"
        layer_names.append(name)
        displayTerr.builder.adjust(name,overlay)
    

    anim = LoopingLayerAnimation(layer_names, visible_count=2, step_duration=2, fade_duration=0.1, dim_opacity=0)
    apply_looping_animation( displayTerr.hexGrid.builder,anim)

    return displayTerr

        

# %% ../nbs/09_terraform.ipynb 47
@patch
def render(self: Terraform,  wrapper: HexWrapper = None):
    """Render terraform based on RingMenuState configuration."""

    
    if self.config.animate:
        self.animation_loop(wrapper=wrapper)
    else:

        saveOrg = self.terrain.elevations.copy()
        self.terrain.colorMap()
        for i, event in enumerate(self.events):
            self.terrain.elevations += event.adjustment
        self.terrain.climate.configure(self.terrain)
        climateTex = self.render_layer(0)
        self.builder.adjust("climate",climateTex)
        if wrapper is not None:
            self.terrain.colorMap()
            self.terrain.hexGrid.update(wrapper)
            self.terrain.hexGrid.builder.layers[-1].set_opacity(0.2)
            #self.builder.adjust("touch",tex)
            #print(f"text {tex}")

        self.terrain.elevations = saveOrg

    # Add title and subtitle
    title_elements = ""
    config = self.config
    if self.config.title:
        title_text = config.title 
        title_style = StyleCSS(
            "map-title",
            fill="#2c3e50",
            font_size="24px",
            font_weight="bold",
            font_family="serif",
            text_anchor="middle"
        )
        self.builder.add_style(title_style)
        
        # Position title at top center
        title_x = self.builder.width / 2
        title_y = 30
        title_elements += f'<text x="{title_x}" y="{title_y}" class="map-title">{title_text}</text>\n'
    
    if self.config.subtitle:
        subtitle_text = self.config.subtitle
        subtitle_style = StyleCSS(
            "map-subtitle",
            fill="#7f8c8d",
            font_size="16px",
            font_style="italic",
            font_family="serif",
            text_anchor="middle"
        )
        self.builder.add_style(subtitle_style)
        
        # Position subtitle below title
        subtitle_x = self.builder.width / 2
        subtitle_y = 55
        title_elements += f'<text x="{subtitle_x}" y="{subtitle_y}" class="map-subtitle">{subtitle_text}</text>\n'
  
    self.builder.adjust("title_l",title_elements)

    return
