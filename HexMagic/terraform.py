# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09_terraform.ipynb.

# %% auto 0
__all__ = ['SeismicEvent', 'ClimateRenderConfig', 'MapRenderConfig', 'VolcanoSettings', 'LegendLabel', 'Terraform']

# %% ../nbs/09_terraform.ipynb 2
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple
from dataclasses import dataclass,  field, asdict
import json
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

#custom
import inspect
import copy

# %% ../nbs/09_terraform.ipynb 5
@dataclass
class SeismicEvent:
    kind: str  # e.g., "volcano", "erosion", "glacier", "meteor"
    name: str
    order_id: int
    properties: dict  # string key-value pairs
    adjustment: np.ndarray
    caller: str
    
    def encode(self) -> str:
        """Encode the seismic event to a string format."""
        ret = f"kind:{self.kind}\n"
        ret += f"name:{self.name}\n"
        ret += f"caller:{self.caller}\n"
        ret += f"order_id:{self.order_id}\n"
        
        # Encode properties as tab-separated key=value pairs
        prop_str = '\t'.join([f"{k}={v}" for k, v in self.properties.items()])
        ret += f"properties:{prop_str}\n"
        
        ret += "+adjustment:\n"
        # Encode the numpy array as tab-separated values
        ret += '\t'.join([f"{int(x)}" for x in self.adjustment]) + "\n"
        ret += "-adjustment:\n"
        
        return ret
    
    @staticmethod
    def decode(s: str) -> 'SeismicEvent':
        """Decode a string to create a SeismicEvent."""
        lines = s.strip().split('\n')
        
        kind = None
        name = None
        caller = None
        order_id = None
        properties = {}
        adjustment = None
        in_adjustment = False
        
        for line in lines:
            if in_adjustment:
                if line.startswith('-adjustment:'):
                    in_adjustment = False
                else:
                    # Parse the adjustment array
                    adjustment = np.array([float(x) for x in line.split('\t')])
            elif ':' in line:
                key, val = line.split(':', 1)
                key = key.strip()
                val = val.strip()
                
                if key == 'caller':
                    caller = val
                if key == 'kind':
                    kind = val
                elif key == 'name':
                    name = val
                elif key == 'order_id':
                    order_id = int(val)
                elif key == 'properties':
                    # Parse key=value pairs
                    if val:
                        pairs = val.split('\t')
                        for pair in pairs:
                            if '=' in pair:
                                k, v = pair.split('=', 1)
                                properties[k.strip()] = v.strip()
                elif key == '+adjustment':
                    in_adjustment = True
        
        return SeismicEvent(
            kind=kind,
            name=name,
            order_id=order_id,
            properties=properties,
            adjustment=adjustment,
            caller = caller
        )

# %% ../nbs/09_terraform.ipynb 6
@dataclass
class ClimateRenderConfig:
    mode: str = "climate_zones"
    
    # Rivers
    show_rivers: bool = False
    river_max_count: int = 6
    river_branches: int = 2  # simplify() parameter
    river_color: str = "#1565c0"
    river_opacity: float = 0.7
    river_min_width: float = 1.0
    river_max_width: float = 8.0
    
    # Overlays
    show_elevation_borders: bool = True
    #show_coastline: bool = False
    show_legend: bool = True
    
    debug: bool = False

# %% ../nbs/09_terraform.ipynb 7
@dataclass
class MapRenderConfig:
    show_hexes: bool = True
    show_coastline: bool = False
    animate: bool = False
    show_biomes: bool = False
    title: str = ""
    subtitle: str = ""
    description:str = ""
    icon:str = ""
    background_color: str = "#81b1e1ff"
    climate: ClimateRenderConfig = None
    shrink:int = 1  # was 'skrink'
    compass:str = None

# %% ../nbs/09_terraform.ipynb 8
@dataclass
class VolcanoSettings:
    height: int = 300
    rings: int = 2
    variability= 80
    initial_threshold=0.4

# %% ../nbs/09_terraform.ipynb 9
#This currently is under development

@dataclass
class LegendLabel:
    """used for labeling the legend"""
    icon: StyleCSS = None
    label: str = ""
    tip: str = ""
    group:int = 0

# %% ../nbs/09_terraform.ipynb 11
class Terraform:
    def __init__(self, terrain: Terrain,config:MapRenderConfig=None):
        self.terrain = terrain
        self.events: List[SeismicEvent] = []
        # rivers placeholder for later
        self.plates: List[Plate] = []
        if config is None:
            rCofig = ClimateRenderConfig()
            self.config = MapRenderConfig(climate=rCofig)
        else:
            self.config = config

    @property
    def grid(self):
        return self.terrain.hexGrid

    @property
    def builder(self):
        return self.grid.builder



    @staticmethod
    def decode(s: str) -> 'Terraform':
        """Decode a string to create a Terraform."""
        lines = s.split('\n')
        
        terrain_lines = []
        event_lines = []
        config_lines = []
        current_section = None
        current_event = []
        plates = []
        
        i = 0
        while i < len(lines):
            line = lines[i]
            
            if line.startswith('+terrain:'):
                current_section = 'terrain'
            elif line.startswith('-terrain:'):
                current_section = None
            elif line.startswith('+configuration:'):
                current_section = 'configuration'
            elif line.startswith('-configuration:'):
                current_section = None
            elif line.startswith('+plate:'):
                current_section = 'plate'
            elif line.startswith('-plate:'):
                current_section = None
            elif line.startswith('+event:'):
                current_section = 'event'
                current_event = []
            elif line.startswith('-event:'):
                if current_event:
                    event_lines.append('\n'.join(current_event))
                current_event = []
                current_section = None
            elif current_section == 'terrain':
                terrain_lines.append(line)
            elif current_section == 'configuration':
                config_lines.append(line)
            elif current_section == 'event':
                current_event.append(line)
            elif current_section == 'plate':
                plates.append(line)
            
            i += 1
        
        # Decode terrain
        terrain_str = '\n'.join(terrain_lines)
        terrain = Terrain.decode(terrain_str)
        
        # Decode configuration
        config = None
        if config_lines:
            config_dict = json.loads('\n'.join(config_lines))
            # Handle nested ClimateRenderConfig
            climate_dict = config_dict.pop('climate', None)
            climate_config = ClimateRenderConfig(**climate_dict) if climate_dict else None
            config = MapRenderConfig(**config_dict, climate=climate_config)
        
        # Create Terraform
        terraform = Terraform(terrain, config=config)
        
        # Decode events
        for event_str in event_lines:
            event = SeismicEvent.decode(event_str)
            terraform.events.append(event)
        
        terraform.plates = [Plate.decode(x, terrain.hexGrid) for x in plates]
        return terraform

        
        
        # Create Terraform
        terraform = Terraform(terrain)

        
        # Decode events
        for event_str in event_lines:
            event = SeismicEvent.decode(event_str)
            terraform.events.append(event)
        
        terraform.plates = [Plate.decode(x,terrain.hexGrid) for x in plates]
        return terraform

# %% ../nbs/09_terraform.ipynb 12
@patch
def encode(self: Terraform) -> str:
    """Encode the Terraform to a string format."""
    ret = "=== TERRAFORM ===\n"
    ret += "+terrain:\n"
    ret += self.terrain.encode()
    ret += "-terrain:\n"
    
    # Configuration section
    ret += "+configuration:\n"
    config_dict = asdict(self.config)
    ret += json.dumps(config_dict, indent=2) + "\n"
    ret += "-configuration:\n"
    
    ret += f"event_count:{len(self.events)}\n"

    if len(self.plates) > 0:
        ret += "+plate:\n"
        for plate in self.plates:
            ret += plate.encode()
        ret += "-plate:\n"
    
    for event in self.events:
        ret += "+event:\n"
        ret += event.encode()
        ret += "-event:\n"
    
    return ret

# %% ../nbs/09_terraform.ipynb 14
@patch
def add_event(self:Terraform, kind: str,  adjustment: np.ndarray,name: str=None, properties: dict={}):
    order_id = len(self.events)  # or use actual timestamp
    if name is None:
        name = f"event_{len(self.events)}"
    caller_name = ", ".join([x.function for x in inspect.stack()][1:3])
    event = SeismicEvent(kind, name, order_id, properties, adjustment,caller_name)
    self.events.append(event)

# %% ../nbs/09_terraform.ipynb 15
@patch
def flatten(self: Terraform):
    """Flatten all events into a single terrain state."""
    # Start with initial terrain
    adjustment = np.zeros(len(self.terrain.elevations))
    
    # Apply all adjustments
    for event in self.events:
        adjustment += event.adjustment
    
    self.events = [SeismicEvent("flatten", "flatten", 0, {}, adjustment, "flatten()")]
    
    
    return self.terrain

# %% ../nbs/09_terraform.ipynb 16
@patch
def final(self: Terraform):
    """Flatten all events into a single terrain state."""

    for i, event in enumerate(self.events):
        self.terrain.elevations += event.adjustment
        self.terrain.colorMap()
        self.grid.update()
        
        hex_layer_body = self.builder.layers[0].body
        layer_name = f"event_{i}_{event.name}"
        self.builder.adjust(layer_name, hex_layer_body)

    self.builder.adjust("root","")
    return self.builder

# %% ../nbs/09_terraform.ipynb 19
@patch
def starterTerrain(demo:TerraDemo,debug = False):
    """Create a tropical island with three volcanoes and downsampled rivers."""
    
    # 1. Create blank ocean world with tropical preset
    bounds = MapRect(MapCord(0, 0), MapSize(800, 800))
    terrain , plates = TerrainFactory.create_ocean_world(
        bounds=bounds,
        preset='tropical',
        radius=15,
        lon_span=5.0,
        num_plates=16,
        ocean_fraction=0.6,
        debug = debug
    )

    mountains = terrain.find_peaks(15,4)
    for i , epicenter in enumerate(mountains):
        terrain.elevations += terrain.volcano(center=epicenter, adjusted=20+ ((i+1)*30), num_rings=5)

    if debug:
        print("\n=== COMPUTING CLIMATE ===")
    terrain.climate.configure(terrain,debug=debug)
    return Terraform(terrain)
    
    



# %% ../nbs/09_terraform.ipynb 21
@patch
def generate_legend(self: Terraform, labels:[LegendLabel], config: ClimateRenderConfig):
    return ""

# %% ../nbs/09_terraform.ipynb 22
@patch
def generate_climate_legend(self: Terrain , config: ClimateRenderConfig)->[LegendLabel]:
    return []

# %% ../nbs/09_terraform.ipynb 23
@patch
def render_climate_zones(self: Terrain, config: ClimateRenderConfig) -> tuple[str, [LegendLabel]]:
    """
    Render climate zones with precipitation density overlay.
    
    Returns:
        (layer_svg, legend_svg) - two separate SVG strings
    """
    if 'climate' not in self.fields or 'precipitation' not in self.fields:
        # Compute if needed
        if hasattr(self, 'climate') and self.climate is not None:
            self.climate.configure(self, force_recompute=False)
        else:
            raise ValueError("Need climate data - use TerrainFactory.create_ocean_world()")
    
    # Generate the main layer
    layer_svg = self.dottedClimate()
    
    
    # Add elevation borders if requested
    if config.show_elevation_borders:
        layer_svg += self.elevation_borders()
    
    # Add coastline if requested
    #if config.show_coastline:
    #    layer_svg += self.coastline_svg()
    
    # Generate legend
    legend = []
    if config.show_legend:
        legend.extend( self.generate_climate_legend(config))
    
    return layer_svg, legend

# %% ../nbs/09_terraform.ipynb 25
@patch
def render_hydration(self: Terrain, config: ClimateRenderConfig) -> tuple[str, list[LegendLabel]]:
    """
    Render hydration layer with watershed boundaries, flow gradient, and elevation borders.
    
    Returns:
        (layer_svg, legend_labels)
    """
    basin = DrainageBasins(self, debug=config.debug)
    
    layer_svg = ""
    
    # Flow gradient (direction with gradient-based widths)
    #layer_svg += basin.gradient_overlay()

    layer_svg += basin.dotted_watershed_overlay()
    
    # Watershed boundaries
    #layer_svg += basin.boundary_overlay()
    
    # Elevation borders
    if config.show_elevation_borders:
        layer_svg += self.elevation_borders()
    
    # Legend
    legend = []
    #if config.show_legend:
    #    legend = self.generate_hydration_legend(config)
    
    return layer_svg, legend

# %% ../nbs/09_terraform.ipynb 27
@patch
def render_weather(self: Terrain, config: ClimateRenderConfig) -> tuple[str, list[LegendLabel]]:
    """
    Render hydration layer with watershed boundaries, flow gradient, and elevation borders.
    
    Returns:
        (layer_svg, legend_labels)
    """
    
    layer_svg = ""
    
    # Flow gradient (direction with gradient-based widths)
    #layer_svg += basin.gradient_overlay()

    layer_svg += self.render_icon_temperature()
    
    
    # Legend
    legend = []
    #if config.show_legend:
    #    legend = self.generate_hydration_legend(config)
    
    return layer_svg, legend

# %% ../nbs/09_terraform.ipynb 29
@patch
def render_climate(self: Terraform,terrain, event_index: int) -> tuple[str, str]:
    """Render climate-based visualization including rivers."""
    config = self.config.climate
    
    
    legend = []
    ret = ""
    

    
    # Climate zones layer
    if config.mode == "climate_zones":
        climate_layer, legend = terrain.render_climate_zones(config=config)
        ret += climate_layer

    if config.mode == "hydro":
        hydro_layer, legend = terrain.render_hydration(config=config)
        ret += hydro_layer

    if config.mode == "weather":
        weather_layer, legend = terrain.render_weather(config=config)
        ret += weather_layer
    


    # Rivers via watershed system
    if config.show_rivers:
        basin = DrainageBasins(terrain, debug=config.debug)
        rivers = basin.get_major(config.river_max_count)
        
        river_svg = ""
        for river in rivers:
            river_svg += river.simplify(config.river_branches).draw(
                color=config.river_color,
                opacity=config.river_opacity,
                min_width=config.river_min_width,
                max_width=config.river_max_width
            )
        ret += river_svg
    
    # Legend
    legend_svg = self.generate_legend(legend, config)
    
    return ret, legend_svg
