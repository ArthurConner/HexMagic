# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_climate.ipynb.

# %% auto #0
__all__ = ['Climate', 'WeatherColor', 'Geology', 'TerrainFactory']

# %% ../nbs/07_climate.ipynb #d3dd5cf1
import numpy as np
import sys
import os
import math
import random

#data
from collections import namedtuple
from dataclasses import dataclass,  field, asdict
from typing import List
from enum import Enum

#Jeremy
from dialoghelper import * 
from fastcore.basics import patch
from fasthtml.common import *
from fasthtml.jupyter import *
import httpx

#custom
import inspect
import copy
import colorsys

from .styles import StyleCSS, SVGBuilder, SVGLayer, SVGPatternLoader, preview, app, StyleDemo, LayerAnimation
from .primitives import MapCord, MapSize, MapRect, MapPath, Hex, HexGrid, HexWrapper, HexPosition, hexBackground, HexRegion, windy_edge
from .terrain import  TerraDemo, Terrain, GeoBounds, ClimatePreset
#from terrainpattern import TerrainPatterns
#from HexMagic.river import River, SoilSystem, ErosionModel

# %% ../nbs/07_climate.ipynb #f6041f38
from .terrainpatterns import TerrainPatterns

# %% ../nbs/07_climate.ipynb #96feb0e5
#from HexMagic.river import River, RiverDemo

# %% ../nbs/07_climate.ipynb #c8f8bc45
import math
from collections import deque

# %% ../nbs/07_climate.ipynb #2585598c
import orographic_precipitation as op



# %% ../nbs/07_climate.ipynb #5aa6f966
@patch
def _compute_hex_coordinates(self: Terrain):
    """Compute lat/lon for each hex center."""
    if self.geo is None:
        return
    
    grid = self.hexGrid
    
    # Store lat/lon for each hex
    self.fields['latitude'] = np.zeros(len(self.elevations))
    self.fields['longitude'] = np.zeros(len(self.elevations))
    
    for idx in range(len(self.elevations)):
        row = idx // grid.nCols
        col = idx % grid.nCols
        
        # Normalize to [0, 1]
        row_norm = row / (grid.nRows - 1) if grid.nRows > 1 else 0.5
        col_norm = col / (grid.nCols - 1) if grid.nCols > 1 else 0.5
        
        # Map to geographic coordinates
        # Note: row 0 = top = max latitude
        self.fields['latitude'][idx] = self.geo.lat_max - row_norm * (self.geo.lat_max - self.geo.lat_min)
        self.fields['longitude'][idx] = self.geo.lon_min + col_norm * (self.geo.lon_max - self.geo.lon_min)

@patch
def grid_resolution_meters(self: Terrain):
    """Calculate dx, dy in meters for the grid."""
    if self.geo is None:
        return None, None
    
    # Meters per degree at center latitude
    lat_center = (self.geo.lat_min + self.geo.lat_max) / 2
    lat_rad = math.radians(lat_center)
    
    meters_per_lat = 111132.92  # ~constant
    meters_per_lon = 111132.92 * math.cos(lat_rad)
    
    # Resolution per grid cell
    lat_span = self.geo.lat_max - self.geo.lat_min
    lon_span = self.geo.lon_max - self.geo.lon_min
    
    dy = (lat_span / self.hexGrid.nRows) * meters_per_lat
    dx = (lon_span / self.hexGrid.nCols) * meters_per_lon
    
    return dx, dy



# %% ../nbs/07_climate.ipynb #32ad6cdb
@patch
def california_with_geo(self: TerraDemo):
    """Load California terrain with proper geographic bounds."""
    with open("data/templates/ca_nv_elevation_grid.txt", "r") as f:
        terrain = Terrain.decode(f.read())
    
    # Set the geographic bounds that match your data
    terrain.geo = GeoBounds(
        lat_min=32.5,   # Southern California/Nevada border
        lat_max=42.0,   # Northern California/Oregon border
        lon_min=-124.5, # Pacific coast
        lon_max=-114.5  # Eastern Nevada
    )
    
    # Compute hex coordinates
    terrain._compute_hex_coordinates()
    
    return terrain


# %% ../nbs/07_climate.ipynb #c50c61ff
@patch
def compute_precipitation_sb(self: Terrain,
                              wind_speed=15.0,
                              wind_dir=270.0,
                              precip_base=0.3,
                              # Atmospheric parameters with typical values
                              nm=0.005,         # moist stability frequency [1/s]
                              hw=2500.0,        # water vapor scale height [m]
                              cw=0.005,         # uplift sensitivity [kg/m³]
                              conv_time=1000.0, # conversion time [s]
                              fall_time=1000.0 , # fallout time [s]
                              debug = False
                            
                             ):
    """
    Compute orographic precipitation using Smith-Barstad (2004) model.
    
    Args:
        wind_speed: Wind speed in m/s (typical: 10-20)
        wind_dir: Wind direction in degrees (270 = from west)
        precip_base: Background precipitation rate in mm/h (typical: 0.1-1.0)
        nm: Moist stability frequency [1/s] (typical: 0.005)
        hw: Water vapor scale height [m] (typical: 2000-3000)
        cw: Uplift sensitivity [kg/m³] (typical: 0.003-0.006)
        conv_time: Cloud water conversion time [s] (typical: 500-1500)
        fall_time: Hydrometeor fallout time [s] (typical: 500-1500)
    
    Returns:
        Annual precipitation in mm
    """
    
    
    if self.geo is None:
        raise ValueError("Geographic bounds not set. Use terrain.geo = GeoBounds(...)")
    
    # Get 2D elevation array
    grid = self.hexGrid
    elev_2d = self.elevations.reshape(grid.nRows, grid.nCols)
    
    # Get grid resolution in meters
    dx, dy = self.grid_resolution_meters()
    
    if debug:
        print(f"Grid: {grid.nRows} x {grid.nCols}")
        print(f"Resolution: dx={dx:.0f}m (~{dx/1000:.1f}km), dy={dy:.0f}m (~{dy/1000:.1f}km)")
        print(f"Latitude: {self.geo.lat_min}° to {self.geo.lat_max}° (center: {(self.geo.lat_min + self.geo.lat_max)/2:.1f}°)")
        print(f"Wind: {wind_speed} m/s from {wind_dir}°")
        print(f"Background precip: {precip_base} mm/h")
    
    # Run Smith-Barstad model with all required parameters
    precip_rate = op.compute_orographic_precip(
        elev_2d, dx, dy,
        latitude=(self.geo.lat_min + self.geo.lat_max) / 2,
        wind_speed=wind_speed,
        wind_dir=wind_dir,
        precip_base=precip_base,
        precip_min=0.01,
        nm=nm,
        hw=hw,
        cw=cw,
        conv_time=conv_time,
        fall_time=fall_time
    )
    
    # Convert mm/h to annual mm
    hours_per_year = 8760
    annual_precip = precip_rate * hours_per_year
    
    # Flatten and store
    self.fields['precipitation'] = annual_precip.flatten()
    self.fields['precip_rate_mmh'] = precip_rate.flatten()
    
    if debug:
        print(f"\nPrecipitation range: {annual_precip.min():.0f} - {annual_precip.max():.0f} mm/year")
        print(f"Mean: {annual_precip.mean():.0f} mm/year")
    
    return self.fields['precipitation']


# %% ../nbs/07_climate.ipynb #b09556ab
@patch
def visualize_precipitation(self: Terrain, layer_name="precipitation"):
    """Visualize precipitation with color gradient."""
    if 'precipitation' not in self.fields:
        print("Computing precipitation first...")
        self.compute_precipitation_sb()
    
    precip = self.fields['precipitation']
    
    # Precipitation ranges for California (mm/year)
    thresholds = [0, 150, 300, 500, 750, 1000, 1500, 2000]
    colors = [
        "#8B4513",  # Brown - desert (<150mm)
        "#DEB887",  # Tan - arid (150-300)
        "#F0E68C",  # Khaki - semi-arid (300-500)
        "#9ACD32",  # Yellow-green - dry (500-750)
        "#32CD32",  # Lime green - moderate (750-1000)
        "#228B22",  # Forest green - wet (1000-1500)
        "#006400",  # Dark green - very wet (1500-2000)
        "#004d00",  # Very dark green - rainforest (>2000)
    ]
    
    # Bin precipitation
    precip_indices = np.digitize(precip, thresholds) - 1
    precip_indices = np.clip(precip_indices, 0, len(colors) - 1)
    
    # Create patterns
    patternGen = TerrainPatterns(self)
    patterns = patternGen.ballDensity(len(colors), fills=colors, prefix="precip")
    

    overlay = self.makeOverlay(precip_indices, patterns)
    self.builder.adjust(layer_name, overlay)
    
    return self

# %% ../nbs/07_climate.ipynb #d9da8bcb
@patch
def climate_readiness(self: Terrain):
    """Check what fields are available for climate classification."""
    required = ['elevation', 'temperature', 'precipitation']
    optional = ['latitude', 'longitude', 'distance_to_coast']
    
    print("=== CLIMATE READINESS ===")
    print("\nRequired fields:")
    print(f"  elevation:     {'✓' if len(self.elevations) > 0 else '✗'}")
    print(f"  temperature:   {'✓' if 'temperature' in self.fields else '✗'}")
    print(f"  precipitation: {'✓' if 'precipitation' in self.fields else '✗'}")
    
    print("\nOptional fields:")
    for field in optional:
        print(f"  {field:20s} {'✓' if field in self.fields else '✗'}")
    
    print("\nAvailable fields:")
    for field in sorted(self.fields.keys()):
        print(f"  - {field}")


@patch
def climate_distribution(self: Terrain):
    """Show distribution of climate zones (after classification)."""
    if 'climate' not in self.fields:
        return "Climate not computed yet"
    
    from collections import Counter
    climate_data = self.fields['climate'].astype(int)
    counts = Counter(climate_data)
    total = len(climate_data)
    
    print("\n=== CLIMATE DISTRIBUTION ===")
    climate_names = ['MARINE', 'FRESHWATER', 'TUNDRA', 'DESERT', 
                     'GRASSLAND', 'FOREST', 'JUNGLE']
    
    for i, name in enumerate(climate_names):
        count = counts.get(i, 0)
        pct = 100 * count / total
        bar = '█' * int(40 * count / max(counts.values()))
        print(f"{name:12s}: {bar} {count:4d} ({pct:5.1f}%)")


# %% ../nbs/07_climate.ipynb #21133139
@patch
def mauiMap(self:TerraDemo,debug = False):
    """Load Maui terrain with proper geographic bounds."""
    with open("data/templates/maui.txt", "r") as f:
        terrain = Terrain.decode(f.read())
    
    # Set Maui's geographic bounds
    terrain.geo = GeoBounds(
        lat_min=20.57,   # Southern tip (near Makena)
        lat_max=21.03,   # Northern tip (near Kahakuloa)
        lon_min=-156.69, # Western tip (West Maui)
        lon_max=-155.97  # Eastern tip (Haleakalā/Hāna)
    )
    
    # Compute hex coordinates
    terrain._compute_hex_coordinates()
    
    # Maui-specific precipitation model
    # Trade winds from northeast at ~50-60 degrees
    terrain.compute_precipitation_sb(
    wind_speed=8.0,        # Slightly stronger trade winds
    wind_dir=50.0,         
    precip_base=0.15,      # MUCH higher base moisture (tropical ocean)
    nm=0.008,              # Less stable (more convection)
    hw=2500.0,             # Higher moisture scale height
    cw=0.003,              # MUCH stronger orographic effect
    conv_time=1000.0,      # Faster conversion
    fall_time=1000.0,       # Faster fallout
    debug = debug
)

    return terrain

@patch
def maui(self:TerraDemo,debug=False):
    terrain = self.mauiMap(debug=debug)
    if debug:
        terrain.field_summary('precipitation')
    return len(terrain.hexGrid.builder.xml())


# %% ../nbs/07_climate.ipynb #2ee0ad71
@patch
def compute_distance_from_coast(self: Terrain):
    """Calculate distance from coast for each hex using BFS."""
    from collections import deque
    
    n_hexes = len(self.elevations)
    distances = np.full(n_hexes, np.inf)
    
    # Find all coastal hexes (at or below sea level)
    coastal = [i for i in range(n_hexes) if self.elevations[i] <= 0]
    
    # BFS to calculate distances
    queue = deque()
    for coast_idx in coastal:
        distances[coast_idx] = 0
        queue.append((coast_idx, 0))
    
    visited = set(coastal)
    
    while queue:
        current_idx, dist = queue.popleft()
        
        # Check all neighbors
        neighbors = self.ring(current_idx, 1)
        for neighbor in neighbors:
            if neighbor >= 0 and neighbor not in visited:
                distances[neighbor] = dist + 1
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    self.fields['distance_to_coast'] = distances.astype(float)
    return self.fields['distance_to_coast']



# %% ../nbs/07_climate.ipynb #a30b1c86
@patch
def compute_temperature(self: Terrain,
                        base_temp_south=20.0,    # Southern coast 
                        base_temp_north=14.0,    # Northern coast  
                        lapse_rate=6.5):         # °C per 1000m
    """
    Temperature model for California - mean annual temperature.
    Continentality affects seasonal range, not annual mean.
    """
    if 'distance_to_coast' not in self.fields:
        self.compute_distance_to_coast()
    
    # Latitude-based baseline
    if 'latitude' in self.fields and self.geo:
        lat_fraction = (self.fields['latitude'] - self.geo.lat_min) / (self.geo.lat_max - self.geo.lat_min)
        base_temp = base_temp_south + (base_temp_north - base_temp_south) * lat_fraction
    else:
        base_temp = np.full(len(self.elevations), (base_temp_south + base_temp_north) / 2)
    
    # Apply elevation lapse rate
    temp = base_temp - (self.elevations / 1000.0) * lapse_rate
    
    self.fields['temperature'] = temp
    return temp


# %% ../nbs/07_climate.ipynb #c8df8f67
@patch
def validate_coastal_temps(self: Terrain):
    """Check that coastal areas aren't getting tundra temperatures."""
    if 'distance_to_coast' not in self.fields or 'temperature' not in self.fields:
        return "Missing required fields"
    
    # Check coastal hexes (distance <= 2)
    coastal_mask = self.fields['distance_to_coast'] <= 2
    coastal_temps = self.fields['temperature'][coastal_mask]
    coastal_elevs = self.elevations[coastal_mask]
    
    print("=== COASTAL VALIDATION ===")
    print(f"Coastal hexes: {coastal_mask.sum()}")
    print(f"Temp range: {coastal_temps.min():.1f}°C to {coastal_temps.max():.1f}°C")
    print(f"Elevation range: {coastal_elevs.min():.0f}m to {coastal_elevs.max():.0f}m")
    print(f"Mean temp: {coastal_temps.mean():.1f}°C")
    
    # Check for problematic cold coastal areas
    cold_coastal = (coastal_mask) & (self.fields['temperature'] < 10)
    if cold_coastal.sum() > 0:
        print(f"\n⚠️  {cold_coastal.sum()} coastal hexes < 10°C")
        cold_elevs = self.elevations[cold_coastal]
        print(f"   These are at elevations: {cold_elevs.min():.0f}m to {cold_elevs.max():.0f}m")
        print(f"   (Likely coastal mountains - OK for biomes)")
    else:
        print(f"\n✓ No unrealistic cold coastal areas")
    
    # Check high elevation inland
    high_inland = (self.fields['distance_to_coast'] > 5) & (self.elevations > 2000)
    if high_inland.sum() > 0:
        high_temps = self.fields['temperature'][high_inland]
        print(f"\nHigh mountains (>2000m, inland):")
        print(f"  Count: {high_inland.sum()}")
        print(f"  Temp range: {high_temps.min():.1f}°C to {high_temps.max():.1f}°C")


# %% ../nbs/07_climate.ipynb #e6a9b219
@patch
def caliRain(demo:TerraDemo):

    demo = TerraDemo()
    terrain = demo.california_with_geo()

    # Compute precipitation
    terrain.compute_precipitation_sb(
        wind_speed=10.0,
        wind_dir=270.0,
        precip_base=0.1,
        nm=0.01,
        hw=2000.0,
        cw=0.002,
        conv_time=2000.0,
        fall_time=2000.0
    )

    # Compute distance and temperature
    terrain.compute_distance_to_coast()
    terrain.field_summary('distance_to_coast')

    terrain.compute_temperature( )
    terrain.field_summary('temperature')

    # Compare to precipitation
    terrain.compare_fields('elevation', 'temperature')
    terrain.compare_fields('precipitation', 'temperature')
    terrain.validate_coastal_temps()


# %% ../nbs/07_climate.ipynb #fa24bc48
@patch
def maui(self:TerraDemo,debug=True):
    terrain = self.mauiMap(debug=debug)
    if debug:
        terrain.field_summary('precipitation')
            
        terrain.compute_distance_to_coast()
        terrain.field_summary('distance_to_coast')
        terrain.compute_temperature()  # Tropical base
        terrain.field_summary('temperature')

        # Compare to precipitation
        terrain.compare_fields('elevation', 'temperature')
        terrain.compare_fields('precipitation', 'temperature')
        terrain.validate_coastal_temps()

# %% ../nbs/07_climate.ipynb #af47db95
from enum import Enum

class Climate(Enum):
    MARINE = 0        # Ocean/sea
    FRESHWATER = 1    # Lakes/rivers
    TUNDRA = 2        # Cold, low precipitation
    DESERT = 3        # Hot/cold, very low precipitation
    GRASSLAND = 4     # Moderate temp, moderate precipitation
    FOREST = 5        # Moderate temp, high precipitation
    JUNGLE = 6        # Hot, very high precipitation







# %% ../nbs/07_climate.ipynb #31d201cb
@patch
def configure(preset:ClimatePreset,terrain: Terrain, force_recompute: bool = False,debug=False):
    """
    Apply the stored climate preset to compute precipitation, temperature, and climate zones.
    
    Args:
        terrain: Terrain with climate_preset set
        force_recompute: Recompute even if fields already exist
    """
   
    
    # Compute precipitation
    if 'precipitation' not in terrain.fields or force_recompute:
        if debug:
            print("\nComputing precipitation...")
        terrain.compute_precipitation_sb(
            wind_speed=preset.wind_speed,
            wind_dir=preset.wind_dir,
            precip_base=preset.precip_base,
            nm=preset.nm,
            hw=preset.hw,
            cw=preset.cw,
            conv_time=preset.conv_time,
            fall_time=preset.fall_time
        )
    
    # Compute distance to coast
    if 'distance_to_coast' not in terrain.fields or force_recompute:
        if debug:
            print("Computing distance to coast...")
        terrain.compute_distance_to_coast()
    
    # Compute temperature
    if 'temperature' not in terrain.fields or force_recompute:
        if debug:
            print("Computing temperature...")
        terrain.compute_temperature(
            base_temp_south=preset.base_temp_range[0],
            base_temp_north=preset.base_temp_range[1],
            lapse_rate=preset.lapse_rate
        )
    
    # Compute climate zones
    if 'climate' not in terrain.fields or force_recompute:
        if debug:
            print("Computing climate zones...")
        terrain.compute_climate()
        if debug:
            terrain.summarize_climate()


# %% ../nbs/07_climate.ipynb #844e3601
@patch
def summarize_climate(self: Terrain):
    """Print summary statistics of climate distribution."""
    if 'climate' not in self.fields:
        print("No climate data - run compute_climate() first")
        return
    
    climate = self.fields['climate']
    total = len(climate)
    
    print("\n=== CLIMATE DISTRIBUTION ===")
    print("-" * 40)
    for climate_type in Climate:
        count = np.sum(climate == climate_type.value)
        pct = 100 * count / total
        bar = '█' * int(30 * count / total)
        print(f"{climate_type.name:12s}: {bar} {count:4d} ({pct:5.1f}%)")
    
    print("\n=== FIELD STATS ===")
    if 'temperature' in self.fields:
        t = self.fields['temperature']
        print(f"Temperature: {t.min():.1f}°C to {t.max():.1f}°C (mean: {t.mean():.1f}°C)")
    
    if 'precipitation' in self.fields:
        p = self.fields['precipitation']
        print(f"Precipitation: {p.min():.0f}mm to {p.max():.0f}mm (mean: {p.mean():.0f}mm)")


# %% ../nbs/07_climate.ipynb #275e7173
## pass 2
@patch
def compute_climate(self: Terrain):
    """Classify climate zones based on temperature and precipitation."""
    n_hexes = len(self.elevations)
    
    if 'temperature' not in self.fields:
        raise ValueError("Must compute temperature first")
    if 'precipitation' not in self.fields:
        raise ValueError("Must compute precipitation first")
    
    climate = np.zeros(n_hexes, dtype=int)
    temp = self.fields['temperature']
    precip = self.fields['precipitation']
    
    for i in range(n_hexes):
        elev = self.elevations[i]
        t = temp[i]
        p = precip[i]
        
        # Marine (ocean/sea)
        if elev <= 0:
            climate[i] = Climate.MARINE.value
        
        # Tundra (very cold) - stricter threshold
        elif t < 0:  # Changed from 5 to 0
            climate[i] = Climate.TUNDRA.value
        
        # Desert (very dry)
        elif p < 250:
            climate[i] = Climate.DESERT.value
        
        # Jungle (hot and very wet)
        elif t > 20 and p > 1500:
            climate[i] = Climate.JUNGLE.value
        
        # Forest (good rainfall)
        elif p > 750:  # Changed from 800
            climate[i] = Climate.FOREST.value
        
        # Grassland (moderate conditions)
        elif p >= 250:
            climate[i] = Climate.GRASSLAND.value
        
        # Fallback to desert
        else:
            climate[i] = Climate.DESERT.value
    
    self.fields['climate'] = climate
    return climate


# %% ../nbs/07_climate.ipynb #b91b5e67
@patch
def add_climate_overlay(self: Terrain, layer_name="climate"):
    """Visualize climate zones with appropriate colors."""
    opacity = 0.5
    
    climate_colors = {
        Climate.MARINE.value: "#1e88e5",
        Climate.FRESHWATER.value: "#42a5f5",
        Climate.TUNDRA.value: "#e3f2fd",
        Climate.DESERT.value: "#fdd835",
        Climate.GRASSLAND.value: "#9ccc65",
        Climate.FOREST.value: "#2e7d32",
        Climate.JUNGLE.value: "#1b5e20",
    }
    
    if 'climate' not in self.fields:
        self.compute_climate()
    
    climate_indices = self.fields['climate'].astype(int)
    
    # Create patterns
    patternGen = TerrainPatterns(self)
    colors = [climate_colors[i] for i in range(len(Climate))]
    patterns = patternGen.ballDensity(len(colors), fills=colors, prefix="climate")
    
     # Add opacity to pattern styles
    for pattern in patterns:
        pattern.opacity = opacity  # This may need adjustment based on your StyleCSS implementation
    
    # Generate overlay for all hexes
    overlay = self.makeOverlay(climate_indices, patterns)
    
    self.builder.adjust(layer_name, overlay)


# %% ../nbs/07_climate.ipynb #06b01099
@patch
def downsample_climate(self: Terrain, scale=0.5,sample_radius=1):
    """Downsample terrain with all climate data preserved.
    
    This intelligently handles:
    - Elevation (max to preserve peaks)
    - Temperature (weighted average)
    - Precipitation (weighted average)
    - Distance to coast (min - closest coast matters)
    - Climate zones (mode - most common type)
    - Geographic coordinates (weighted average)
    
    Args:
        scale: Fraction of original size (0.5 = half size, 0.33 = third size)
    """
    
    # Helper to get hex pattern for sampling
    def hexes_in_range(n):
        """Finding all hexes within distance N from origin"""
        results = []
        for q in range(-n, n + 1):
            for r in range(max(-n, -q - n), min(n, -q + n) + 1):
                s = -q - r
                results.append(HexPosition(q, r, s))
        return results
    
    ring_pattern = hexes_in_range(sample_radius)
    
    # Start with elevation using max (preserve peaks)
    new_elevations, nRows, nCols = self.convolution(
        self.elevations, ring_pattern, scale, method='max')
    
    # Create new terrain with downsampled grid
    grid = HexGrid(
        nRows=nRows,
        nCols=nCols,
        radius=self.hexGrid.radius,
        style=self.hexGrid.style
    )
    
    mySize = MapSize(400, 400)  # These get dropped
    myBounds = MapRect(MapCord(0, 0), mySize)
    new_terrain = Terrain(myBounds, radius=15)
    new_terrain.hexGrid = grid
    new_terrain.elevations = new_elevations
    
    # Copy style properties
    new_terrain.colorLevels = self.colorLevels.copy() if self.colorLevels else None
    new_terrain.elevationDelta = self.elevationDelta
    new_terrain.seaLevel = self.seaLevel
    new_terrain.climate = self.climate
    
    # Downsample all fields with appropriate methods
    field_methods = {
        'temperature': 'weighted_avg',
        'precipitation': 'weighted_avg',
        'precip_rate_mmh': 'weighted_avg',
        'distance_to_coast': 'min',  # Closest coast matters
        'latitude': 'weighted_avg',
        'longitude': 'weighted_avg',
        'climate': 'mode',  # Most common climate type
        'temp_range': 'weighted_avg',
    }
    
    for field_name, method in field_methods.items():
        if field_name in self.fields:
            downsampled, _, _ = self.convolution(
                self.fields[field_name], ring_pattern, scale, method=method)
            new_terrain.fields[field_name] = downsampled
    
    # Add color styles
    if new_terrain.colorLevels:
        for color in new_terrain.colorLevels:
            new_terrain.hexGrid.builder.add_style(color)
    
    return new_terrain


# %% ../nbs/07_climate.ipynb #f6ae946f
class WeatherColor:
    """Color scheme for weather map."""

    def __init__(self,color: str = "#000000"):
        self.color = color  # <-- Need the assignment!
        self.r, self.g, self.b = int(color[1:3], 16), int(color[3:5], 16), int(color[5:7], 16)
        self.h, self.l, self.s = colorsys.rgb_to_hls(self.r/255, self.g/255, self.b/255)

    def __str__(self):
        return self.color

    def __repr__(self):
        return f"r:{self.r:02} g:{self.g:02} b:{self.b:02}   "

    
    @staticmethod
    def temp_to_color(temp: float) -> 'WeatherColor':
        """Map temperature to smooth weather map gradient (purple → blue → green → yellow → red)."""
  
        
        # Define color stops: (temperature, hex_color)
        stops = [
            (-15, "#8B4789"),  # Purple (very cold)
            (0,   "#4A90E2"),  # Blue (freezing)
            (10,  "#50C878"),  # Green (cool)
            (20,  "#F4D03F"),  # Yellow (warm)
            (30,  "#E74C3C"),  # Red (hot)
        ]
        
        # Clamp temperature to range
        if temp <= stops[0][0]:
            return stops[0][1]
        if temp >= stops[-1][0]:
            return stops[-1][1]
        
        # Find the two stops to interpolate between
        for i in range(len(stops) - 1):
            temp1, color1 = stops[i]
            temp2, color2 = stops[i + 1]
            
            if temp1 <= temp <= temp2:
                # Calculate interpolation factor (0 to 1)
                factor = (temp - temp1) / (temp2 - temp1)
                
                # Convert hex to RGB
                r1, g1, b1 = int(color1[1:3], 16), int(color1[3:5], 16), int(color1[5:7], 16)
                r2, g2, b2 = int(color2[1:3], 16), int(color2[3:5], 16), int(color2[5:7], 16)
                
                # Interpolate in RGB space
                r = int(r1 + (r2 - r1) * factor)
                g = int(g1 + (g2 - g1) * factor)
                b = int(b1 + (b2 - b1) * factor)
                
                return WeatherColor(f"#{r:02x}{g:02x}{b:02x}")
        
        return WeatherColor("#808080" ) # Fallback gray
    
   
    def adjust_brightness(self, elevation: float, max_elev: float = 3000.0, range_pct: float = 0.10) -> 'WeatherColor':
        """Adjust color brightness based on elevation.
        
        Args:
            color: Hex color string
            elevation: Elevation in meters
            max_elev: Maximum elevation for normalization
            range_pct: Brightness adjustment range (0.10 = ±10%)
        """
        import colorsys
        color = self.color
        
        # Normalize elevation to [-1, 1] range
        elev_norm = np.clip(elevation / max_elev, 0, 1) * 2 - 1
        
        
        
        # Adjust lightness: higher elevation = brighter (within range_pct)
        l = self.l + (elev_norm * range_pct)
        l = np.clip(l, 0, 1)
        
        # Convert back to RGB
        r, g, b = colorsys.hls_to_rgb(self.h, l, self.s)
        
        return  WeatherColor(f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}")
    
    
    def adjust_saturation(self, precip: float, climate_preset: ClimatePreset) -> 'WeatherColor':
        """Adjust color saturation based on precipitation.
        
        Args:
            color: Hex color string
            precip: Precipitation in mm/year
            climate_preset: ClimatePreset with precip_bins
        """
        color = self.color
        
        # Normalize precipitation using climate's bins
        bins = climate_preset.precip_bins
        if precip <= bins[0]:
            sat_factor = 0.5  # Very dry = 50% saturation
        elif precip >= bins[-1]:
            sat_factor = 1.0  # Very wet = 100% saturation
        else:
            # Linear interpolation between bins
            for i in range(len(bins) - 1):
                if bins[i] <= precip <= bins[i+1]:
                    sat_factor = 0.5 + 0.5 * ((precip - bins[i]) / (bins[i+1] - bins[i]))
                    break
        
       
        
        # Adjust saturation
        s = self.s * sat_factor
        s = np.clip(s, 0, 1)
        
        # Convert back to RGB
        r, g, b = colorsys.hls_to_rgb(self.h, self.l, s)
        
        return WeatherColor(f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}")

@patch
def render_icon_temperature(self: Terrain, ocean_color: str = "#2c5f8d") -> str:
    """Render hexes with inline fill based on temperature gradient.
    
    Args:
        ocean_color: Solid color for ocean hexes
    
    Returns:
        SVG string with solid-colored hexes
    """
    if 'temperature' not in self.fields:
        raise ValueError("Temperature field not computed")
    
    if 'precipitation' not in self.fields:
        raise ValueError("Precipitation field not computed")
    
    overlay = ""
    grid = self.hexGrid
    
    # Find max elevation for normalization
    land_elevs = self.elevations[self.elevations > 0]
    max_elev = land_elevs.max() if len(land_elevs) > 0 else 3000.0
    
    for i in range(len(self.elevations)):
        if self.elevations[i] <= 0:
            # Ocean
            color = ocean_color
        else:
            # Land: temperature gradient
            temp = self.fields['temperature'][i]
            color = WeatherColor.temp_to_color(temp)
            
            # Modulate by elevation (brightness)
            color = color.adjust_brightness( self.elevations[i], max_elev)
            
            # Modulate by precipitation (saturation)
            if self.climate:
                color = color.adjust_saturation( self.fields['precipitation'][i], self.climate)
        
        # Generate polygon with inline fill
        hex_obj = grid.hexes[i]
        points = " ".join([f"{p.x:.0f},{p.y:.0f}" for p in hex_obj.vertices()])
        overlay += f'\t<polygon points="{points}" fill="{color}"/>\n'
    
    return overlay

# %% ../nbs/07_climate.ipynb #127014d9
@patch
def gradient_temperature(self: Terrain, ocean_color: str = "#2c5f8d") -> str:
    """Render hexes with inline fill based on temperature gradient.
    
    Args:
        ocean_color: Solid color for ocean hexes
    
    Returns:
        SVG string with solid-colored hexes
    """
    if 'temperature' not in self.fields:
        raise ValueError("Temperature field not computed")
    
    if 'precipitation' not in self.fields:
        raise ValueError("Precipitation field not computed")
    
    overlay = ""
    grid = self.hexGrid
    
    # Find max elevation for normalization
    land_elevs = self.elevations[self.elevations > 0]
    max_elev = land_elevs.max() if len(land_elevs) > 0 else 3000.0
    lookUp = {}
    
    for i in range(len(self.elevations)):
        if self.elevations[i] <= 0:
            # Ocean
            color = ocean_color
        else:
            # Land: temperature gradient
            temp = self.fields['temperature'][i]
            color = WeatherColor.temp_to_color(temp)
            
            # Modulate by elevation (brightness)
            color = color.adjust_brightness( self.elevations[i], max_elev)
            
            # Modulate by precipitation (saturation)
            if self.climate:
                color = color.adjust_saturation( self.fields['precipitation'][i], self.climate)
        
        # Generate polygon with inline fill
        lookUp[i] = color
    overlay = self.hexGrid.radial_gradient(lookUp)
    
    return overlay


# %% ../nbs/07_climate.ipynb #4e0021d9
@patch
def makeClimateOverlay(self: Terrain, climate_data, precip_data, all_patterns: list[SVGBuilder]) -> str:
    """
    Create overlay for climate+precipitation visualization.
    
    Args:
        climate_data: array of climate type values (0-6)
        precip_data: array of precipitation values (mm/year)
        all_patterns: list of 35 patterns (7 climates * 5 precip levels)
    
    Returns:
        SVG string for the overlay
    """
    testBody = ""
    grid = self.hexGrid
    preset = self.climate
    
    # Track which patterns are actually used
    used_patterns = set()
    
    for i in range(len(climate_data)):
        climate_val = int(climate_data[i])
        precip = precip_data[i]
        precip_level = preset.get_precip_level(precip)
        
        # Calculate flat pattern index
        pattern_idx = climate_val * 5 + precip_level
        
        # Bounds check
        if pattern_idx >= 0 and pattern_idx < len(all_patterns):
            used_patterns.add(pattern_idx)
            
            patName = all_patterns[pattern_idx].attributes['id']
            fill = f"url(#{patName})"
            
            ret = "<polygon points=\""
            hex = grid.hexes[i]
            for point in hex.vertices():
                ret += f"{point.x:.0f},{point.y:.0f} "
            ret += f"\" style=\"fill:{fill}\""
            ret += "/>"
            
            testBody += "\t" + ret + "\n"
    
    # Only add used patterns to builder
    for pattern_idx in sorted(used_patterns):
        grid.builder.add_definition(all_patterns[pattern_idx])
    
    return testBody

# %% ../nbs/07_climate.ipynb #2e870fe7
@patch
def dottedClimate(self: Terrain, 
                  flow_levels: int = 5,
                  min_density: float = 0.25,  # Minimum dot density for dry areas
                  debug: bool = False) -> str:
    """Combine climate colors with precipitation-based dot density.
    
    Args:
        flow_levels: Number of dot density levels (default 5)
        min_density: Minimum density for low-precip areas (0.25 = 25%)
        debug: Print pattern generation info
    
    Returns:
        SVG string for the overlay
    """
    
    if 'climate' not in self.fields or 'precipitation' not in self.fields:
        raise ValueError("Need both climate and precipitation computed")
    
    # Define climate colors (muted palette)
    climate_colors = {
        Climate.MARINE: "#A9B9D4",
        Climate.FRESHWATER: "#7BA3C0",
        Climate.TUNDRA: "#8E7159",
        Climate.DESERT: "#D8A48F",
        Climate.GRASSLAND: "#B9B291",
        Climate.FOREST: "#7A9B76",
        Climate.JUNGLE: "#5D7C5A",
    }
    
    # Generate patterns for each climate type
    patternGen = TerrainPatterns(self)
    all_patterns = []
    
    for climate_type in Climate:
        color = climate_colors.get(climate_type, "#cccccc")
        
        # Create flow_levels density patterns for this climate color
        patterns = patternGen.ballDensity(
            levels=flow_levels + 3,
            fills=[color],
            prefix=f"{climate_type.name.lower()}_ball"
        )[:flow_levels]
        
        if debug:
            print(f"{climate_type.name}: generated {len(patterns)} patterns with color {color}")
        
        all_patterns.extend(patterns)
    
    # Build overlay
    grid = self.hexGrid
    overlay = ""
    used_patterns = set()
    
    climate_data = self.fields['climate']
    precip_data = self.fields['precipitation']
    
    # Find max precipitation for normalization
    max_precip = precip_data.max()
    min_precip = precip_data.min()
    
    if debug:
        print(f"\nPrecipitation range: {min_precip:.0f} - {max_precip:.0f} mm/year")
        print(f"Min density: {min_density * 100}%")
    
    # Generate hex polygons
    for i in range(len(climate_data)):
        climate_val = int(climate_data[i])
        precip = precip_data[i]
        
        # Normalize precipitation to [min_density, 1.0] range
        if max_precip > min_precip:
            normalized_precip = (precip - min_precip) / (max_precip - min_precip)  # [0, 1]
            # Scale to [min_density, 1.0]
            scaled_precip = min_density + normalized_precip * (1.0 - min_density)
            precip_level = int(scaled_precip * (flow_levels - 1))
            precip_level = min(precip_level, flow_levels - 1)
        else:
            precip_level = 0
        
        # Calculate pattern index: climate_val * flow_levels + precip_level
        pattern_idx = climate_val * flow_levels + precip_level
        
        # Bounds check
        if pattern_idx >= 0 and pattern_idx < len(all_patterns):
            used_patterns.add(pattern_idx)
            
            patName = all_patterns[pattern_idx].attributes['id']
            fill = f"url(#{patName})"
            
            # Generate polygon
            hex_obj = grid.hexes[i]
            ret = "<polygon points=\""
            for point in hex_obj.vertices():
                ret += f"{point.x:.0f},{point.y:.0f} "
            ret += f"\" style=\"fill:{fill}\"/>"
            
            overlay += "\t" + ret + "\n"
    
    # Add used patterns to builder
    for pattern_idx in sorted(used_patterns):
        grid.builder.add_definition(all_patterns[pattern_idx])
    
    if debug:
        print(f"\nUsed {len(used_patterns)} patterns out of {len(all_patterns)}")
    
    return overlay


# %% ../nbs/07_climate.ipynb #6ea71e52
@patch
def add_climate_overlay(self: Terrain, layer_name="climate_precip",debug=False):
    """Combine climate colors with precipitation-based dot density."""
   
    overlay =  self.dottedClimate(debug=debug)
    self.hexGrid.builder.adjust(layer_name, overlay)
    
    return self

# %% ../nbs/07_climate.ipynb #91f412fa
@patch  
def show(self: River, builder: SVGBuilder, layer: str = "river", 
         style: dict = None):
    """Display river on SVG builder.
    
    Args:
        builder: SVGBuilder to add river to
        layer: Layer name for the river
        style: Dict of SVG style attributes (stroke, stroke-width, opacity, etc.)
    """
    if self.tree.size() == 0:
        return
    
    # Default style
    default_style = {
        'fill': 'none',
        'stroke': '#1565c0',
        'stroke-width': 3,
        'opacity': 0.7
    }
    
    if style:
        default_style.update(style)
    
    # Create StyleCSS from dict
    river_style = StyleCSS(
        layer,
        fill=default_style.get('fill', 'none'),
        stroke=default_style.get('stroke', '#1565c0'),
        stroke_width=default_style.get('stroke-width', 3),
        opacity=default_style.get('opacity', 0.7)
    )
    
    builder.add_style(river_style)
    
    # Generate SVG using existing svg() method
    svg_content = self.svg(styles=[river_style])
    builder.adjust(layer, svg_content)


# %% ../nbs/07_climate.ipynb #8f8d786e
from .voronoi import generate_plate_terrain

# %% ../nbs/07_climate.ipynb #bab14741
@patch
def recomputeClimate(self:Terrain):
    self.climate.configure(self)

# %% ../nbs/07_climate.ipynb #f0bcfe5c
class Geology:

    def __init__(self,terrain,plates, num_plates=None, 
                          age = 0.25,
                          
                          debug = False):
        self.terrain = terrain
        self.plates = plates
        self.soil = SoilSystem.from_plates(terrain, plates, debug=debug)
        if debug:
            print(f"\n=== Before erosion (age={age}) ===")
            print(f"Max elev: {terrain.elevations.max():.0f}")
        
        self.model = ErosionModel(self.terrain, self.soil, age=age)
        #self.model.erode(iterations=3, base_rate=3.0)
        

# %% ../nbs/07_climate.ipynb #29647756
class TerrainFactory:
    """Factory for creating terrains with realistic climate parameters."""
    
    PRESETS = {
    'tropical': ClimatePreset(
        name='Tropical',
        lat_range=(0, 15),
        base_temp_range=(26, 28),
        wind_speed=8.0,
        wind_dir=90.0,
        precip_base=0.2,
        nm=0.008,
        hw=2500.0,
        cw=0.004,
        conv_time=1000.0,
        fall_time=1000.0,
        lapse_rate=5.5,
        precip_bins=(1500, 2500, 4000, 6000),  # High rainfall expected
        description="Hot, humid, high rainfall. Trade winds from east."
    ),
    
    'subtropical': ClimatePreset(
        name='Subtropical',
        lat_range=(15, 30),
        base_temp_range=(20, 24),
        wind_speed=10.0,
        wind_dir=270.0,
        precip_base=0.12,
        nm=0.009,
        hw=2200.0,
        cw=0.003,
        conv_time=1200.0,
        fall_time=1200.0,
        lapse_rate=6.0,
        precip_bins=(600, 1000, 1800, 3000),  # Moderate
        description="Warm, moderate rainfall. Mediterranean-like."
    ),
    
    'mediterranean': ClimatePreset(
        name='Mediterranean',
        lat_range=(30, 45),
        base_temp_range=(14, 18),
        wind_speed=12.0,
        wind_dir=270.0,
        precip_base=0.08,
        nm=0.01,
        hw=2000.0,
        cw=0.0025,
        conv_time=1500.0,
        fall_time=1500.0,
        lapse_rate=6.5,
        precip_bins=(250, 500, 900, 1400),  # Drier
        description="Mild winters, dry summers. California-like."
    ),
    
    'temperate': ClimatePreset(
        name='Temperate',
        lat_range=(35, 55),
        base_temp_range=(8, 14),
        wind_speed=15.0,
        wind_dir=270.0,
        precip_base=0.15,
        nm=0.012,
        hw=1800.0,
        cw=0.003,
        conv_time=1500.0,
        fall_time=1500.0,
        lapse_rate=6.5,
        precip_bins=(800, 1400, 2200, 3500),  # Wet
        description="Four seasons, moderate rainfall. Pacific Northwest-like."
    ),
    
    'continental': ClimatePreset(
        name='Continental',
        lat_range=(40, 60),
        base_temp_range=(2, 10),
        wind_speed=12.0,
        wind_dir=270.0,
        precip_base=0.08,
        nm=0.013,
        hw=1600.0,
        cw=0.002,
        conv_time=2000.0,
        fall_time=2000.0,
        lapse_rate=7.0,
        precip_bins=(200, 400, 700, 1200),  # Dry interior
        description="Hot summers, cold winters, low rainfall. Central Asia-like."
    ),
    
    'subarctic': ClimatePreset(
        name='Subarctic',
        lat_range=(55, 70),
        base_temp_range=(-5, 5),
        wind_speed=10.0,
        wind_dir=270.0,
        precip_base=0.05,
        nm=0.015,
        hw=1400.0,
        cw=0.0015,
        conv_time=2500.0,
        fall_time=2500.0,
        lapse_rate=7.5,
        precip_bins=(150, 300, 500, 800),  # Low precipitation
        description="Long cold winters, short cool summers. Alaska-like."
    ),
    
    'arctic': ClimatePreset(
        name='Arctic',
        lat_range=(70, 85),
        base_temp_range=(-15, -5),
        wind_speed=8.0,
        wind_dir=0.0,
        precip_base=0.02,
        nm=0.018,
        hw=1200.0,
        cw=0.001,
        conv_time=3000.0,
        fall_time=3000.0,
        lapse_rate=8.0,
        precip_bins=(50, 100, 200, 400),  # Very dry
        description="Extremely cold, very low precipitation. Ice cap climate."
    ),
    
    'monsoon': ClimatePreset(
        name='Monsoon',
        lat_range=(10, 25),
        base_temp_range=(24, 28),
        wind_speed=12.0,
        wind_dir=135.0,
        precip_base=0.25,
        nm=0.007,
        hw=2800.0,
        cw=0.005,
        conv_time=800.0,
        fall_time=800.0,
        lapse_rate=5.5,
        precip_bins=(2000, 3500, 5500, 8000),  # Extreme rainfall
        description="Extreme seasonal rainfall. India/Southeast Asia-like."
    ),
    
    'oceanic': ClimatePreset(
        name='Oceanic',
        lat_range=(40, 60),
        base_temp_range=(8, 12),
        wind_speed=18.0,
        wind_dir=270.0,
        precip_base=0.2,
        nm=0.01,
        hw=2000.0,
        cw=0.004,
        conv_time=1000.0,
        fall_time=1000.0,
        lapse_rate=6.0,
        precip_bins=(1000, 1800, 2800, 4000),  # Very wet
        description="Mild, wet year-round. British Isles-like."
    ),
}
    
    @staticmethod
    def create_ocean_world(bounds: MapRect, 
                          preset: str = 'temperate',
                          radius: float = 15,
                          lon_span: float = 10.0,
                          custom_params: dict = None,
                          num_plates=None, 
                          ocean_fraction=0.4,
                          age = 0.25,
                          ruggedness: float = None,
                          factor=1.5, 
                          oceanic_sides=['N'],
                          
                          debug = False) -> Geology:
        """
        Create a blank ocean world ready for terrain generation.
        
        Args:
            bounds: MapRect for the hex grid
            preset: Climate preset name (see PRESETS)
            radius: Hex radius
            lon_span: Longitude span in degrees (lat span calculated from preset)
            custom_params: Override specific preset parameters
        
        Returns:
            Terrain with all-ocean elevations and climate parameters set
        """
        
        if preset not in TerrainFactory.PRESETS:
            raise ValueError(f"Unknown preset: {preset}. Available: {list(TerrainFactory.PRESETS.keys())}")
        
        climate_preset = TerrainFactory.PRESETS[preset]
        
        # Calculate geographic bounds
        lat_min, lat_max = climate_preset.lat_range
        lon_min = -lon_span / 2
        lon_max = lon_span / 2

        if ruggedness is None:
            ruggedness = 1.0 - age  # Young terrain is rugged
    
        slope = int(10 + ruggedness * 30)
        variation = int(20 + ruggedness * 60)
        
        # Create terrain with all ocean (elevation = 0)
        if num_plates is None:
            terrain = Terrain(bounds, radius=radius)
            terrain.elevations = np.zeros(len(terrain.elevations))  # All ocean
            plates = []
        else:
            terrain, plates = generate_plate_terrain(bounds, 
            radius=radius,slope=slope,variation=variation, 
            num_plates=num_plates, ocean_fraction=ocean_fraction,
            factor=factor, oceanic_sides=oceanic_sides
            )
        
        # Set geographic bounds
        terrain.geo = GeoBounds(
            lat_min=lat_min,
            lat_max=lat_max,
            lon_min=lon_min,
            lon_max=lon_max
        )
        
        # Compute hex coordinates
        terrain._compute_hex_coordinates()

        terrain.climate = climate_preset
        world = Geology(terrain,plates=plates,age=age,debug=debug)

        # Apply custom parameter overrides
        if custom_params:
            for key, value in custom_params.items():
                if hasattr(climate_preset, key):
                    setattr(climate_preset, key, value)
        if debug:
            print(f"\n=== TERRAIN FACTORY ===")
            print(f"Preset: {climate_preset.name}")
            print(f"Description: {climate_preset.description}")
            print(f"Latitude: {lat_min}° to {lat_max}°")
            print(f"Longitude: {lon_min}° to {lon_max}°")
            print(f"Grid: {terrain.hexGrid.nRows} x {terrain.hexGrid.nCols} hexes")
            print(f"Base temperature range: {climate_preset.base_temp_range[0]}°C to {climate_preset.base_temp_range[1]}°C")
            print(f"Wind: {climate_preset.wind_speed} m/s from {climate_preset.wind_dir}°")
        
        return world
    
    
    @staticmethod
    def list_presets():
        """Print all available climate presets."""
        print("\n=== AVAILABLE CLIMATE PRESETS ===\n")
        for name, preset in TerrainFactory.PRESETS.items():
            print(f"{name.upper()}")
            print(f"  Latitude: {preset.lat_range[0]}° to {preset.lat_range[1]}°")
            print(f"  Temperature: {preset.base_temp_range[0]}°C to {preset.base_temp_range[1]}°C")
            print(f"  {preset.description}")
            print()


# %% ../nbs/07_climate.ipynb #6e802311
@patch
def bayAreaMap(self:TerraDemo,debug = False):
    """Load Maui terrain with proper geographic bounds."""
    with open("data/templates/BayArea.txt", "r") as f:
        terrain = Terrain.decode(f.read())
    
    # Set Maui's geographic bounds
    terrain.geo = GeoBounds(
        lat_min=37.57,   # 
        lat_max=38.03,   # 
        lon_min=-122.69, # 
        lon_max=-121.97  # 
    )
    
    # Compute hex coordinates
    terrain._compute_hex_coordinates()
    
    terrain.climate =  ClimatePreset(
            name='Mediterranean',
            lat_range=(30, 45),
            base_temp_range=(14, 18),
            wind_speed=12.0,
            wind_dir=270.0,  # Westerlies
            precip_base=0.08,
            nm=0.01,
            hw=2000.0,
            cw=0.0025,
            conv_time=1500.0,
            fall_time=1500.0,
            lapse_rate=6.5,
            description="Mild winters, dry summers. California-like."
        )

    return terrain
